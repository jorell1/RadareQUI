// WARNING: [r2ghidra] Failed to match type LPSYSTEM_INFO for variable lpSystemInfo to Decompiler type: Unknown type
// identifier LPSYSTEM_INFO
// WARNING: [r2ghidra] Failed to match type PDWORD * for variable lpflOldProtect to Decompiler type: Unknown type
// identifier PDWORD
// WARNING: [r2ghidra] Failed to match type DWORD * for variable flNewProtect to Decompiler type: Unknown type
// identifier DWORD
// WARNING: [r2ghidra] Detected overlap for variable var_9h

void entry0(void)
{
    int32_t iVar1;
    int32_t *in_FS_OFFSET;
    undefined uVar2;
    int32_t iVar3;
    undefined4 uStack128;
    undefined *puStack124;
    int32_t iStack120;
    undefined4 uStack116;
    undefined *puStack112;
    int32_t var_5ch;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_1ch;
    uint32_t var_18h;
    int32_t var_14h;
    
    puStack124 = &stack0xfffffffc;
    var_5ch = 0;
    puStack112 = (undefined *)0x41184c;
    fcn.004065d4();
    uStack116 = 0x411efe;
    iStack120 = *in_FS_OFFSET;
    *in_FS_OFFSET = (int32_t)&iStack120;
    uStack128 = 0x411eba;
    iVar1 = *in_FS_OFFSET;
    *in_FS_OFFSET = (int32_t)&stack0xffffff7c;
    puStack112 = &stack0xfffffffc;
    fcn.0040ed58();
    fcn.0040e8ac();
    if (*(char *)0x412ae0 != '\0') {
        fcn.0040ee80();
        fcn.004046ac();
    }
    fcn.0040b8fc();
    fcn.00404c98(iVar1);
    *(int32_t **)0x41865c = (int32_t *)fcn.0040c238(1, 0, 2);
    *in_FS_OFFSET = (int32_t)&stack0xffffff64;
    *(int32_t *)0x418664 = fcn.0040ee2c();
    uVar2 = *(int32_t *)(*(int32_t *)0x418664 + 0xc) == 1;
    if ((bool)uVar2) {
        iVar1 = fcn.0040c738();
        uVar2 = iVar1 == *(int32_t *)(*(int32_t *)0x418664 + 0x28);
        if ((bool)uVar2) {
            (**(code **)(**(int32_t **)0x41865c + 4))();
            uVar2 = var_18h == 0;
            if (!(bool)uVar2) goto code_r0x00411930;
            (**(code **)(**(int32_t **)0x41865c + 4))();
            uVar2 = var_24h == *(uint32_t *)(*(int32_t *)0x418664 + 0x10);
            if (*(uint32_t *)(*(int32_t *)0x418664 + 0x10) <= (uint32_t)var_24h) goto code_r0x00411930;
        }
    }
    fcn.0040ec70();
code_r0x00411930:
    fcn.0040c220();
    fcn.0040c1f8();
    fcn.004031e0();
    if (!(bool)uVar2) {
        fcn.0040ec70();
    }
    *in_FS_OFFSET = (int32_t)&stack0xffffff58;
    *(undefined4 *)0x4186b8 = fcn.0040c854(*(int32_t *)0x40cbc0);
    *in_FS_OFFSET = (int32_t)&stack0xffffff48;
    iVar3 = 4;
    fcn.0040da38(4, 0x1c);
    *(int32_t *)0x418650 = *(int32_t *)0x4185ac;
    *(undefined4 *)0x41864c = fcn.00402dec();
    iVar1 = *(int32_t *)0x418650;
    if (-1 < *(int32_t *)0x418650 + -1) {
        do {
            iVar3 = 4;
            fcn.0040da38(4, 6);
            iVar1 = iVar1 + -1;
        } while (iVar1 != 0);
    }
    *in_FS_OFFSET = iVar3;
    fcn.00403894();
    return;
}


void fcn.00402be0(void)
{
    uint16_t uVar1;
    uint32_t uVar2;
    code **ppcVar3;
    int32_t iVar4;
    int32_t iVar5;
    
    iVar4 = 0x37;
    ppcVar3 = (code **)0x412078;
    do {
        if (*ppcVar3 == (code *)0x0) {
            *ppcVar3 = fcn.0040148c;
        }
        ppcVar3[-2] = (code *)(ppcVar3 + -7);
        ppcVar3[-6] = (code *)(ppcVar3 + -7);
        ppcVar3[-4] = (code *)0x0;
        ppcVar3[-5] = (code *)0x1;
        uVar2 = ((uint32_t)*(uint16_t *)((int32_t)ppcVar3 + -0x1a) * 0xc + 0xef & 0xffffff00) + 0x30;
        if (uVar2 < 0xb30) {
            uVar2 = 0xb30;
        }
        uVar2 = uVar2 + 0x4d0 >> 0xd;
        if (7 < uVar2) {
            uVar2 = 7;
        }
        *(char *)((int32_t)ppcVar3 + -0x1b) = -1 << ((uint8_t)uVar2 & 0x1f);
        *(int16_t *)(ppcVar3 + -1) = (int16_t)(uVar2 << 0xd) + 0xb30;
        uVar1 = *(uint16_t *)((int32_t)ppcVar3 + -0x1a);
        uVar2 = ((uint32_t)uVar1 * 0x30 + 0xef & 0xffffff00) + 0x30;
        if (uVar2 < 0x7330) {
            uVar2 = 0x7330;
        }
        if (0xff30 < uVar2) {
            uVar2 = 0xff30;
        }
        *(uint16_t *)((int32_t)ppcVar3 + -2) =
             ((int16_t)((uint64_t)(uVar2 - 0x20) / (uint64_t)uVar1) * uVar1 + 0xef & 0xff00) + 0x30;
        ppcVar3 = ppcVar3 + 8;
        iVar4 = iVar4 + -1;
    } while (iVar4 != 0);
    fcn.00402b9c();
    *(undefined4 *)0x413a24 = 0x413a24;
    *(undefined4 *)0x413a28 = 0x413a24;
    iVar5 = 0x400;
    iVar4 = 0x413ac4;
    do {
        *(int32_t *)iVar4 = iVar4;
        *(int32_t *)(iVar4 + 4) = iVar4;
        iVar4 = iVar4 + 8;
        iVar5 = iVar5 + -1;
    } while (iVar5 != 0);
    *(undefined4 *)0x415ac8 = 0x415ac8;
    *(undefined4 *)0x415acc = 0x415ac8;
    return;
}


undefined4 fcn.00406458(void)
{
    undefined auStack36 [16];
    undefined4 uStack20;
    
    sub.kernel32.dll_GetSystemInfo(auStack36);
    return uStack20;
}


undefined4 fcn.004036e4(void)
{
    int32_t iVar1;
    uint32_t uVar2;
    undefined4 uVar3;
    
    uVar3 = 0;
    iVar1 = sub.user32.dll_GetKeyboardType(0);
    if (iVar1 == 7) {
        uVar2 = sub.user32.dll_GetKeyboardType(1);
        if (((uVar2 & 0xff00) == 0xd00) || ((uVar2 & 0xff00) == 0x400)) {
            uVar3 = 1;
        }
    }
    return uVar3;
}


// WARNING: Could not reconcile some variable overlaps
// WARNING: [r2ghidra] Failed to match type HKEY for variable hKey to Decompiler type: Unknown type identifier HKEY

void fcn.00403714(void)
{
    int32_t iVar1;
    undefined4 *in_FS_OFFSET;
    undefined4 uVar2;
    undefined4 uStack48;
    undefined4 uStack44;
    undefined *puStack40;
    undefined4 uStack36;
    undefined4 uStack32;
    undefined4 uStack28;
    undefined4 uStack24;
    undefined4 *puStack20;
    int32_t var_ch;
    int32_t var_8h;
    undefined4 hKey;
    
    var_8h = ZEXT24(*(uint16_t *)0x41201c);
    puStack20 = &hKey;
    uStack24 = 1;
    uStack28 = 0;
    uStack32 = 0x4037ac;
    uStack36 = 0x80000002;
    puStack40 = (undefined *)0x40373b;
    iVar1 = sub.advapi32.dll_RegOpenKeyExW();
    if (iVar1 == 0) {
        uStack44 = 0x403785;
        uStack48 = *in_FS_OFFSET;
        *in_FS_OFFSET = &uStack48;
        var_ch = 4;
        uVar2 = hKey;
        puStack40 = &stack0xfffffffc;
        sub.advapi32.dll_RegQueryValueExW(hKey, 0x4037e4, 0, 0, &var_8h, &var_ch);
        *in_FS_OFFSET = uVar2;
        sub.advapi32.dll_RegCloseKey(hKey, 0x40378c);
        return;
    }
    *(uint16_t *)0x41201c = *(uint16_t *)0x41201c & 0xffc0 | (uint16_t)var_8h & 0x3f;
    return;
}


void fcn.00403800(void)
{
    return;
}


undefined2 fcn.004011c0(void)
{
    undefined2 uVar1;
    undefined4 auStack72 [10];
    uint8_t uStack32;
    undefined2 uStack28;
    
    auStack72[0] = 0x44;
    sub.kernel32.dll_GetStartupInfoA(auStack72);
    uVar1 = 10;
    if ((uStack32 & 1) != 0) {
        uVar1 = uStack28;
    }
    return uVar1;
}


void fcn.0040646c(void)
{
    uint32_t uVar1;
    
    uVar1 = sub.kernel32.dll_GetVersion();
    if ((((uVar1 & 0xff) != 5) || ((uVar1 & 0xff00) == 0)) && ((uVar1 & 0xff) < 6)) {
        *(undefined4 *)0x4138d0 = 0x409;
        return;
    }
    *(undefined4 *)0x4138d0 = 0x7f;
    return;
}


// WARNING: [r2ghidra] Failed to match type LPWSTR for variable lpBuffer to Decompiler type: Unknown type identifier
// LPWSTR

void fcn.0040699c(void)
{
    undefined auStack524 [520];
    
    sub.kernel32.dll_GetSystemDirectoryW(auStack524, 0x104);
    fcn.00406988();
    return;
}


void fcn.00406988(void)
{
    fcn.00404e14();
    return;
}


void __fastcall fcn.00404e14(undefined4 param_1, int16_t *param_2)
{
    undefined4 uVar1;
    undefined4 *in_EAX;
    int16_t *piVar2;
    
    piVar2 = param_2;
    if (param_2 != (int16_t *)0x0) {
        while ((((*piVar2 != 0 && (piVar2[1] != 0)) && (piVar2[2] != 0)) && (piVar2[3] != 0))) {
            piVar2 = piVar2 + 4;
        }
    }
    uVar1 = fcn.004054b4();
    if (param_2 != (int16_t *)0x0) {
        fcn.00402fbc();
    }
    fcn.004046c4();
    *in_EAX = uVar1;
    return;
}


// WARNING: Possible PIC construction at 0x00404dcc: Changing call to branch
// WARNING: Removing unreachable block (ram,0x00404dd1)
// WARNING: [r2ghidra] Failed to match type UINT for variable CodePage to Decompiler type: Unknown type identifier UINT

void __fastcall fcn.00404e6c(undefined4 param_1, int32_t param_2)
{
    int32_t *piVar1;
    int32_t iVar2;
    int32_t *in_EAX;
    int32_t iVar3;
    uint32_t unaff_retaddr;
    
    do {
        iVar3 = 0;
        if (param_2 == 0) {
code_r0x00404d30:
            if (iVar3 < 1) {
                fcn.00404c88();
            } else {
                if ((iVar3 + 1 < 0x7ff) && (iVar2 = fcn.004047ec(unaff_retaddr, iVar3), 0 < iVar2)) {
                    fcn.00404dd4();
                } else {
                    fcn.00404f00();
                    fcn.004047ec(unaff_retaddr, iVar3);
                    fcn.00404f00();
                }
            }
            return;
        }
        if (*(int16_t *)(param_2 + -10) != 2) {
            unaff_retaddr = (uint32_t)*(uint16_t *)(param_2 + -0xc);
            iVar3 = *(int32_t *)(param_2 + -4);
            goto code_r0x00404d30;
        }
        if (param_2 == 0) goto code_r0x00404cce;
    } while (*(int16_t *)(param_2 + -10) != 2);
    iVar3 = *(int32_t *)(param_2 + -8);
    if (iVar3 == -1 || SCARRY4(iVar3, 1) != iVar3 + 1 < 0) {
        param_2 = fcn.004054b4(param_2);
        fcn.00402fbc();
    } else {
        LOCK();
        *(int32_t *)(param_2 + -8) = *(int32_t *)(param_2 + -8) + 1;
    }
code_r0x00404cce:
    iVar3 = *in_EAX;
    *in_EAX = param_2;
    if ((iVar3 != 0) && (0 < *(int32_t *)(iVar3 + -8))) {
        LOCK();
        piVar1 = (int32_t *)(iVar3 + -8);
        *piVar1 = *piVar1 + -1;
        if (*piVar1 == 0) {
            fcn.00402e20();
        }
    }
    return;
}


// WARNING: Possible PIC construction at 0x00404dcc: Changing call to branch
// WARNING: Removing unreachable block (ram,0x00404dd1)
// WARNING: Removing unreachable block (ram,0x00402f34)
// WARNING: [r2ghidra] Failed to match type UINT for variable CodePage to Decompiler type: Unknown type identifier UINT

int32_t * __fastcall fcn.00404f98(undefined4 param_1, int32_t *param_2)
{
    int32_t iVar1;
    int32_t **in_EAX;
    int32_t *piVar2;
    int32_t iVar3;
    uint32_t unaff_retaddr;
    int32_t *piVar4;
    
    if (param_2 == (int32_t *)0x0) {
        return (int32_t *)in_EAX;
    }
    piVar2 = *in_EAX;
    if (piVar2 == (int32_t *)0x0) {
        do {
            if (param_2 == (int32_t *)0x0) {
code_r0x00404cce:
                piVar2 = *in_EAX;
                *in_EAX = param_2;
                if ((piVar2 != (int32_t *)0x0) && (0 < piVar2[-2])) {
                    LOCK();
                    piVar2 = piVar2 + -2;
                    *piVar2 = *piVar2 + -1;
                    if (*piVar2 == 0) {
                        in_EAX = (int32_t **)fcn.00402e20();
                    }
                }
                return (int32_t *)in_EAX;
            }
            if (*(int16_t *)((int32_t)param_2 + -10) == 2) {
                iVar3 = param_2[-2];
                if (iVar3 == -1 || SCARRY4(iVar3, 1) != iVar3 + 1 < 0) {
                    param_2 = (int32_t *)fcn.004054b4(param_2);
                    fcn.00402fbc();
                } else {
                    LOCK();
                    param_2[-2] = param_2[-2] + 1;
                }
                goto code_r0x00404cce;
            }
            iVar3 = 0;
            if (param_2 == (int32_t *)0x0) goto code_r0x00404d30;
        } while (*(int16_t *)((int32_t)param_2 + -10) == 2);
        unaff_retaddr = (uint32_t)*(uint16_t *)(param_2 + -3);
        iVar3 = param_2[-1];
code_r0x00404d30:
        if (iVar3 < 1) {
            piVar2 = (int32_t *)fcn.00404c88();
        } else {
            if ((iVar3 + 1 < 0x7ff) && (iVar1 = fcn.004047ec(unaff_retaddr, iVar3), 0 < iVar1)) {
                piVar2 = (int32_t *)fcn.00404dd4();
            } else {
                fcn.00404f00();
                fcn.004047ec(unaff_retaddr, iVar3);
                piVar2 = (int32_t *)fcn.00404f00();
            }
        }
        return piVar2;
    }
    if (param_2 == piVar2) {
        if (*(int16_t *)((int32_t)piVar2 + -10) != 2) {
            piVar2 = (int32_t *)fcn.00404830();
        }
        if ((piVar2[-1] & 0x60000000U) != 0) goto code_r0x00402f14;
        fcn.00404f00();
        piVar4 = (int32_t *)0x0;
    } else {
        if (*(int16_t *)((int32_t)piVar2 + -10) != 2) {
            piVar2 = (int32_t *)fcn.00404830();
        }
        piVar4 = (int32_t *)0x0;
        if (*(int16_t *)((int32_t)param_2 + -10) != 2) {
            fcn.00404c80();
            fcn.00404830();
            piVar4 = param_2;
        }
        if ((param_2[-1] + piVar2[-1] & 0xc0000000U) != 0) {
code_r0x00402f14:
            if (*(code **)0x413008 != (code *)0x0) {
                (**(code **)0x413008)(param_2);
            }
            piVar2 = (int32_t *)fcn.00402f08();
            return piVar2;
        }
        fcn.00404f00();
    }
    fcn.00402fbc();
    if (piVar4 != (int32_t *)0x0) {
        fcn.004046c4();
    }
    return piVar4;
}


// WARNING: Possible PIC construction at 0x00404dcc: Changing call to branch
// WARNING: Removing unreachable block (ram,0x00404dd1)
// WARNING: Removing unreachable block (ram,0x00402f34)
// WARNING: [r2ghidra] Failed to match type UINT for variable CodePage to Decompiler type: Unknown type identifier UINT

int32_t ** __fastcall fcn.00405058(int32_t **param_1, int32_t **param_2)
{
    int32_t **ppiVar1;
    int32_t iVar2;
    int32_t **ppiVar3;
    int32_t **in_EAX;
    int32_t *piVar4;
    int32_t unaff_EDI;
    uint32_t unaff_retaddr;
    
    ppiVar1 = param_1;
    if ((param_2 != (int32_t **)0x0) && (ppiVar1 = param_2, param_1 != (int32_t **)0x0)) {
        if (param_2 != (int32_t **)*in_EAX) {
            if (param_1 == (int32_t **)*in_EAX) {
                ppiVar3 = (int32_t **)0x0;
                ppiVar1 = (int32_t **)0x0;
                if (*(int16_t *)((int32_t)param_1 + -10) != 2) {
                    fcn.00404c80();
                    fcn.00404830();
                    ppiVar1 = param_1;
                }
                if (*(int16_t *)((int32_t)param_2 + -10) != 2) {
                    fcn.00404c80();
                    fcn.00404830();
                    ppiVar3 = param_2;
                }
                in_EAX = param_2;
                if (((int32_t)param_2[-1] + (int32_t)param_1[-1] & 0xc0000000U) == 0) {
                    iVar2 = fcn.004054b4();
                    fcn.00402fbc();
                    fcn.00402fbc();
                    if (((uint32_t)ppiVar1 | (uint32_t)ppiVar3) != 0) {
                        fcn.004046e8();
                    }
                    if (iVar2 != 0) {
                        *(int32_t *)(iVar2 + -8) = *(int32_t *)(iVar2 + -8) + -1;
                    }
                    ppiVar1 = (int32_t **)fcn.00404c98(unaff_EDI);
                    return ppiVar1;
                }
                goto code_r0x00402f14;
            }
            fcn.00404c98((int32_t)param_1);
        }
        if (param_1 == (int32_t **)0x0) {
            return in_EAX;
        }
        ppiVar3 = (int32_t **)*in_EAX;
        ppiVar1 = param_1;
        if (ppiVar3 != (int32_t **)0x0) {
            if (param_1 == ppiVar3) {
                if (*(int16_t *)((int32_t)ppiVar3 + -10) != 2) {
                    ppiVar3 = (int32_t **)fcn.00404830();
                }
                if (((uint32_t)ppiVar3[-1] & 0x60000000) == 0) {
                    fcn.00404f00();
                    ppiVar1 = (int32_t **)0x0;
                    goto code_r0x00405002;
                }
            } else {
                if (*(int16_t *)((int32_t)ppiVar3 + -10) != 2) {
                    ppiVar3 = (int32_t **)fcn.00404830();
                }
                ppiVar1 = (int32_t **)0x0;
                if (*(int16_t *)((int32_t)param_1 + -10) != 2) {
                    fcn.00404c80();
                    fcn.00404830();
                    ppiVar1 = param_1;
                }
                if (((int32_t)param_1[-1] + (int32_t)ppiVar3[-1] & 0xc0000000U) == 0) {
                    fcn.00404f00();
code_r0x00405002:
                    fcn.00402fbc();
                    if (ppiVar1 != (int32_t **)0x0) {
                        fcn.004046c4();
                    }
                    return ppiVar1;
                }
            }
code_r0x00402f14:
            if (*(code **)0x413008 != (code *)0x0) {
                (**(code **)0x413008)(param_1, in_EAX);
            }
            ppiVar1 = (int32_t **)fcn.00402f08();
            return ppiVar1;
        }
    }
    do {
        if (ppiVar1 == (int32_t **)0x0) {
code_r0x00404cce:
            piVar4 = *in_EAX;
            *in_EAX = (int32_t *)ppiVar1;
            if ((piVar4 != (int32_t *)0x0) && (0 < piVar4[-2])) {
                LOCK();
                piVar4 = piVar4 + -2;
                *piVar4 = *piVar4 + -1;
                if (*piVar4 == 0) {
                    in_EAX = (int32_t **)fcn.00402e20();
                }
            }
            return in_EAX;
        }
        if (*(int16_t *)((int32_t)ppiVar1 + -10) == 2) {
            piVar4 = ppiVar1[-2];
            if (piVar4 == (int32_t *)0xffffffff || SCARRY4((int32_t)piVar4, 1) != (int32_t)piVar4 + 1 < 0) {
                ppiVar1 = (int32_t **)fcn.004054b4(ppiVar1);
                fcn.00402fbc();
            } else {
                LOCK();
                ppiVar1[-2] = (int32_t *)((int32_t)ppiVar1[-2] + 1);
            }
            goto code_r0x00404cce;
        }
        piVar4 = (int32_t *)0x0;
        if (ppiVar1 == (int32_t **)0x0) goto code_r0x00404d30;
    } while (*(int16_t *)((int32_t)ppiVar1 + -10) == 2);
    unaff_retaddr = (uint32_t)*(uint16_t *)(ppiVar1 + -3);
    piVar4 = ppiVar1[-1];
code_r0x00404d30:
    if ((int32_t)piVar4 < 1) {
        ppiVar1 = (int32_t **)fcn.00404c88();
    } else {
        if (((int32_t)piVar4 + 1 < 0x7ff) && (iVar2 = fcn.004047ec(unaff_retaddr, (int32_t)piVar4), 0 < iVar2)) {
            ppiVar1 = (int32_t **)fcn.00404dd4();
        } else {
            fcn.00404f00();
            fcn.004047ec(unaff_retaddr, (int32_t)piVar4);
            ppiVar1 = (int32_t **)fcn.00404f00();
        }
    }
    return ppiVar1;
}


// WARNING: [r2ghidra] Failed to match type UINT for variable var_ch to Decompiler type: Unknown type identifier UINT
// WARNING: [r2ghidra] Failed to match type HMODULE for variable var_8h to Decompiler type: Unknown type identifier
// HMODULE

void fcn.004069c8(void)
{
    undefined4 uVar1;
    undefined4 *in_FS_OFFSET;
    undefined4 uStack48;
    undefined4 uStack44;
    undefined *puStack40;
    undefined4 uStack36;
    undefined4 uStack32;
    undefined *puStack28;
    undefined4 uStack24;
    undefined4 var_ch;
    undefined4 var_8h;
    
    puStack40 = &stack0xfffffffc;
    uStack24 = 0x8000;
    puStack28 = (undefined *)0x4069db;
    var_ch = sub.kernel32.dll_SetErrorMode();
    uStack32 = 0x406a3e;
    uStack36 = *in_FS_OFFSET;
    *in_FS_OFFSET = &uStack36;
    uStack44 = 0x406a20;
    uStack48 = *in_FS_OFFSET;
    *in_FS_OFFSET = &uStack48;
    puStack28 = &stack0xfffffffc;
    uVar1 = fcn.00404d24();
    sub.kernel32.dll_LoadLibraryW();
    *in_FS_OFFSET = uVar1;
    return;
}


int32_t fcn.00404d24(void)
{
    int32_t in_EAX;
    
    if (in_EAX != 0) {
        return in_EAX;
    }
    return 0x4127a8;
}


void __fastcall fcn.00404c90(undefined4 param_1, int32_t param_2)
{
    int32_t *piVar1;
    int32_t iVar2;
    int32_t *in_EAX;
    
    do {
        iVar2 = *in_EAX;
        if ((iVar2 != 0) && (*in_EAX = 0, 0 < *(int32_t *)(iVar2 + -8))) {
            LOCK();
            piVar1 = (int32_t *)(iVar2 + -8);
            *piVar1 = *piVar1 + -1;
            if (*piVar1 == 0) {
                fcn.00402e20();
            }
        }
        in_EAX = in_EAX + 1;
        param_2 = param_2 + -1;
    } while (param_2 != 0);
    return;
}


void fcn.004043d0(void)
{
    int32_t iVar1;
    code *pcVar2;
    int32_t *in_EAX;
    int32_t *piVar3;
    int32_t iVar4;
    
    iVar4 = *in_EAX;
    piVar3 = in_EAX + 1;
    do {
        iVar1 = piVar3[2];
        if (iVar1 == 0) {
            fcn.00404318();
        } else {
            if (iVar1 == 1) {
                fcn.0040436c();
            } else {
                if (iVar1 != 2) {
                    pcVar2 = (code *)swi(3);
                    (*pcVar2)();
                    return;
                }
                fcn.004043bc();
            }
        }
        piVar3 = piVar3 + 3;
        iVar4 = iVar4 + -1;
    } while (iVar4 != 0);
    return;
}


// WARNING: [r2ghidra] Var arg_2000h is stack pointer based, which is not supported for decompilation.

void fcn.00404318(void)
{
    int32_t *in_FS_OFFSET;
    int32_t arg_8h;
    undefined4 uStack24;
    undefined *puStack20;
    int32_t var_4h;
    
    puStack20 = &stack0xfffffffc;
    var_4h = 0;
    uStack24 = 0x404360;
    arg_8h = *in_FS_OFFSET;
    *in_FS_OFFSET = (int32_t)&stack0xffffffe4;
    fcn.004063e4();
    fcn.00404e94(arg_8h);
    *in_FS_OFFSET = arg_8h;
    puStack20 = (undefined *)0x404367;
    uStack24 = 0x40435f;
    fcn.00404c88();
    return;
}


// WARNING: [r2ghidra] Var arg_2000h is stack pointer based, which is not supported for decompilation.

void fcn.004063e4(void)
{
    int32_t iVar1;
    undefined4 uVar2;
    int32_t in_stack_00000ff4;
    undefined auStack4104 [4092];
    int32_t iStack12;
    
    iVar1 = 2;
    do {
        iStack12 = iVar1;
        iVar1 = iStack12 + -1;
    } while (iStack12 + -1 != 0);
    if (in_stack_00000ff4 != 0) {
        if (*(int32_t *)(in_stack_00000ff4 + 4) < 0x10000) {
            uVar2 = fcn.00405b90(*(undefined4 *)(in_stack_00000ff4 + 4), auStack4104, 0x1000);
            sub.user32.dll_LoadStringW(uVar2);
            fcn.00404dd4();
        } else {
            fcn.00404e14();
        }
    }
    return;
}


void __fastcall fcn.00404718(undefined4 param_1, int32_t param_2)
{
    int32_t *piVar1;
    int32_t *in_EAX;
    int32_t iVar2;
    int32_t iVar3;
    uint32_t uVar4;
    
    do {
        if (param_2 == 0) {
code_r0x00404756:
            iVar3 = *in_EAX;
            *in_EAX = param_2;
            if ((iVar3 != 0) && (0 < *(int32_t *)(iVar3 + -8))) {
                LOCK();
                piVar1 = (int32_t *)(iVar3 + -8);
                *piVar1 = *piVar1 + -1;
                if (*piVar1 == 0) {
                    fcn.00402e20();
                }
            }
            return;
        }
        if (*(int16_t *)(param_2 + -10) == 1) {
            iVar3 = *(int32_t *)(param_2 + -8);
            if (iVar3 == -1 || SCARRY4(iVar3, 1) != iVar3 + 1 < 0) {
                param_2 = fcn.00404774(param_2);
                fcn.00402fbc();
            } else {
                LOCK();
                *(int32_t *)(param_2 + -8) = *(int32_t *)(param_2 + -8) + 1;
            }
            goto code_r0x00404756;
        }
        iVar3 = 0;
        if (param_2 == 0) goto code_r0x00404ea8;
    } while (*(int16_t *)(param_2 + -10) == 1);
    iVar3 = *(int32_t *)(param_2 + -4);
code_r0x00404ea8:
    if (iVar3 < 1) {
        fcn.004046c4();
    } else {
        uVar4 = *(uint32_t *)0x4138c8;
        if ((int16_t)*(uint32_t *)0x4138c8 == 0) {
            uVar4 = *(uint32_t *)0x4138c8 & 0xffff;
        }
        iVar2 = fcn.004047c0(uVar4 & 0xffff, iVar3);
        fcn.004049c4();
        if (iVar2 < 1) {
            fcn.004046c4();
        } else {
            fcn.004047c0(uVar4 & 0xffff, iVar3);
            *(int16_t *)(*in_EAX + -0xc) = (int16_t)uVar4;
        }
    }
    return;
}


void fcn.00404c88(void)
{
    int32_t *piVar1;
    int32_t iVar2;
    int32_t *in_EAX;
    
    iVar2 = *in_EAX;
    if ((iVar2 != 0) && (*in_EAX = 0, 0 < *(int32_t *)(iVar2 + -8))) {
        LOCK();
        piVar1 = (int32_t *)(iVar2 + -8);
        *piVar1 = *piVar1 + -1;
        if (*piVar1 == 0) {
            fcn.00402e20();
        }
    }
    return;
}


// WARNING: Removing unreachable block (ram,0x00402f34)

void fcn.00402e20(void)
{
    int32_t in_EAX;
    int32_t iVar1;
    
    if ((in_EAX != 0) && (iVar1 = (**(code **)0x412740)(), iVar1 != 0)) {
        if (*(code **)0x413008 != (code *)0x0) {
            (**(code **)0x413008)();
        }
        fcn.00402f08();
        return;
    }
    return;
}


// WARNING: [r2ghidra] Var arg_2000h is stack pointer based, which is not supported for decompilation.
// WARNING: [r2ghidra] Var arg_4h is stack pointer based, which is not supported for decompilation.

void fcn.0040436c(void)
{
    undefined4 *in_FS_OFFSET;
    undefined4 uStack28;
    undefined4 uStack24;
    undefined *puStack20;
    int32_t var_4h;
    
    puStack20 = &stack0xfffffffc;
    var_4h = 0;
    uStack24 = 0x4043af;
    uStack28 = *in_FS_OFFSET;
    *in_FS_OFFSET = &uStack28;
    fcn.004063e4();
    fcn.00404ecc();
    *in_FS_OFFSET = uStack28;
    puStack20 = (undefined *)0x4043b6;
    uStack24 = 0x4043ae;
    fcn.00404c88();
    return;
}


// WARNING: Removing unreachable block (ram,0x00402f34)
// WARNING: Variable defined which should be unmapped: var_1004h
// WARNING: Variable defined which should be unmapped: var_4h
// WARNING: [r2ghidra] Var arg_4h is stack pointer based, which is not supported for decompilation.
// WARNING: [r2ghidra] Failed to match type UINT for variable CodePage to Decompiler type: Unknown type identifier UINT

void __fastcall fcn.00404ecc(undefined4 param_1, int32_t *param_2)
{
    int32_t iVar1;
    int32_t *in_EAX;
    int32_t iVar2;
    uint32_t CodePage;
    int32_t var_1004h;
    int32_t var_4h;
    
    iVar2 = 0;
    if ((param_2 != (int32_t *)0x0) && (iVar2 = param_2[-1], *(int16_t *)((int32_t)param_2 + -10) != 2)) {
        CodePage = (uint32_t)*(uint16_t *)(param_2 + -3);
        if (iVar2 < 1) {
            fcn.00404a8c();
        } else {
            if ((iVar2 + 1 < 0x7ff) && (iVar1 = fcn.004047ec(CodePage, iVar2), 0 < iVar1)) {
                fcn.00404b9c();
            } else {
                fcn.00404c2c();
                fcn.00404c1c();
                fcn.004047ec(CodePage, iVar2);
                fcn.00404c2c();
            }
        }
        return;
    }
    if (iVar2 == 0) {
        iVar2 = *in_EAX;
        if (iVar2 != 0) {
            *in_EAX = 0;
            sub.oleaut32.dll_SysFreeString(iVar2);
        }
        return;
    }
    iVar2 = sub.oleaut32.dll_SysAllocStringLen(param_2, iVar2);
    if (iVar2 != 0) {
        iVar1 = *param_2;
        *param_2 = iVar2;
        sub.oleaut32.dll_SysFreeString(iVar1);
        return;
    }
    if (*(code **)0x413008 != (code *)0x0) {
        (**(code **)0x413008)();
    }
    fcn.00402f08();
    return;
}


// WARNING: [r2ghidra] Var arg_2000h is stack pointer based, which is not supported for decompilation.

void fcn.004043bc(void)
{
    fcn.004063e4();
    return;
}


void fcn.00404414(void)
{
    int32_t *in_EAX;
    int32_t **ppiVar1;
    int32_t iVar2;
    
    iVar2 = *in_EAX;
    ppiVar1 = (int32_t **)(in_EAX + 1);
    do {
        **ppiVar1 = *ppiVar1[1] + (int32_t)ppiVar1[2];
        ppiVar1 = ppiVar1 + 3;
        iVar2 = iVar2 + -1;
    } while (iVar2 != 0);
    return;
}


void fcn.0040a00c(void)
{
    *(undefined4 *)0x415c9c = fcn.004098e0();
    *(undefined4 *)0x415ca0 = fcn.004098e0();
    **(undefined4 **)0x412b24 = 0x409b64;
    **(code ***)0x412b80 = fcn.00409ffc;
    **(undefined4 **)0x412b44 = *(undefined4 *)0x406d5c;
    **(undefined4 **)0x412b74 = 0x409d24;
    **(undefined4 **)0x412b84 = 0x409f08;
    **(undefined4 **)0x412b88 = 0x409fd8;
    **(undefined4 **)0x412c00 = 0x409c70;
    **(undefined4 **)0x412b18 = 0x409c8c;
    return;
}


// WARNING: [r2ghidra] Var arg_10h is stack pointer based, which is not supported for decompilation.
// WARNING: [r2ghidra] Var arg_2000h is stack pointer based, which is not supported for decompilation.

undefined4 __fastcall fcn.004098e0(undefined4 param_1, char param_2)
{
    undefined4 in_EAX;
    char extraout_DL;
    undefined4 *in_FS_OFFSET;
    undefined4 uStack28;
    
    if (param_2 != '\0') {
        in_EAX = fcn.004039e4();
        param_2 = extraout_DL;
    }
    fcn.004063e4();
    if (param_2 != '\0') {
        fcn.00403a3c();
        *in_FS_OFFSET = uStack28;
    }
    return in_EAX;
}


void fcn.0040a2b8(void)
{
    **(undefined4 **)0x412bb4 = 0x4129c4;
    return;
}


void fcn.00406114(void)
{
    undefined4 in_EAX;
    undefined4 *puVar1;
    
    puVar1 = (undefined4 *)fcn.00402e04();
    *puVar1 = *(undefined4 *)0x412030;
    puVar1[1] = in_EAX;
    *(undefined4 **)0x412030 = puVar1;
    return;
}


// WARNING: Removing unreachable block (ram,0x00402f34)

int32_t fcn.00402e04(void)
{
    int32_t in_EAX;
    int32_t iVar1;
    
    if (in_EAX < 1) {
        return 0;
    }
    iVar1 = (**(code **)0x41273c)();
    if (iVar1 == 0) {
        if (*(code **)0x413008 != (code *)0x0) {
            (**(code **)0x413008)();
        }
        iVar1 = fcn.00402f08();
        return iVar1;
    }
    return iVar1;
}


// WARNING: Removing unreachable block (ram,0x00402f34)

void __fastcall fcn.00404b9c(int32_t param_1, int32_t *param_2)
{
    int32_t iVar1;
    int32_t *in_EAX;
    int32_t iVar2;
    
    if (param_1 == 0) {
        iVar2 = *in_EAX;
        if (iVar2 != 0) {
            *in_EAX = 0;
            sub.oleaut32.dll_SysFreeString(iVar2);
        }
        return;
    }
    iVar2 = sub.oleaut32.dll_SysAllocStringLen(param_2, param_1);
    if (iVar2 == 0) {
        if (*(code **)0x413008 != (code *)0x0) {
            (**(code **)0x413008)();
        }
        fcn.00402f08();
        return;
    }
    iVar1 = *param_2;
    *param_2 = iVar2;
    sub.oleaut32.dll_SysFreeString(iVar1);
    return;
}


// WARNING: [r2ghidra] Var arg_10h is stack pointer based, which is not supported for decompilation.
// WARNING: [r2ghidra] Var arg_4h is stack pointer based, which is not supported for decompilation.
// WARNING: [r2ghidra] Var arg_8h is stack pointer based, which is not supported for decompilation.
// WARNING: [r2ghidra] Var arg_ch is stack pointer based, which is not supported for decompilation.
// WARNING: [r2ghidra] Var arg_14h is stack pointer based, which is not supported for decompilation.

void fcn.0040a358(void)
{
    int32_t iVar1;
    undefined4 uStack276;
    undefined4 uStack272;
    uint32_t uStack268;
    int32_t iStack264;
    
    uStack276 = 0x114;
    iVar1 = sub.kernel32.dll_GetVersionExW(&uStack276);
    if (iVar1 != 0) {
        *(int32_t *)0x4127d8 = iStack264;
        *(undefined4 *)0x4127dc = uStack276;
        *(undefined4 *)0x4127e0 = uStack272;
        if (iStack264 == 1) {
            *(uint32_t *)0x4127e4 = uStack268 & 0xffff;
        } else {
            *(uint32_t *)0x4127e4 = uStack268;
        }
        fcn.00404e50();
    }
    return;
}


void fcn.0040abf8(void)
{
    int32_t arg_8h;
    
    arg_8h = sub.kernel32.dll_GetModuleHandleW_2(0x40ac30);
    if (arg_8h != 0) {
        *(int32_t *)0x412810 = fcn.00406728(arg_8h, 0x40ac4c);
    }
    if (*(int32_t *)0x412810 == 0) {
        *(int32_t *)0x412810 = 0x408068;
    }
    return;
}


// WARNING: Variable defined which should be unmapped: var_40h
// WARNING: Variable defined which should be unmapped: var_ch
// WARNING: [r2ghidra] Failed to match type LCID for variable var_4h to Decompiler type: Unknown type identifier LCID
// WARNING: [r2ghidra] Failed to match type LPWSTR for variable lpLCData to Decompiler type: Unknown type identifier
// LPWSTR
// WARNING: [r2ghidra] Removing arg arg_4h because it doesn't fit into ProtoModel

void fcn.0040a5a8(void)
{
    int32_t iVar1;
    int32_t unaff_EBX;
    int32_t *in_FS_OFFSET;
    int32_t var_40h;
    int32_t var_3ch;
    int32_t var_38h;
    int32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_18h;
    int32_t var_14h;
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    
    var_10h = (int32_t)&stack0xfffffffc;
    iVar1 = 8;
    do {
        iVar1 = iVar1 + -1;
    } while (iVar1 != 0);
    var_14h = 0x40a886;
    var_18h = *in_FS_OFFSET;
    *in_FS_OFFSET = (int32_t)&var_18h;
    var_1ch = 0x40a5cb;
    fcn.0040a4f0();
    var_1ch = 0x40a5d0;
    fcn.00408f68();
    if (*(char *)0x415c3c != '\0') {
        var_1ch = 0x40a5de;
        fcn.00409140();
    }
    var_1ch = 0x40a5e3;
    sub.kernel32.dll_GetThreadLocale_1();
    var_1ch = (int32_t)&var_10h;
    fcn.00408eb4(var_1ch);
    fcn.00404c98(var_1ch);
    var_24h = 0x40a619;
    fcn.00408eb4((int32_t)&var_14h);
    var_24h = 0x40a623;
    *(undefined *)0x415b70 = fcn.00407f10();
    var_24h = (int32_t)&var_18h;
    fcn.00408eb4(var_24h);
    *(undefined *)0x415b71 = fcn.00407f10();
    *(undefined2 *)0x415b72 = fcn.00408f00();
    *(undefined2 *)0x415b74 = fcn.00408f00();
    var_2ch = 0x40a68d;
    fcn.00408eb4((int32_t)&var_1ch);
    var_2ch = 0x40a697;
    *(undefined *)0x415b76 = fcn.00407f10();
    var_2ch = 0x40a6ac;
    *(undefined2 *)0x415b78 = fcn.00408f00();
    var_2ch = (int32_t)&var_24h;
    var_30h = 0x40a6c7;
    fcn.00408eb4(var_2ch);
    var_30h = 0x40a6d2;
    fcn.004091f4();
    var_30h = 0x40a6df;
    fcn.00404c98(var_2ch);
    var_30h = (int32_t)&var_2ch;
    var_34h = 0x40a6f4;
    fcn.00408eb4(var_30h);
    var_34h = 0x40a6ff;
    fcn.004091f4();
    var_34h = 0x40a70c;
    fcn.00404c98(var_30h);
    var_34h = 0x40a71c;
    *(undefined2 *)0x415b84 = fcn.00408f00();
    var_34h = (int32_t)&var_30h;
    var_38h = 0x40a737;
    fcn.00408eb4(var_34h);
    var_38h = 0x40a744;
    fcn.00404c98(var_34h);
    var_38h = (int32_t)&var_34h;
    var_3ch = 0x40a759;
    fcn.00408eb4(var_38h);
    var_3ch = 0x40a766;
    fcn.00404c98(var_38h);
    var_3ch = 0x40a770;
    fcn.00404cec();
    var_3ch = 0x40a77a;
    fcn.00404cec();
    var_3ch = (int32_t)&var_38h;
    var_40h = 0x40a78f;
    fcn.00408eb4(var_3ch);
    var_40h = 0x40a799;
    iVar1 = fcn.00407f10();
    if (iVar1 == 0) {
        var_40h = 0x40a7aa;
        fcn.00404cec();
    } else {
        var_40h = 0x40a7b9;
        fcn.00404cec();
    }
    var_40h = (int32_t)&var_3ch;
    fcn.00408eb4(var_40h);
    iVar1 = fcn.00407f10();
    if (iVar1 == 0) {
        fcn.00408eb4((int32_t)&var_40h);
        iVar1 = fcn.00407f10();
        if (iVar1 == 0) {
            fcn.00404cec();
        } else {
            fcn.00404cec();
        }
    }
    fcn.0040513c(unaff_EBX, 0x40a970, 0, var_8h);
    fcn.0040513c(unaff_EBX, 0x40a984, 0, var_8h);
    *(undefined2 *)0x415c3e = fcn.00408f00();
    *in_FS_OFFSET = unaff_EBX;
    fcn.00404c90(0x40a88d);
    return;
}


void __cdecl fcn.00406728(int32_t arg_8h, int32_t arg_ch)
{
    undefined4 uVar1;
    int32_t *in_FS_OFFSET;
    int32_t iStack28;
    undefined4 uStack24;
    undefined *puStack20;
    int32_t var_4h;
    
    puStack20 = &stack0xfffffffc;
    var_4h = 0;
    uStack24 = 0x40678b;
    iStack28 = *in_FS_OFFSET;
    *in_FS_OFFSET = (int32_t)&iStack28;
    if ((uint32_t)arg_ch >> 0x10 == 0) {
        puStack20 = &stack0xfffffffc;
        sub.kernel32.dll_GetProcAddress_1(arg_8h, arg_ch);
    } else {
        fcn.004048d4();
        uVar1 = fcn.0040494c();
        sub.kernel32.dll_GetProcAddress_1(arg_8h, uVar1);
    }
    *in_FS_OFFSET = arg_8h;
    iStack28 = 0x406792;
    fcn.004046c4();
    return;
}


// WARNING: [r2ghidra] Failed to match type LPWSTR for variable lpBuffer to Decompiler type: Unknown type identifier
// LPWSTR

void fcn.0040b9d0(void)
{
    undefined auStack524 [520];
    
    sub.kernel32.dll_GetSystemDirectoryW(auStack524, 0x104);
    fcn.00408218();
    return;
}


void fcn.00408218(void)
{
    fcn.00404e14();
    return;
}


void fcn.0040b2e0(void)
{
    char cVar1;
    int32_t in_EAX;
    int32_t unaff_ESI;
    
    if (in_EAX != 0) {
        fcn.0040b5fc();
        cVar1 = fcn.0040b334();
        if (cVar1 == '\0') {
            fcn.00405058();
            return;
        }
    }
    fcn.00404c98(unaff_ESI);
    return;
}


undefined4 fcn.0040b5fc(void)
{
    int32_t in_EAX;
    undefined4 uVar1;
    
    if (in_EAX == 0) {
        return 0;
    }
    uVar1 = fcn.0040b620();
    return uVar1;
}


uint32_t __fastcall fcn.0040b620(undefined4 param_1, uint32_t param_2)
{
    uint32_t in_EAX;
    
    if (in_EAX < param_2) {
        param_2 = param_2 - 2;
    }
    return param_2;
}


undefined4 fcn.0040b334(void)
{
    int16_t in_AX;
    
    if ((in_AX != 0x5c) && (in_AX != 0x2f)) {
        return 0;
    }
    return 1;
}


// WARNING: [r2ghidra] Failed to match type UINT for variable var_ch to Decompiler type: Unknown type identifier UINT
// WARNING: [r2ghidra] Failed to match type HMODULE for variable var_8h to Decompiler type: Unknown type identifier
// HMODULE

void __fastcall fcn.0040ac84(undefined4 param_1, undefined4 param_2)
{
    undefined4 uVar1;
    undefined4 *in_FS_OFFSET;
    undefined4 uStack48;
    undefined4 uStack44;
    undefined *puStack40;
    undefined4 uStack36;
    undefined4 uStack32;
    undefined *puStack28;
    undefined4 uStack24;
    undefined4 var_ch;
    undefined4 var_8h;
    
    puStack40 = &stack0xfffffffc;
    puStack28 = (undefined *)0x40ac93;
    uStack24 = param_2;
    var_ch = sub.kernel32.dll_SetErrorMode();
    uStack32 = 0x40acf6;
    uStack36 = *in_FS_OFFSET;
    *in_FS_OFFSET = &uStack36;
    uStack44 = 0x40acd8;
    uStack48 = *in_FS_OFFSET;
    *in_FS_OFFSET = &uStack48;
    puStack28 = &stack0xfffffffc;
    uVar1 = fcn.00404d24();
    sub.kernel32.dll_LoadLibraryW();
    *in_FS_OFFSET = uVar1;
    return;
}


void fcn.0040bf84(void)
{
    uint16_t uVar1;
    int32_t iVar2;
    undefined4 uStack2084;
    undefined4 uStack2080;
    undefined4 uStack2076;
    undefined4 uStack2068;
    undefined *puStack2064;
    undefined4 uStack2060;
    undefined4 uStack2056;
    undefined auStack2052 [2048];
    
    uStack2056 = 0;
    uStack2060 = 0x400;
    puStack2064 = auStack2052;
    uStack2068 = 0;
    uStack2076 = 0;
    uStack2080 = 0x3200;
    uStack2084 = 0x40bfa8;
    iVar2 = sub.kernel32.dll_FormatMessageW();
    while ((0 < iVar2 &&
           ((uVar1 = *(uint16_t *)((int32_t)&uStack2084 + iVar2 * 2 + 2), uVar1 < 0x21 || (uVar1 == 0x2e))))) {
        iVar2 = iVar2 + -1;
    }
    uStack2084 = 0x40bfca;
    fcn.00404dd4();
    return;
}


void fcn.004065d4(void)
{
    *(undefined4 *)0x4127ac = 0;
    *(undefined4 *)0x4127b8 = sub.kernel32.dll_GetModuleHandleW_1(0);
    *(undefined4 *)0x4127bc = 0;
    *(undefined4 *)0x4127c0 = 0;
    *(undefined4 *)0x415b48 = *(undefined4 *)0x4127b8;
    fcn.004065c8();
    fcn.004042d0();
    return;
}


void fcn.004065c8(void)
{
    fcn.004061f4();
    return;
}


void fcn.004061f4(void)
{
    undefined4 *in_EAX;
    
    *in_EAX = *(undefined4 *)0x41202c;
    *(undefined4 **)0x41202c = in_EAX;
    return;
}


void __fastcall fcn.004042d0(undefined4 param_1, int32_t param_2)
{
    undefined4 in_EAX;
    
    *(undefined4 *)0x413014 = 0x4010a8;
    *(undefined4 *)0x413018 = 0x4010b0;
    *(undefined4 *)0x415af0 = 0;
    *(undefined4 *)0x413034 = *(undefined4 *)(param_2 + 4);
    *(undefined4 *)0x415aec = in_EAX;
    *(int32_t *)0x415af4 = param_2;
    fcn.004041bc();
    *(undefined *)0x41303c = 0;
    fcn.00404268();
    return;
}


void fcn.004041bc(void)
{
    int32_t *piVar1;
    int32_t iVar2;
    int32_t in_EAX;
    int32_t unaff_EBP;
    int32_t *in_FS_OFFSET;
    int32_t var_10h;
    
    piVar1 = (int32_t *)(unaff_EBP + -0x10);
    iVar2 = *in_FS_OFFSET;
    *in_FS_OFFSET = (int32_t)piVar1;
    *piVar1 = iVar2;
    *(undefined4 *)(unaff_EBP + -0xc) = 0x40411c;
    *(int32_t *)(unaff_EBP + -8) = unaff_EBP;
    *(int32_t **)(in_EAX + 4) = piVar1;
    return;
}


void fcn.00404268(void)
{
    int32_t iVar1;
    code *pcVar2;
    int32_t iVar3;
    undefined4 *in_FS_OFFSET;
    undefined4 uStack32;
    undefined4 uStack28;
    undefined *puStack24;
    int32_t var_4h;
    
    puStack24 = &stack0xfffffffc;
    if (*(int32_t **)0x415aec != (int32_t *)0x0) {
        iVar1 = **(int32_t **)0x415aec;
        iVar3 = 0;
        var_4h = (*(int32_t **)0x415aec)[1];
        uStack28 = 0x4042b5;
        uStack32 = *in_FS_OFFSET;
        *in_FS_OFFSET = &uStack32;
        if (0 < iVar1) {
            do {
                pcVar2 = *(code **)(var_4h + iVar3 * 8);
                iVar3 = iVar3 + 1;
                *(int32_t *)0x415af0 = iVar3;
                if (pcVar2 != (code *)0x0) {
                    (*pcVar2)();
                }
            } while (iVar3 < iVar1);
        }
        *in_FS_OFFSET = uStack32;
    }
    return;
}


// WARNING: Removing unreachable block (ram,0x0040eded)
// WARNING: [r2ghidra] Failed to match type LPSYSTEM_INFO for variable lpSystemInfo to Decompiler type: Unknown type
// identifier LPSYSTEM_INFO
// WARNING: [r2ghidra] Failed to match type PDWORD * for variable lpflOldProtect to Decompiler type: Unknown type
// identifier PDWORD
// WARNING: [r2ghidra] Failed to match type DWORD * for variable flNewProtect to Decompiler type: Unknown type
// identifier DWORD

void fcn.0040ed58(void)
{
    int32_t in_EAX;
    int32_t iVar1;
    undefined *puVar2;
    uint32_t uVar3;
    undefined4 uStack100;
    undefined *puStack96;
    int32_t iStack92;
    undefined auStack80 [36];
    int32_t iStack44;
    undefined *puStack40;
    uint32_t uStack32;
    int32_t iStack28;
    uint32_t uStack24;
    
    puStack96 = auStack80;
    uStack100 = 0x40ed70;
    iStack92 = in_EAX;
    sub.kernel32.dll_GetSystemInfo_1();
    puVar2 = puStack96;
    uStack100 = 0x1c;
    iVar1 = sub.kernel32.dll_VirtualQuery_1();
    while ((iVar1 != 0 && (puStack40 == puVar2))) {
        if ((iStack28 == 0x1000) && ((uStack24 & 0x100) == 0)) {
            if ((((uStack24 == 1) || (uStack24 == 2)) || (uStack24 == 0x10)) || (uStack24 == 0x20)) {
                sub.kernel32.dll_VirtualProtect(iStack44, uStack32, 0x40, &uStack100);
            }
            uVar3 = 0;
            while (uVar3 < uStack32) {
                fcn.0040ed50();
                uVar3 = uVar3 + iStack92;
            }
        }
        puVar2 = (undefined *)(iStack44 + uStack32);
        iVar1 = sub.kernel32.dll_VirtualQuery_1();
    }
    return;
}


void fcn.0040e8ac(void)
{
    int32_t iVar1;
    int32_t iVar2;
    int32_t **in_FS_OFFSET;
    int32_t *arg_8h;
    undefined4 uStack32;
    undefined *puStack28;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    
    puStack28 = &stack0xfffffffc;
    var_8h = 0;
    var_ch = 0;
    uStack32 = 0x40e9b0;
    arg_8h = *in_FS_OFFSET;
    *in_FS_OFFSET = (int32_t *)&stack0xffffffdc;
    iVar1 = fcn.0040b89c();
    if (0 < iVar1) {
        do {
            fcn.0040b8fc();
            iVar2 = fcn.00407bdc();
            if (iVar2 == 0) {
code_r0x0040e91b:
                *(undefined *)0x412ae4 = 1;
            } else {
                arg_8h = &var_8h;
                fcn.0040525c((int32_t)arg_8h);
                iVar2 = fcn.00407bdc();
                if (iVar2 == 0) goto code_r0x0040e91b;
                arg_8h = &var_ch;
                fcn.0040525c((int32_t)arg_8h);
                iVar2 = fcn.00407bdc();
                if (iVar2 == 0) {
                    arg_8h = (int32_t *)0x418528;
                    fcn.0040525c(0x418528);
                } else {
                    iVar2 = fcn.00407bdc();
                    if ((iVar2 == 0) || (iVar2 = fcn.00407bdc(), iVar2 == 0)) {
                        *(undefined *)0x412ae0 = 1;
                    }
                }
            }
            iVar1 = iVar1 + -1;
        } while (iVar1 != 0);
    }
    *in_FS_OFFSET = arg_8h;
    puStack28 = (undefined *)0x40e9b7;
    uStack32 = 0x40e9af;
    fcn.00404c90();
    return;
}


void fcn.0040ee80(void)
{
    undefined4 uVar1;
    undefined4 *in_FS_OFFSET;
    undefined4 uVar2;
    undefined4 uStack20;
    undefined4 uStack16;
    undefined *puStack12;
    int32_t var_4h;
    
    puStack12 = &stack0xfffffffc;
    var_4h = 0;
    uStack16 = 0x40eecd;
    uStack20 = *in_FS_OFFSET;
    *in_FS_OFFSET = &uStack20;
    fcn.00404cec();
    uVar1 = fcn.00404d24(0x4100e4, 0x10);
    uVar2 = 0;
    sub.user32.dll_MessageBoxW(0, uVar1);
    *in_FS_OFFSET = uVar2;
    fcn.00404c88(0x40eed4);
    return;
}


// WARNING: Possible PIC construction at 0x00404dcc: Changing call to branch
// WARNING: Removing unreachable block (ram,0x00404dd1)
// WARNING: [r2ghidra] Failed to match type UINT for variable CodePage to Decompiler type: Unknown type identifier UINT

void __fastcall fcn.00404cec(undefined4 param_1, int32_t param_2)
{
    int32_t *piVar1;
    int32_t *in_EAX;
    int32_t iVar2;
    int32_t iVar3;
    uint32_t unaff_retaddr;
    
    if (param_2 != 0) {
        if (*(int16_t *)(param_2 + -10) != 2) {
            do {
                iVar3 = 0;
                if (param_2 == 0) {
code_r0x00404d30:
                    if (iVar3 < 1) {
                        fcn.00404c88();
                    } else {
                        if ((iVar3 + 1 < 0x7ff) && (iVar2 = fcn.004047ec(unaff_retaddr, iVar3), 0 < iVar2)) {
                            fcn.00404dd4();
                        } else {
                            fcn.00404f00();
                            fcn.004047ec(unaff_retaddr, iVar3);
                            fcn.00404f00();
                        }
                    }
                    return;
                }
                if (*(int16_t *)(param_2 + -10) != 2) {
                    unaff_retaddr = (uint32_t)*(uint16_t *)(param_2 + -0xc);
                    iVar3 = *(int32_t *)(param_2 + -4);
                    goto code_r0x00404d30;
                }
                if (param_2 == 0) goto code_r0x00404cce;
            } while (*(int16_t *)(param_2 + -10) != 2);
            iVar3 = *(int32_t *)(param_2 + -8);
            if (iVar3 == -1 || SCARRY4(iVar3, 1) != iVar3 + 1 < 0) {
                param_2 = fcn.004054b4(param_2);
                fcn.00402fbc();
            } else {
                LOCK();
                *(int32_t *)(param_2 + -8) = *(int32_t *)(param_2 + -8) + 1;
            }
code_r0x00404cce:
            iVar3 = *in_EAX;
            *in_EAX = param_2;
            if ((iVar3 != 0) && (0 < *(int32_t *)(iVar3 + -8))) {
                LOCK();
                piVar1 = (int32_t *)(iVar3 + -8);
                *piVar1 = *piVar1 + -1;
                if (*piVar1 == 0) {
                    fcn.00402e20();
                }
            }
            return;
        }
        iVar3 = *(int32_t *)(param_2 + -8);
        if (iVar3 != -1 && SCARRY4(iVar3, 1) == iVar3 + 1 < 0) {
            LOCK();
            *(int32_t *)(param_2 + -8) = *(int32_t *)(param_2 + -8) + 1;
        }
    }
    iVar3 = *in_EAX;
    *in_EAX = param_2;
    if ((iVar3 != 0) && (0 < *(int32_t *)(iVar3 + -8))) {
        LOCK();
        piVar1 = (int32_t *)(iVar3 + -8);
        *piVar1 = *piVar1 + -1;
        if (*piVar1 == 0) {
            fcn.00402e20();
        }
    }
    return;
}


void fcn.004046ac(void)
{
    undefined4 in_EAX;
    
    *(undefined4 *)0x412000 = in_EAX;
    fcn.00404580();
    return;
}


void fcn.00404580(void)
{
    code *pcVar1;
    int32_t iVar2;
    undefined4 *puVar3;
    undefined4 *puVar4;
    
    if (*(int32_t *)0x412004 != 0) {
        fcn.00404458();
        fcn.004044f0();
        *(int32_t *)0x412004 = 0;
    }
    if ((*(int32_t *)0x415b18 != 0) && (iVar2 = sub.kernel32.dll_GetCurrentThreadId(), iVar2 == *(int32_t *)0x415b40)) {
        fcn.004041dc();
        fcn.004044c4();
    }
    pcVar1 = *(code **)0x413048;
    if (*(uint8_t *)0x415b0c == 0) {
        while (*(code **)0x413048 = pcVar1, pcVar1 != (code *)0x0) {
            *(code **)0x413048 = (code *)0x0;
            (*pcVar1)();
            pcVar1 = *(code **)0x413048;
        }
    }
    do {
        if ((*(uint8_t *)0x415b0c == 2) && (*(int32_t *)0x412000 == 0)) {
            *(undefined4 *)0x415af0 = 0;
        }
        iVar2 = fcn.00402ec8();
        while (iVar2 != 0) {
            fcn.00403894();
            iVar2 = fcn.00402ec8();
        }
        fcn.00404204();
        if (((*(uint8_t *)0x415b0c < 2) || (*(int32_t *)0x412000 != 0)) && (*(int32_t *)0x415af4 != 0)) {
            fcn.00406204();
            iVar2 = *(int32_t *)(*(int32_t *)0x415af4 + 0x10);
            if ((iVar2 != *(int32_t *)(*(int32_t *)0x415af4 + 4)) && (iVar2 != 0)) {
                sub.kernel32.dll_FreeLibrary(iVar2);
            }
        }
        fcn.004041dc();
        if (*(uint8_t *)0x415b0c == 1) {
            (**(code **)0x415b08)();
        }
        if (*(uint8_t *)0x415b0c != 0) {
            fcn.004044c4();
        }
        if (*(undefined4 **)0x415ae4 == (undefined4 *)0x0) {
            if (*(code **)0x41302c != (code *)0x0) {
                (**(code **)0x41302c)();
            }
            sub.kernel32.dll_ExitProcess(*(int32_t *)0x412000);
        }
        iVar2 = 0xc;
        puVar3 = *(undefined4 **)0x415ae4;
        puVar4 = (undefined4 *)0x415ae4;
        while (iVar2 != 0) {
            iVar2 = iVar2 + -1;
            *puVar4 = *puVar3;
            puVar3 = puVar3 + 1;
            puVar4 = puVar4 + 1;
        }
    } while( true );
}


void fcn.0040b8fc(void)
{
    int32_t in_EAX;
    int16_t *piVar1;
    int32_t *in_FS_OFFSET;
    int32_t in_stack_fffffdcc;
    int32_t arg_8h;
    undefined4 uStack548;
    undefined *puStack544;
    int32_t var_20ch;
    int32_t var_4h;
    
    puStack544 = &stack0xfffffffc;
    uStack548 = 0x40b993;
    arg_8h = *in_FS_OFFSET;
    *in_FS_OFFSET = (int32_t)&stack0xfffffdd8;
    if (in_EAX == 0) {
        in_stack_fffffdcc = 0;
        puStack544 = &stack0xfffffffc;
        sub.kernel32.dll_GetModuleFileNameW_1(0, &var_20ch, 0x104);
        fcn.00404dd4();
    } else {
        piVar1 = (int16_t *)sub.kernel32.dll_GetCommandLineW_1();
        while (*piVar1 != 0) {
            piVar1 = (int16_t *)fcn.0040b7bc();
            if (in_EAX == 0) goto code_r0x0040b973;
            in_EAX = in_EAX + -1;
        }
        fcn.00404cec();
code_r0x0040b973:
        fcn.00404c98(arg_8h);
    }
    *in_FS_OFFSET = in_stack_fffffdcc;
    fcn.00404c88(0x40b99a);
    return;
}


// WARNING: Variable defined which should be unmapped: var_1h
// WARNING: [r2ghidra] Var arg_10h is stack pointer based, which is not supported for decompilation.

int32_t * __cdecl fcn.0040c238(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h)
{
    int32_t *in_EAX;
    uint32_t uVar1;
    int32_t iVar2;
    char in_DL;
    char extraout_DL;
    uint32_t *in_FS_OFFSET;
    uint32_t var_1h;
    
    if (in_DL != '\0') {
        in_EAX = (int32_t *)fcn.004039e4();
        in_DL = extraout_DL;
    }
    fcn.00403864();
    uVar1 = arg_8h & 0xff;
    iVar2 = (**(code **)(*in_EAX + 0x14))(uVar1, arg_ch & 0xff);
    in_EAX[1] = iVar2;
    if ((in_EAX[1] == 0) || (in_EAX[1] == -1)) {
        fcn.0040c1e4();
    }
    *(undefined *)(in_EAX + 2) = 1;
    if (in_DL != '\0') {
        fcn.00403a3c();
        *in_FS_OFFSET = uVar1;
    }
    return in_EAX;
}


int32_t fcn.0040ee2c(void)
{
    int32_t iVar1;
    int32_t iVar2;
    
    iVar1 = sub.kernel32.dll_FindResourceW(0, 0x2b67, 10);
    if (iVar1 == 0) {
        fcn.0040ec70();
    }
    iVar2 = sub.kernel32.dll_SizeofResource(0, iVar1);
    if (iVar2 != 0x2c) {
        fcn.0040ec70();
    }
    iVar1 = sub.kernel32.dll_LoadResource(0, iVar1);
    if (iVar1 == 0) {
        fcn.0040ec70();
    }
    iVar1 = sub.kernel32.dll_LockResource(iVar1);
    if (iVar1 == 0) {
        fcn.0040ec70();
    }
    return iVar1;
}


uint32_t fcn.0040c738(void)
{
    uint32_t uVar1;
    
    uVar1 = fcn.0040c6e4();
    return uVar1 ^ 0xffffffff;
}


uint32_t __fastcall fcn.0040c6e4(int32_t param_1, uint8_t *param_2)
{
    uint32_t in_EAX;
    
    if (*(int32_t *)0x417d98 == 0) {
        fcn.0040c6b0();
        sub.kernel32.dll_InterlockedExchange(0x417d98, 1);
    }
    if (param_1 != 0) {
        do {
            in_EAX = *(uint32_t *)((uint32_t)(uint16_t)((uint16_t)in_EAX & 0xff ^ (uint16_t)*param_2) * 4 + 0x417d9c) ^
                     in_EAX >> 8;
            param_1 = param_1 + -1;
            param_2 = param_2 + 1;
        } while (param_1 != 0);
    }
    return in_EAX;
}


void fcn.0040ec70(void)
{
    if (*(int32_t *)(*(int32_t *)0x412c0c + 0x278) != 0) {
        fcn.00409824();
        fcn.00403f88();
        return;
    }
    fcn.00409824();
    fcn.00403f88();
    return;
}


// WARNING: [r2ghidra] Var arg_10h is stack pointer based, which is not supported for decompilation.

undefined4 __fastcall fcn.00409824(undefined4 param_1, char param_2)
{
    undefined4 in_EAX;
    char extraout_DL;
    int32_t *in_FS_OFFSET;
    int32_t in_stack_ffffffe4;
    
    if (param_2 != '\0') {
        in_EAX = fcn.004039e4();
        param_2 = extraout_DL;
    }
    fcn.00404c98(in_stack_ffffffe4);
    if (param_2 != '\0') {
        fcn.00403a3c();
        *in_FS_OFFSET = in_stack_ffffffe4;
    }
    return in_EAX;
}


void fcn.00403f88(void)
{
    int32_t in_EAX;
    int32_t iVar1;
    undefined4 unaff_retaddr;
    code *pcVar2;
    undefined4 uVar3;
    undefined4 uVar4;
    undefined4 uVar5;
    undefined *puVar6;
    undefined *puVar7;
    undefined auStack24 [4];
    int32_t iStack20;
    
    if (in_EAX == 0) {
        in_EAX = fcn.004046b8();
    }
    puVar6 = auStack24;
    uVar5 = 7;
    uVar4 = 1;
    uVar3 = 0xeedfade;
    puVar7 = auStack24;
    iStack20 = in_EAX;
    if (*(code **)0x41301c != (code *)0x0) {
        pcVar2 = *(code **)0x41301c;
        iVar1 = fcn.00402efc(*(code **)0x41301c, auStack24, unaff_retaddr, 7, unaff_retaddr, in_EAX);
        if (iVar1 != 0) {
            iVar1 = *(int32_t *)(iVar1 + 0xc);
        }
        (*pcVar2)(0xeedfade, 1, iVar1);
        puVar7 = puVar6;
    }
    // WARNING: Could not recover jumptable at 0x00403fee. Too many branches
    // WARNING: Treating indirect jump as call
    (**(code **)0x413014)(uVar3, uVar4, uVar5, puVar7);
    return;
}


void __fastcall fcn.0040c220(undefined4 param_1, undefined4 param_2)
{
    int32_t *in_EAX;
    
    (**(code **)(*in_EAX + 0xc))(param_2, 0);
    return;
}


void __fastcall fcn.0040c1f8(int32_t param_1)
{
    int32_t *in_EAX;
    int32_t iVar1;
    
    iVar1 = (**(code **)(*in_EAX + 8))();
    if (param_1 != iVar1) {
        fcn.0040c130();
    }
    return;
}


void __fastcall fcn.0040c130(undefined4 param_1, int32_t param_2)
{
    int32_t iVar1;
    uint32_t **in_FS_OFFSET;
    uint32_t *arg_8h;
    uint32_t *puStack32;
    undefined4 uStack28;
    undefined *puStack24;
    int32_t var_ch;
    int32_t var_8h;
    uint32_t var_4h;
    
    puStack24 = &stack0xfffffffc;
    var_4h = 0;
    uStack28 = 0x40c1a7;
    puStack32 = *in_FS_OFFSET;
    *in_FS_OFFSET = (uint32_t *)&puStack32;
    arg_8h = (uint32_t *)0x40c156;
    fcn.0040bf84();
    if (var_4h == 0) {
        arg_8h = &var_4h;
        var_ch = param_2;
        fcn.004082d4((int32_t)arg_8h);
    }
    iVar1 = fcn.00409824();
    *(int32_t *)(iVar1 + 0x18) = param_2;
    fcn.00403f88();
    *in_FS_OFFSET = arg_8h;
    uStack28 = 0x40c1ae;
    puStack32 = (uint32_t *)0x40c1a6;
    fcn.00404c88();
    return;
}


// WARNING: [r2ghidra] Failed to match type signed int for variable var_10h to Decompiler type: Unknown type identifier
// signed

void __cdecl fcn.004082d4(int32_t arg_8h)
{
    int32_t in_ECX;
    
    fcn.004082e8(in_ECX);
    return;
}


// WARNING: Variable defined which should be unmapped: var_2010h
// WARNING: [r2ghidra] Failed to match type signed int for variable var_10h to Decompiler type: Unknown type identifier
// signed

void __cdecl fcn.004082e8(int32_t arg_8h)
{
    int32_t iVar1;
    int32_t in_ECX;
    int32_t in_EDX;
    int32_t iVar2;
    int32_t *in_FS_OFFSET;
    int32_t var_2010h;
    int32_t iStack4152;
    int32_t iStack4140;
    undefined4 uStack4136;
    undefined *puStack4132;
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    
    iVar1 = 2;
    do {
        iVar1 = iVar1 + -1;
    } while (iVar1 != 0);
    puStack4132 = (undefined *)0x408315;
    fcn.00404c80();
    uStack4136 = 0x40846e;
    iStack4140 = *in_FS_OFFSET;
    *in_FS_OFFSET = (int32_t)&iStack4140;
    iVar2 = 0x1000;
    iVar1 = in_EDX;
    puStack4132 = &stack0xfffffffc;
    if ((in_EDX != 0) && (puStack4132 = &stack0xfffffffc, *(int16_t *)(in_EDX + -10) != 2)) {
        puStack4132 = &stack0xfffffffc;
        iVar1 = fcn.00404820();
    }
    if (iVar1 != 0) {
        iVar1 = *(int32_t *)(iVar1 + -4);
    }
    if (iVar1 < 0xc00) {
        iVar1 = in_EDX;
        if ((in_EDX != 0) && (*(int16_t *)(in_EDX + -10) != 2)) {
            iVar1 = fcn.00404820();
        }
        if (iVar1 != 0) {
            iVar1 = *(int32_t *)(iVar1 + -4);
        }
        iStack4152 = arg_8h;
        var_10h = fcn.00408274(arg_8h, in_ECX, iVar1);
    } else {
        iVar2 = in_EDX;
        if ((in_EDX != 0) && (*(int16_t *)(in_EDX + -10) != 2)) {
            iVar2 = fcn.00404820();
        }
        var_10h = iVar2;
        if (iVar2 != 0) {
            iVar2 = *(int32_t *)(iVar2 + -4);
            var_10h = iVar2;
        }
    }
    if (var_10h < iVar2 + -1) {
        fcn.00404dd4();
    } else {
        while (iVar2 + -1 <= var_10h) {
            iVar2 = iVar2 * 2;
            fcn.00404c98(iStack4152);
            fcn.00404f00();
            iVar1 = in_EDX;
            if ((in_EDX != 0) && (*(int16_t *)(in_EDX + -10) != 2)) {
                iVar1 = fcn.00404820();
            }
            if (iVar1 != 0) {
                iVar1 = *(int32_t *)(iVar1 + -4);
            }
            iStack4152 = arg_8h;
            fcn.00404d24();
            var_10h = fcn.00408274(arg_8h, in_ECX, iVar1);
        }
        fcn.00404f00();
    }
    *in_FS_OFFSET = iStack4152;
    fcn.00404c88(0x408475);
    return;
}


int32_t * __fastcall fcn.004031e0(uint32_t param_1, int32_t *param_2)
{
    int32_t *in_EAX;
    uint32_t uVar1;
    
    uVar1 = param_1 >> 2;
    do {
        if (uVar1 == 0) {
code_r0x00403210:
            param_1 = param_1 & 3;
            if (((param_1 != 0) && (*(char *)in_EAX == *(char *)param_2)) &&
               ((param_1 == 1 ||
                ((*(char *)((int32_t)in_EAX + 1) == *(char *)((int32_t)param_2 + 1) &&
                 ((param_1 == 2 || (*(char *)((int32_t)in_EAX + 2) == *(char *)((int32_t)param_2 + 2))))))))) {
                return (int32_t *)0x0;
            }
            return in_EAX;
        }
        if (*in_EAX != *param_2) {
            return in_EAX;
        }
        if (uVar1 == 1) {
            in_EAX = in_EAX + 1;
            param_2 = param_2 + 1;
            goto code_r0x00403210;
        }
        if (in_EAX[1] != param_2[1]) {
            return in_EAX;
        }
        in_EAX = in_EAX + 2;
        param_2 = param_2 + 2;
        uVar1 = uVar1 - 2;
    } while( true );
}


// WARNING: Variable defined which should be unmapped: var_1h
// WARNING: [r2ghidra] Detected overlap for variable var_9h
// WARNING: [r2ghidra] Var arg_10h is stack pointer based, which is not supported for decompilation.

int32_t __cdecl fcn.0040c854(int32_t arg_8h)
{
    int32_t in_EAX;
    int32_t iVar1;
    uint32_t uVar2;
    undefined4 uVar3;
    code **in_ECX;
    code **extraout_ECX;
    char in_DL;
    char extraout_DL;
    undefined4 *in_FS_OFFSET;
    undefined4 uStack64;
    int32_t var_20h;
    int32_t var_18h;
    int32_t var_dh;
    char var_9h;
    uint32_t var_8h;
    uint32_t var_1h;
    
    if (in_DL != '\0') {
        in_EAX = fcn.004039e4();
        in_ECX = extraout_ECX;
        in_DL = extraout_DL;
    }
    fcn.00403864();
    *(code ***)(in_EAX + 8) = in_ECX;
    iVar1 = (**(code **)(*in_ECX + 8))();
    if (iVar1 == 4) {
        iVar1 = (**(code **)(*in_ECX + 8))();
        if (iVar1 == 5) goto code_r0x0040c8ba;
    }
    fcn.00409824();
    fcn.00403f88();
code_r0x0040c8ba:
    uVar2 = fcn.0040c738();
    if (uVar2 != var_8h) {
        fcn.00409824();
        fcn.00403f88();
    }
    (**(code **)*in_ECX)();
    fcn.0040b2d4();
    (**(code **)(*in_ECX + 4))();
    iVar1 = fcn.0040b2b4();
    if (0 < iVar1) {
        fcn.00409824();
        fcn.00403f88();
    }
    if (var_9h != '\0') {
        uVar3 = (**(code **)arg_8h)(fcn.0040cad8, in_EAX);
        *(undefined4 *)(in_EAX + 4) = uVar3;
    }
    *(int32_t *)(in_EAX + 0xc) = var_dh;
    *(undefined *)(in_EAX + 0x10) = 1;
    if (in_DL != '\0') {
        fcn.00403a3c();
        *in_FS_OFFSET = uStack64;
    }
    return in_EAX;
}


void __cdecl fcn.0040da38(int32_t arg_8h, int32_t arg_ch)
{
    undefined *puVar1;
    int32_t *in_FS_OFFSET;
    int32_t arg_8h_00;
    undefined4 uStack44;
    undefined *puStack40;
    uint32_t var_14h;
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    
    puStack40 = &stack0xfffffffc;
    uStack44 = 0x40db37;
    arg_8h_00 = *in_FS_OFFSET;
    *in_FS_OFFSET = (int32_t)&stack0xffffffd0;
    puVar1 = &stack0xfffffffc;
    if (0 < arg_ch) {
        do {
            fcn.0040cb34();
            fcn.00404f00();
            if (var_14h != 0) {
                fcn.004054ac();
                fcn.0040cb34();
            }
            fcn.00404c98(arg_8h_00);
            arg_ch = arg_ch + -1;
            puVar1 = puStack40;
        } while (arg_ch != 0);
    }
    puStack40 = puVar1;
    if (0 < arg_8h) {
        do {
            fcn.0040cb34();
            fcn.004049c4();
            if (var_14h != 0) {
                fcn.004049bc();
                fcn.0040cb34();
            }
            fcn.00404718();
            arg_8h = arg_8h + -1;
        } while (arg_8h != 0);
    }
    fcn.0040cb34();
    *in_FS_OFFSET = arg_8h_00;
    puStack40 = (undefined *)0x40db3e;
    uStack44 = 0x40db2e;
    fcn.004046c4();
    uStack44 = 0x40db36;
    fcn.00404c88();
    return;
}


// WARNING: Removing unreachable block (ram,0x00402f34)

void fcn.00402dec(void)
{
    int32_t in_EAX;
    int32_t iVar1;
    
    if ((in_EAX != 0) && (iVar1 = (**(code **)0x412748)(), iVar1 == 0)) {
        if (*(code **)0x413008 != (code *)0x0) {
            (**(code **)0x413008)();
        }
        fcn.00402f08();
        return;
    }
    return;
}


void fcn.00403894(void)
{
    int32_t *in_EAX;
    
    if (in_EAX != (int32_t *)0x0) {
        (**(code **)(*in_EAX + -4))();
    }
    return;
}


// WARNING (jumptable): Unable to track spacebase fully for stack
// WARNING: Unable to track spacebase fully for stack
// WARNING: [r2ghidra] Var arg_2ch is stack pointer based, which is not supported for decompilation.

void fcn.0040404c(void)
{
    undefined4 *puVar1;
    code *UNRECOVERED_JUMPTABLE;
    undefined4 *in_FS_OFFSET;
    undefined4 *in_stack_00000030;
    
    puVar1 = (undefined4 *)fcn.00406588();
    *puVar1 = *(undefined4 *)*puVar1;
    fcn.00403894();
    *in_FS_OFFSET = *in_stack_00000030;
    in_stack_00000030[2] = 0x404079;
    fcn.00403bb8();
    // WARNING: Could not recover jumptable at 0x00404079. Too many branches
    // WARNING: Treating indirect jump as call
    (*UNRECOVERED_JUMPTABLE)();
    return;
}


// WARNING: [r2ghidra] Detected overlap for variable var_2h

void fcn.0040eab8(void)
{
    undefined auStack4 [4];
    
    fcn.0040e684((int32_t)auStack4);
    fcn.0040ea44();
    return;
}


// WARNING: Variable defined which should be unmapped: var_1h
// WARNING: [r2ghidra] Detected overlap for variable var_2h
// WARNING: [r2ghidra] Failed to match type LPWSTR for variable lpLCData to Decompiler type: Unknown type identifier
// LPWSTR
// WARNING: [r2ghidra] Failed to match type HKEY for variable hKey to Decompiler type: Unknown type identifier HKEY

undefined __cdecl fcn.0040e684(int32_t arg_8h)
{
    char cVar1;
    uint16_t uVar2;
    code *in_EAX;
    int32_t iVar3;
    int32_t iVar4;
    int32_t in_ECX;
    char in_DL;
    int32_t iVar5;
    int32_t var_8h;
    int32_t var_1h;
    
    *(undefined4 *)arg_8h = 0;
    if (in_ECX != 0) {
        iVar5 = 0;
        while (cVar1 = (*in_EAX)(), cVar1 != '\0') {
            iVar3 = fcn.00407bdc();
            if (iVar3 == 0) {
                *(int32_t *)arg_8h = iVar5;
                return 2;
            }
            iVar5 = iVar5 + 1;
        }
    }
    if (in_DL == '\0') {
        uVar2 = fcn.0040bcb4();
    } else {
        if (in_DL == '\x01') {
            uVar2 = sub.kernel32.dll_GetUserDefaultLangID();
        } else {
            uVar2 = 0;
        }
    }
    if (uVar2 != 0) {
        iVar5 = 0;
        while (cVar1 = (*in_EAX)(), cVar1 != '\0') {
            if (*(uint32_t *)(var_8h + 0x28) == (uint32_t)uVar2) {
                *(int32_t *)arg_8h = iVar5;
                return 1;
            }
            iVar5 = iVar5 + 1;
        }
        iVar5 = 0;
        while (cVar1 = (*in_EAX)(), cVar1 != '\0') {
            if ((*(uint32_t *)(var_8h + 0x28) & 0x3ff) == (uint32_t)(uVar2 & 0x3ff)) {
                if ((uVar2 & 0x3ff) != 4) {
code_r0x0040e764:
                    *(int32_t *)arg_8h = iVar5;
                    return 1;
                }
                iVar3 = fcn.0040e658();
                iVar4 = fcn.0040e658();
                if (iVar3 == iVar4) goto code_r0x0040e764;
            }
            iVar5 = iVar5 + 1;
        }
    }
    return 0;
}


void __fastcall fcn.0040ea44(undefined4 param_1)
{
    int32_t in_EAX;
    
    if (((-1 < in_EAX) && (in_EAX < *(int32_t *)0x418650)) && (in_EAX != *(int32_t *)0x412ae8)) {
        fcn.004049bc(param_1);
        fcn.0040e02c();
        *(int32_t *)0x412ae8 = in_EAX;
    }
    return;
}


int32_t fcn.004049bc(void)
{
    int32_t *piVar1;
    int32_t iVar2;
    int32_t *in_EAX;
    int32_t iVar3;
    
    iVar3 = *in_EAX;
    if (iVar3 != 0) {
        if (*(int16_t *)(iVar3 + -10) != 1) {
            fcn.00404808();
            iVar3 = *in_EAX;
        }
        if (*(int32_t *)(iVar3 + -8) != 1) {
            iVar2 = fcn.00404774();
            iVar3 = *in_EAX;
            *in_EAX = iVar2;
            fcn.00402fbc();
            if (0 < *(int32_t *)(iVar3 + -8)) {
                LOCK();
                piVar1 = (int32_t *)(iVar3 + -8);
                *piVar1 = *piVar1 + -1;
                if (*piVar1 == 0) {
                    fcn.00402e20();
                }
            }
            iVar3 = *in_EAX;
        }
    }
    return iVar3;
}


void __fastcall fcn.0040e02c(undefined4 param_1, uint32_t param_2)
{
    int32_t in_EAX;
    uint32_t uVar1;
    int32_t iVar2;
    char cVar3;
    uint32_t uVar4;
    bool bVar5;
    
    bVar5 = param_2 == 0x50;
    if ((param_2 < 0x51) || (fcn.004031e0(param_1), !bVar5)) {
        fcn.0040df78();
    }
    if (((*(uint32_t *)(in_EAX + 0x44) != ~*(uint32_t *)(in_EAX + 0x48)) || (param_2 != *(uint32_t *)(in_EAX + 0x44)))
       || (*(int32_t *)(in_EAX + 0x40) != 0xdd)) {
        fcn.0040df78();
    }
    uVar1 = in_EAX + 0x50;
    uVar4 = in_EAX + *(int32_t *)(in_EAX + 0x44);
    iVar2 = fcn.0040c738();
    if ((iVar2 != *(int32_t *)(in_EAX + 0x4c)) || (*(int16_t *)(uVar4 - 2) != 0)) {
        fcn.0040df78();
    }
    cVar3 = -0x23;
    do {
        if (uVar4 <= uVar1) {
            fcn.0040df78();
        }
        iVar2 = fcn.004080dc();
        fcn.00404dd4();
        uVar1 = uVar1 + (iVar2 + 1) * 2;
        cVar3 = cVar3 + -1;
    } while (cVar3 != '\0');
    return;
}


void __fastcall fcn.0040df38(int32_t param_1)
{
    fcn.0040df08(param_1);
    return;
}


// WARNING: [r2ghidra] Detected overlap for variable var_11h
// WARNING: [r2ghidra] Detected overlap for variable var_12h

void __cdecl fcn.0040df08(int32_t arg_8h)
{
    fcn.00404d24();
    fcn.0040dd98(arg_8h);
    return;
}


// WARNING: [r2ghidra] Detected overlap for variable var_11h
// WARNING: [r2ghidra] Detected overlap for variable var_12h

void __cdecl fcn.0040dd98(int32_t arg_8h)
{
    bool bVar1;
    int32_t in_EAX;
    int32_t iVar2;
    int32_t in_ECX;
    uint16_t *puVar3;
    int32_t iVar4;
    int32_t *in_FS_OFFSET;
    int32_t arg_8h_00;
    undefined4 uStack48;
    undefined *puStack44;
    int32_t var_18h;
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    
    puStack44 = &stack0xfffffffc;
    var_18h = 0;
    uStack48 = 0x40dec7;
    arg_8h_00 = *in_FS_OFFSET;
    *in_FS_OFFSET = (int32_t)&stack0xffffffcc;
    fcn.00404c98(arg_8h_00);
    if (in_EAX != 0) {
        while (iVar2 = fcn.004081d0(), iVar2 != 0) {
            iVar4 = in_EAX;
            if (in_EAX != iVar2) {
                fcn.00404dd4();
                fcn.00404f98();
                iVar4 = iVar2;
            }
            puVar3 = (uint16_t *)(iVar2 + 2);
            if ((*puVar3 < 0x100) &&
               ((*(uint8_t *)(((int32_t)(uint32_t)*(uint8_t *)puVar3 >> 3) + 0x40ded8) >> (*(uint8_t *)puVar3 & 7) & 1)
                != 0)) {
                bVar1 = true;
            } else {
                bVar1 = false;
            }
            if (bVar1) {
                bVar1 = (int32_t)(*puVar3 - 0x31) <= in_ECX;
            } else {
                bVar1 = false;
            }
            if (bVar1) {
                fcn.00404f98();
                in_EAX = iVar4 + 4;
            } else {
                fcn.00404f98();
                in_EAX = iVar4 + 2;
                if (*puVar3 == 0x25) {
                    in_EAX = iVar4 + 4;
                }
            }
        }
        fcn.00404e14();
        fcn.00404f98();
    }
    *in_FS_OFFSET = arg_8h_00;
    puStack44 = (undefined *)0x40dece;
    uStack48 = 0x40debe;
    fcn.00404c88();
    uStack48 = 0x40dec6;
    fcn.00404c88();
    return;
}


void fcn.00409810(void)
{
    int32_t iVar1;
    undefined4 unaff_retaddr;
    code *pcVar2;
    undefined4 uVar3;
    undefined4 uVar4;
    undefined4 uVar5;
    undefined *puVar6;
    undefined *puVar7;
    undefined auStack28 [4];
    int32_t iStack24;
    
    iStack24 = fcn.004098e0();
    if (iStack24 == 0) {
        iStack24 = fcn.004046b8();
    }
    puVar6 = auStack28;
    uVar5 = 7;
    uVar4 = 1;
    uVar3 = 0xeedfade;
    puVar7 = auStack28;
    if (*(code **)0x41301c != (code *)0x0) {
        pcVar2 = *(code **)0x41301c;
        iVar1 = fcn.00402efc(*(code **)0x41301c, auStack28, unaff_retaddr, 7, unaff_retaddr, iStack24);
        if (iVar1 != 0) {
            iVar1 = *(int32_t *)(iVar1 + 0xc);
        }
        (*pcVar2)(0xeedfade, 1, iVar1);
        puVar7 = puVar6;
    }
    // WARNING: Could not recover jumptable at 0x00403fee. Too many branches
    // WARNING: Treating indirect jump as call
    (**(code **)0x413014)(uVar3, uVar4, uVar5, puVar7);
    return;
}


void fcn.004030bc(void)
{
    int32_t iVar1;
    undefined auStack8 [8];
    
    iVar1 = sub.kernel32.dll_QueryPerformanceCounter();
    if (iVar1 != 0) {
        *(undefined **)0x412008 = auStack8;
        return;
    }
    *(undefined4 *)0x412008 = (undefined *)sub.kernel32.dll_GetTickCount();
    return;
}


// WARNING: Variable defined which should be unmapped: var_24h
// WARNING: Variable defined which should be unmapped: var_10h
// WARNING: Variable defined which should be unmapped: var_14h

void fcn.0040e42c(void)
{
    int32_t iVar1;
    int32_t *in_FS_OFFSET;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_18h;
    int32_t var_14h;
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    
    var_ch = 4;
    do {
        var_4h = 0;
        var_ch = var_ch + -1;
    } while (var_ch != 0);
    var_20h = *in_FS_OFFSET;
    *in_FS_OFFSET = (int32_t)&var_20h;
    while( true ) {
        fcn.0040b9fc();
        fcn.0040e310((int32_t)&var_4h);
        var_20h = fcn.00404d24(0);
        iVar1 = sub.kernel32.dll_CreateDirectoryW();
        if (iVar1 != 0) break;
        iVar1 = sub.kernel32.dll_GetLastError();
        if (iVar1 != 0xb7) {
            fcn.0040df38(&var_ch);
            var_20h = iVar1;
            fcn.00407ee8(iVar1);
            fcn.0040bf84();
            fcn.0040df08(var_20h);
            fcn.00409824();
            fcn.00403f88();
        }
    }
    fcn.00404c98(var_20h);
    *in_FS_OFFSET = var_20h;
    fcn.00404c90(0x40e528);
    fcn.00404c90();
    return;
}


void __fastcall fcn.0040b5d4(undefined4 param_1, int32_t param_2)
{
    fcn.0040b4b4();
    fcn.0040525c(param_2);
    return;
}


undefined8 __fastcall fcn.0040b4b4(undefined4 param_1, char param_2)
{
    char cVar1;
    int32_t in_EAX;
    int32_t iVar2;
    int32_t iVar3;
    int32_t iVar4;
    
    iVar2 = fcn.0040b3cc();
    if (in_EAX != 0) {
        in_EAX = *(int32_t *)(in_EAX + -4);
    }
    iVar4 = iVar2 + 1;
    iVar3 = iVar2;
    while (iVar4 <= in_EAX) {
        cVar1 = fcn.0040b334();
        if (cVar1 == '\0') {
            iVar3 = fcn.0040b32c();
            iVar4 = iVar4 + iVar3;
            iVar3 = iVar4 + -1;
        } else {
            iVar2 = iVar3;
            if (param_2 != '\0') {
                iVar2 = iVar4;
            }
            iVar4 = iVar4 + 1;
        }
    }
    return CONCAT44(iVar3, iVar2);
}


void __cdecl fcn.0040525c(int32_t arg_8h)
{
    int16_t iVar1;
    uint32_t in_EAX;
    undefined4 *in_FS_OFFSET;
    undefined4 uStack32;
    undefined4 uStack28;
    undefined *puStack24;
    uint32_t var_4h;
    
    puStack24 = (undefined *)0x405272;
    var_4h = in_EAX;
    fcn.00404c80();
    uStack28 = 0x40531d;
    uStack32 = *in_FS_OFFSET;
    *in_FS_OFFSET = &uStack32;
    puStack24 = &stack0xfffffffc;
    if ((var_4h != 0) && (puStack24 = &stack0xfffffffc, *(int16_t *)(var_4h - 10) != 2)) {
        puStack24 = &stack0xfffffffc;
        fcn.00404820();
    }
    if (var_4h == 0) {
        iVar1 = 2;
    } else {
        iVar1 = *(int16_t *)(var_4h - 10);
    }
    if (iVar1 == 2) {
        fcn.00404dd4();
    } else {
        fcn.00404dc4();
    }
    *in_FS_OFFSET = uStack32;
    puStack24 = (undefined *)0x405324;
    uStack28 = 0x40531c;
    fcn.00404c88();
    return;
}


void fcn.0040b348(void)
{
    int32_t iVar1;
    int32_t **in_FS_OFFSET;
    int32_t *arg_8h;
    int32_t *piStack36;
    undefined4 uStack32;
    undefined *puStack28;
    int32_t var_8h;
    int32_t var_4h;
    
    puStack28 = &stack0xfffffffc;
    var_8h = 0;
    uStack32 = 0x40b3bc;
    piStack36 = *in_FS_OFFSET;
    *in_FS_OFFSET = (int32_t *)&piStack36;
    iVar1 = fcn.0040b58c();
    if (iVar1 == 0) {
        arg_8h = (int32_t *)0x40b384;
        fcn.00405058();
    } else {
        arg_8h = &var_8h;
        fcn.0040525c((int32_t)arg_8h);
        fcn.00405058();
    }
    *in_FS_OFFSET = arg_8h;
    uStack32 = 0x40b3c3;
    piStack36 = (int32_t *)0x40b3bb;
    fcn.00404c88();
    return;
}


void __fastcall fcn.00403250(undefined param_1, int32_t param_2)
{
    undefined8 uVar1;
    undefined8 *in_EAX;
    undefined2 uVar2;
    int32_t iVar3;
    int32_t iVar4;
    bool bVar5;
    
    uVar2 = CONCAT11(param_1, param_1);
    if (0x1f < param_2) {
        *(undefined2 *)in_EAX = uVar2;
        *(undefined2 *)((int32_t)in_EAX + 2) = uVar2;
        *(undefined2 *)((int32_t)in_EAX + 4) = uVar2;
        *(undefined2 *)((int32_t)in_EAX + 6) = uVar2;
        uVar1 = *in_EAX;
        *(undefined8 *)(param_2 + -0x10 + (int32_t)in_EAX) = uVar1;
        *(undefined8 *)(param_2 + -8 + (int32_t)in_EAX) = uVar1;
        iVar3 = ((uint32_t)in_EAX & 7) - 8;
        iVar4 = param_2 + -0x10 + iVar3;
        iVar3 = (int32_t)in_EAX + (iVar4 - iVar3);
        iVar4 = -iVar4;
        do {
            *(undefined8 *)(iVar4 + iVar3) = uVar1;
            *(undefined8 *)(iVar4 + 8 + iVar3) = uVar1;
            bVar5 = SCARRY4(iVar4, 0x10);
            iVar4 = iVar4 + 0x10;
        } while (bVar5 != iVar4 < 0);
        return;
    }
    *(undefined *)(param_2 + -1 + (int32_t)in_EAX) = param_1;
    switch(param_2) {
    default:
        return;
    case 0x1e:
    case 0x1f:
        *(undefined2 *)((int32_t)in_EAX + 0x1c) = uVar2;
    case 0x1c:
    case 0x1d:
        *(undefined2 *)((int32_t)in_EAX + 0x1a) = uVar2;
    case 0x1a:
    case 0x1b:
        *(undefined2 *)(in_EAX + 3) = uVar2;
    case 0x18:
    case 0x19:
        *(undefined2 *)((int32_t)in_EAX + 0x16) = uVar2;
    case 0x16:
    case 0x17:
        *(undefined2 *)((int32_t)in_EAX + 0x14) = uVar2;
    case 0x14:
    case 0x15:
        *(undefined2 *)((int32_t)in_EAX + 0x12) = uVar2;
    case 0x12:
    case 0x13:
        *(undefined2 *)(in_EAX + 2) = uVar2;
    case 0x10:
    case 0x11:
        *(undefined2 *)((int32_t)in_EAX + 0xe) = uVar2;
    case 0xe:
    case 0xf:
        *(undefined2 *)((int32_t)in_EAX + 0xc) = uVar2;
    case 0xc:
    case 0xd:
        *(undefined2 *)((int32_t)in_EAX + 10) = uVar2;
    case 10:
    case 0xb:
        *(undefined2 *)(in_EAX + 1) = uVar2;
    case 8:
    case 9:
        *(undefined2 *)((int32_t)in_EAX + 6) = uVar2;
    case 6:
    case 7:
        *(undefined2 *)((int32_t)in_EAX + 4) = uVar2;
    case 4:
    case 5:
        *(undefined2 *)((int32_t)in_EAX + 2) = uVar2;
    case 2:
    case 3:
        *(undefined2 *)in_EAX = uVar2;
        return;
    }
}


void __fastcall fcn.0040cb34(int32_t param_1)
{
    int32_t in_EAX;
    int32_t iVar1;
    
    if (*(int32_t **)(in_EAX + 4) == (int32_t *)0x0) {
        iVar1 = fcn.0040cad8();
        if (param_1 != iVar1) {
            fcn.00409824();
            fcn.00403f88();
        }
    } else {
        (**(code **)(**(int32_t **)(in_EAX + 4) + 4))();
    }
    return;
}


// WARNING: [r2ghidra] Failed to match type signed int for variable var_4h to Decompiler type: Unknown type identifier
// signed
// WARNING: [r2ghidra] Detected overlap for variable var_4h

void __cdecl fcn.0040c750(int32_t arg_8h)
{
    int32_t in_EAX;
    int32_t iVar1;
    int32_t iVar2;
    char in_CL;
    int32_t in_EDX;
    uint32_t uVar3;
    uint32_t uVar4;
    int32_t var_ch;
    uint32_t var_5h;
    
    if (4 < in_EDX) {
        iVar1 = 0;
        if (0 < in_EDX + -4) {
            do {
                if ((*(char *)(in_EAX + iVar1) == -0x18) || (*(char *)(in_EAX + iVar1) == -0x17)) {
                    iVar2 = iVar1 + 1;
                    if ((*(char *)(in_EAX + 3 + iVar2) == '\0') || (*(char *)(in_EAX + 3 + iVar2) == -1)) {
                        uVar3 = arg_8h + iVar2 + 4U & 0xffffff;
                        uVar4 = (uint32_t)
                                CONCAT12(*(undefined *)(in_EAX + 2 + iVar2), 
                                         CONCAT11(*(undefined *)(in_EAX + 1 + iVar2), *(undefined *)(in_EAX + iVar2)));
                        if (in_CL == '\0') {
                            uVar4 = uVar4 - uVar3;
                        }
                        if ((uVar4 & 0x800000) != 0) {
                            *(uint8_t *)(in_EAX + 3 + iVar2) = ~*(uint8_t *)(in_EAX + 3 + iVar2);
                        }
                        if (in_CL != '\0') {
                            uVar4 = uVar4 + uVar3;
                        }
                        *(char *)(in_EAX + iVar2) = (char)uVar4;
                        *(char *)(in_EAX + 1 + iVar2) = (char)(uVar4 >> 8);
                        *(char *)(in_EAX + 2 + iVar2) = (char)(uVar4 >> 0x10);
                    }
                    iVar1 = iVar1 + 5;
                } else {
                    iVar1 = iVar1 + 1;
                }
            } while (iVar1 < in_EDX + -4);
        }
    }
    return;
}


void fcn.0040c410(void)
{
    int32_t in_EAX;
    int32_t iVar1;
    
    iVar1 = sub.kernel32.dll_SetEndOfFile(*(undefined4 *)(in_EAX + 4));
    if (iVar1 == 0) {
        fcn.0040c1e4();
    }
    return;
}


void fcn.0040c1e4(void)
{
    sub.kernel32.dll_GetLastError();
    fcn.0040c130();
    return;
}


// WARNING: [r2ghidra] Failed to match type LPCWSTR for variable lpWindowName to Decompiler type: Unknown type
// identifier LPCWSTR
// WARNING: [r2ghidra] Failed to match type LPVOID for variable lpParam to Decompiler type: Unknown type identifier
// LPVOID
// WARNING: [r2ghidra] Failed to match type HINSTANCE for variable hInstance to Decompiler type: Unknown type identifier
// HINSTANCE
// WARNING: [r2ghidra] Failed to match type HMENU for variable hMenu to Decompiler type: Unknown type identifier HMENU
// WARNING: [r2ghidra] Failed to match type HWND for variable hWndParent to Decompiler type: Unknown type identifier
// HWND
// WARNING: [r2ghidra] Failed to match type DWORD for variable dwStyle to Decompiler type: Unknown type identifier DWORD

undefined4 __cdecl
fcn.004068ec(undefined4 lpParam, undefined4 hInstance, undefined4 hMenu, undefined4 hWndParent, int32_t nHeight,
            int32_t nWidth, int32_t Y, int32_t X, undefined4 dwStyle)
{
    undefined4 uVar1;
    undefined4 lpWindowName;
    
    fcn.00403110();
    uVar1 = sub.user32.dll_CreateWindowExW();
    fcn.00403100();
    return uVar1;
}


undefined2 fcn.00403110(void)
{
    undefined2 in_FPUControlWord;
    
    return in_FPUControlWord;
}


void fcn.00403100(void)
{
    undefined2 in_AX;
    
    *(undefined2 *)0x41201c = in_AX;
    return;
}


void fcn.0040b84c(void)
{
    undefined4 *in_FS_OFFSET;
    undefined4 uStack24;
    undefined4 uStack20;
    undefined *puStack16;
    int32_t var_4h;
    
    puStack16 = &stack0xfffffffc;
    var_4h = 0;
    uStack20 = 0x40b88e;
    uStack24 = *in_FS_OFFSET;
    *in_FS_OFFSET = &uStack24;
    sub.kernel32.dll_GetCommandLineW_1();
    fcn.0040b7bc();
    fcn.00404e14();
    *in_FS_OFFSET = uStack24;
    puStack16 = (undefined *)0x40b895;
    uStack20 = 0x40b88d;
    fcn.00404c88();
    return;
}


void fcn.0040b7bc(void)
{
    uint16_t *puVar1;
    int32_t *in_FS_OFFSET;
    int32_t arg_8h;
    undefined4 uStack28;
    undefined *puStack24;
    int32_t var_8h;
    int32_t var_4h;
    
    puStack24 = &stack0xfffffffc;
    uStack28 = 0x40b83d;
    arg_8h = *in_FS_OFFSET;
    *in_FS_OFFSET = (int32_t)&stack0xffffffe0;
    fcn.0040b770();
    fcn.00404dd4();
    fcn.004054ac();
    puVar1 = (uint16_t *)fcn.0040b770();
    fcn.00404c98(arg_8h);
    while ((*puVar1 != 0 && (*puVar1 < 0x21))) {
        puVar1 = puVar1 + 1;
    }
    *in_FS_OFFSET = arg_8h;
    puStack24 = (undefined *)0x40b844;
    uStack28 = 0x40b83c;
    fcn.00404c88();
    return;
}


// WARNING (jumptable): Unable to track spacebase fully for stack
// WARNING: Unable to track spacebase fully for stack
// WARNING: Removing unreachable block (ram,0x00402f34)
// WARNING: [r2ghidra] Removing arg arg_4h because it doesn't fit into ProtoModel

void __fastcall fcn.0040513c(undefined4 param_1, int32_t param_2)
{
    int32_t *in_EAX;
    int32_t *piVar1;
    int32_t *piVar2;
    int32_t iVar3;
    int32_t iVar4;
    int32_t *unaff_ESI;
    int32_t *piVar5;
    int32_t *arg_8h;
    int32_t var_18h;
    int32_t var_14h;
    int32_t var_4h;
    
    piVar5 = (int32_t *)0x0;
    arg_8h = (int32_t *)0x0;
    piVar1 = *(int32_t **)(&stack0x00000000 + param_2 * 4);
    iVar3 = param_2;
    if (piVar1 == (int32_t *)0x0) {
        piVar2 = (int32_t *)0x0;
        goto code_r0x004051d7;
    }
    if (*(int16_t *)((int32_t)piVar1 + -10) != 2) {
        fcn.00404c80();
        piVar1 = (int32_t *)fcn.00404830();
        unaff_ESI = in_EAX;
        arg_8h = piVar1;
    }
    if ((int32_t *)*in_EAX == piVar1) {
        piVar2 = (int32_t *)piVar1[-1];
        iVar3 = param_2 + -1;
        piVar5 = piVar1;
        do {
            arg_8h = (int32_t *)0x0;
code_r0x00405190:
            piVar1 = *(int32_t **)(&stack0x00000000 + iVar3 * 4);
            if (piVar1 != (int32_t *)0x0) {
                if (*(int16_t *)((int32_t)piVar1 + -10) != 2) {
                    fcn.00404c80();
                    piVar1 = (int32_t *)fcn.00404830();
                    unaff_ESI = piVar2;
                    arg_8h = piVar1;
                }
                piVar2 = (int32_t *)((int32_t)piVar2 + piVar1[-1]);
                if (((uint32_t)piVar2 & 0xc0000000) != 0) {
                    if (*(code **)0x413008 != (code *)0x0) {
                        (**(code **)0x413008)(unaff_ESI, param_2);
                    }
                    fcn.00402f08();
                    return;
                }
                if (piVar5 == piVar1) {
                    piVar5 = (int32_t *)0x0;
                }
            }
code_r0x004051d7:
            iVar3 = iVar3 + -1;
            if (iVar3 == 0) {
                if (piVar5 == (int32_t *)0x0) {
                    iVar3 = fcn.004054b4();
                    iVar4 = param_2;
                } else {
                    fcn.00404f00();
                    iVar3 = *in_EAX;
                    iVar4 = param_2 + -1;
                    piVar5 = in_EAX;
                }
                do {
                    if ((*(int32_t *)(&stack0x00000000 + iVar4 * 4) != 0) &&
                       (*(int32_t *)(&stack0x00000000 + iVar4 * 4) != 0)) {
                        fcn.00402fbc();
                    }
                    iVar4 = iVar4 + -1;
                } while (iVar4 != 0);
                fcn.004046e8();
                if (piVar5 == (int32_t *)0x0) {
                    if (iVar3 != 0) {
                        *(int32_t *)(iVar3 + -8) = *(int32_t *)(iVar3 + -8) + -1;
                    }
                    fcn.00404c98((int32_t)arg_8h);
                }
    // WARNING: Could not recover jumptable at 0x00405251. Too many branches
    // WARNING: Treating indirect jump as call
                (**(code **)(&stack0xfffffffc + param_2 * 4))();
                return;
            }
        } while( true );
    }
    piVar2 = (int32_t *)0x0;
    goto code_r0x00405190;
}


// WARNING: [r2ghidra] Failed to match type HANDLE * for variable hProcess to Decompiler type: Unknown type identifier
// HANDLE
// WARNING: [r2ghidra] Failed to match type HANDLE for variable hObject to Decompiler type: Unknown type identifier
// HANDLE
// WARNING: [r2ghidra] Removing arg arg_4h because it doesn't fit into ProtoModel

void __fastcall fcn.0040eb68(undefined4 param_1, undefined4 param_2)
{
    undefined4 uVar1;
    int32_t iVar2;
    undefined4 *in_FS_OFFSET;
    undefined4 uStack116;
    undefined4 uStack112;
    undefined *puStack108;
    undefined4 hProcess;
    undefined4 hObject;
    int32_t var_48h;
    int32_t var_4h;
    
    puStack108 = &stack0xfffffffc;
    uStack112 = 0x40ec3d;
    uStack116 = *in_FS_OFFSET;
    *in_FS_OFFSET = &uStack116;
    fcn.0040513c(param_2, 0x40ec68);
    fcn.00403250();
    var_48h = 0x44;
    uVar1 = fcn.00404d24(0, 0, 0, 0, 0, 0, &var_48h, &hProcess);
    iVar2 = sub.kernel32.dll_CreateProcessW(0, uVar1);
    if (iVar2 == 0) {
        fcn.0040e788();
    }
    sub.kernel32.dll_CloseHandle_1(hObject);
    do {
        fcn.0040eb3c(hObject);
        hObject = 1;
        iVar2 = sub.user32.dll_MsgWaitForMultipleObjects();
    } while (iVar2 == 1);
    fcn.0040eb3c();
    sub.kernel32.dll_GetExitCodeProcess(hProcess, param_1);
    sub.kernel32.dll_CloseHandle_1();
    *in_FS_OFFSET = hProcess;
    fcn.00404c88(0x40ec44);
    return;
}


// WARNING: [r2ghidra] Failed to match type DWORD for variable arg_8h to Decompiler type: Unknown type identifier DWORD
// WARNING: [r2ghidra] Failed to match type DWORD for variable dwMilliseconds to Decompiler type: Unknown type
// identifier DWORD
// WARNING: [r2ghidra] Failed to match type BOOL for variable var_4h to Decompiler type: Unknown type identifier BOOL
// WARNING: [r2ghidra] Failed to match type DWORD for variable var_10h to Decompiler type: Unknown type identifier DWORD

void __cdecl fcn.0040e5f4(undefined4 arg_8h, undefined4 dwMilliseconds)
{
    int32_t iVar1;
    int32_t in_ECX;
    int32_t iVar2;
    int32_t var_4h;
    
    if (-1 < in_ECX + -1) {
        iVar2 = 0;
        do {
            if (iVar2 == 1) {
                sub.kernel32.dll_Sleep_1(dwMilliseconds);
            } else {
                if (1 < iVar2) {
                    sub.kernel32.dll_Sleep_1(arg_8h);
                }
            }
            iVar1 = fcn.0040e180();
            if (iVar1 != 0) {
                return;
            }
            iVar1 = sub.kernel32.dll_GetLastError();
            if (iVar1 == 2) {
                return;
            }
            iVar1 = sub.kernel32.dll_GetLastError();
            if (iVar1 == 3) {
                return;
            }
            iVar2 = iVar2 + 1;
            in_ECX = in_ECX + -1;
        } while (in_ECX != 0);
    }
    return;
}


// WARNING: Removing unreachable block (ram,0x00402f34)

void __fastcall fcn.00405548(int32_t param_1, char *param_2)
{
    char cVar1;
    bool bVar2;
    int32_t iVar3;
    
    if (param_1 != 0) {
        cVar1 = *param_2;
        if (cVar1 == '\n') {
            if (param_1 < 2) {
                fcn.004046c4();
            } else {
                fcn.004046e8();
            }
        } else {
            if (cVar1 == '\x12') {
                if (param_1 < 2) {
                    fcn.00404c88();
                } else {
                    fcn.00404c90();
                }
            } else {
                if (cVar1 == '\v') {
                    if (param_1 < 2) {
                        fcn.00404a8c();
                    } else {
                        fcn.00404aa4();
                    }
                } else {
                    if (cVar1 == '\f') {
                        do {
                            fcn.00405530();
                            iVar3 = param_1 + -1;
                            bVar2 = 0 < param_1;
                            param_1 = iVar3;
                        } while (iVar3 != 0 && bVar2);
                    } else {
                        if (cVar1 == '\r') {
                            do {
                                fcn.00405548();
                                iVar3 = param_1 + -1;
                                bVar2 = 0 < param_1;
                                param_1 = iVar3;
                            } while (iVar3 != 0 && bVar2);
                        } else {
                            if (cVar1 == '\x0e') {
                                do {
                                    fcn.004054f8();
                                    iVar3 = param_1 + -1;
                                    bVar2 = 0 < param_1;
                                    param_1 = iVar3;
                                } while (iVar3 != 0 && bVar2);
                            } else {
                                if (cVar1 == '\x0f') {
                                    do {
                                        fcn.00406274();
                                        iVar3 = param_1 + -1;
                                        bVar2 = 0 < param_1;
                                        param_1 = iVar3;
                                    } while (iVar3 != 0 && bVar2);
                                } else {
                                    if (cVar1 != '\x11') {
                                        if (*(code **)0x413008 != (code *)0x0) {
                                            (**(code **)0x413008)();
                                        }
                                        fcn.00402f08();
                                        return;
                                    }
                                    do {
                                        fcn.00405ae4();
                                        iVar3 = param_1 + -1;
                                        bVar2 = 0 < param_1;
                                        param_1 = iVar3;
                                    } while (iVar3 != 0 && bVar2);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return;
}


// WARNING: [r2ghidra] Failed to match type HANDLE for variable TokenHandle to Decompiler type: Unknown type identifier
// HANDLE

bool fcn.0040e550(void)
{
    int32_t iVar1;
    undefined4 uVar2;
    undefined4 uStack40;
    undefined **ppuStack36;
    undefined4 uStack32;
    undefined4 uStack28;
    undefined *puStack24;
    undefined auStack20 [20];
    
    if (**(int32_t **)0x412c80 == 2) {
        uStack28 = 0x28;
        uStack32 = 0x40e565;
        puStack24 = auStack20;
        uStack32 = sub.kernel32.dll_GetCurrentProcess();
        ppuStack36 = (undefined **)0x40e56b;
        iVar1 = sub.advapi32.dll_OpenProcessToken();
        if (iVar1 == 0) {
            return false;
        }
        ppuStack36 = &puStack24;
        uStack40 = 0x40e5cc;
        uVar2 = 0;
        sub.advapi32.dll_LookupPrivilegeValueW(0);
        uStack40 = 1;
        uStack28 = 2;
        sub.advapi32.dll_AdjustTokenPrivileges(uVar2, 0, &uStack40, 0, 0, 0);
        iVar1 = sub.kernel32.dll_GetLastError();
        if (iVar1 != 0) {
            return false;
        }
    }
    iVar1 = sub.user32.dll_ExitWindowsEx(2, 0);
    return iVar1 != 0;
}


void fcn.0040e83c(void)
{
    char cVar1;
    undefined4 uVar2;
    undefined4 *in_FS_OFFSET;
    undefined4 in_stack_ffffffdc;
    undefined4 uStack20;
    undefined4 uStack16;
    undefined *puStack12;
    int32_t var_4h;
    
    puStack12 = &stack0xfffffffc;
    var_4h = 0;
    uStack16 = 0x40e89f;
    uStack20 = *in_FS_OFFSET;
    *in_FS_OFFSET = &uStack20;
    fcn.00402e88();
    cVar1 = fcn.0040392c();
    if (cVar1 == '\0') {
        fcn.0040bf08(*(undefined4 *)(*(int32_t *)0x412c0c + 300), 0x10);
        uVar2 = fcn.00404d24();
        in_stack_ffffffdc = 0;
        sub.user32.dll_MessageBoxW(0, uVar2);
    }
    *in_FS_OFFSET = in_stack_ffffffdc;
    fcn.00404c88(0x40e8a6);
    return;
}


undefined4 fcn.00402e88(void)
{
    int32_t *piVar1;
    
    piVar1 = (int32_t *)fcn.00406588();
    if (*piVar1 != 0) {
        piVar1 = (int32_t *)fcn.00406588();
        return *(undefined4 *)(*piVar1 + 8);
    }
    return 0;
}


int32_t fcn.00406588(void)
{
    int32_t iVar1;
    int32_t in_FS_OFFSET;
    
    if (*(char *)0x415b44 == '\0') {
        return *(int32_t *)(*(int32_t *)(in_FS_OFFSET + 0x2c) + *(int32_t *)0x4127ac * 4);
    }
    iVar1 = sub.kernel32.dll_TlsGetValue(*(int32_t *)0x4127ac);
    if (iVar1 != 0) {
        return iVar1;
    }
    fcn.00406544();
    iVar1 = sub.kernel32.dll_TlsGetValue(*(int32_t *)0x4127ac);
    if (iVar1 != 0) {
        return iVar1;
    }
    return *(int32_t *)0x415b4c;
}


void fcn.00406544(void)
{
    int32_t iVar1;
    
    iVar1 = fcn.0040653c();
    if (iVar1 != 0) {
        if (*(int32_t *)0x4127ac == -1) {
            fcn.004046b8();
        }
        iVar1 = fcn.00406530();
        if (iVar1 == 0) {
            fcn.004046b8();
        } else {
            sub.kernel32.dll_TlsSetValue(*(int32_t *)0x4127ac, iVar1);
        }
    }
    return;
}


undefined4 fcn.0040392c(void)
{
    char cVar1;
    int32_t in_EAX;
    
    if (in_EAX != 0) {
        cVar1 = fcn.00403980();
        if (cVar1 != '\0') {
            return 1;
        }
    }
    return 0;
}


void fcn.0040bf08(void)
{
    char cVar1;
    int32_t iVar2;
    int32_t unaff_ESI;
    
    iVar2 = fcn.00402e88();
    if (iVar2 == 0) {
        fcn.00404c98(unaff_ESI);
        return;
    }
    cVar1 = fcn.0040392c();
    if (cVar1 == '\0') {
        fcn.00403814();
    } else {
        fcn.0040bec8();
    }
    return;
}


void __fastcall fcn.0040bec8(undefined4 param_1, int32_t *param_2)
{
    uint16_t *puVar1;
    int32_t unaff_ESI;
    
    fcn.00404c98(unaff_ESI);
    if (*param_2 != 0) {
        puVar1 = (uint16_t *)fcn.0040b5fc();
        if (0x2e < *puVar1) {
            fcn.00404f98();
        }
    }
    return;
}


void fcn.00403814(void)
{
    fcn.004063d0();
    return;
}


void fcn.004063d0(void)
{
    fcn.0040633c();
    return;
}


void fcn.0040633c(void)
{
    uint32_t arg_8h;
    uint8_t *in_EAX;
    int32_t iVar1;
    uint32_t *in_FS_OFFSET;
    uint32_t arg_8h_00;
    undefined4 uStack28;
    undefined *puStack24;
    int32_t var_4h;
    
    puStack24 = &stack0xfffffffc;
    var_4h = 0;
    uStack28 = 0x4063c2;
    arg_8h = *in_FS_OFFSET;
    *in_FS_OFFSET = (uint32_t)&stack0xffffffe0;
    arg_8h_00 = 0x40635f;
    fcn.00404c98(arg_8h);
    if (*in_EAX != 0) {
        arg_8h_00 = (uint32_t)*in_EAX;
        fcn.00404f00();
        fcn.00404d24();
        iVar1 = fcn.004062b8(arg_8h_00);
        if (iVar1 < 1) {
            fcn.00404cec();
        } else {
            fcn.00404f00();
        }
        fcn.00404c98(arg_8h_00);
    }
    *in_FS_OFFSET = arg_8h_00;
    uStack28 = 0x4063c9;
    fcn.00404c88();
    return;
}


void fcn.004014d8(void)
{
    uint32_t *puVar1;
    int32_t *piVar2;
    int32_t *piVar3;
    uint8_t uVar4;
    int32_t **in_EAX;
    uint32_t uVar5;
    
    piVar2 = in_EAX[1];
    piVar3 = *in_EAX;
    *piVar2 = (int32_t)piVar3;
    piVar3[1] = (int32_t)piVar2;
    if (piVar2 == piVar3) {
        uVar5 = (uint32_t)(piVar2 + -0x104eb1) >> 8 & 0xff;
        uVar4 = (uint8_t)((uint32_t)(piVar2 + -0x104eb1) >> 3) & 0x1f;
        puVar1 = (uint32_t *)(uVar5 * 4 + 0x413a44);
        *puVar1 = *puVar1 & (-2 << uVar4 | 0xfffffffeU >> 0x20 - uVar4);
        if (*puVar1 == 0) {
            uVar4 = (uint8_t)uVar5 & 0x1f;
            *(uint32_t *)0x413a40 = *(uint32_t *)0x413a40 & (-2 << uVar4 | 0xfffffffeU >> 0x20 - uVar4);
            return;
        }
    }
    return;
}


void fcn.00401578(void)
{
    uint32_t *puVar1;
    int32_t **ppiVar2;
    int32_t *piVar3;
    uint32_t uVar4;
    int32_t iVar5;
    
    iVar5 = *(int32_t *)0x413a38;
    if (*(uint32_t *)0x413a3c == 0) {
        return;
    }
    if ((*(uint8_t *)(*(int32_t *)0x413a38 + -4) & 1) == 0) {
        *(uint32_t *)(*(int32_t *)0x413a38 + -4) = *(uint32_t *)(*(int32_t *)0x413a38 + -4) | 8;
        piVar3 = (int32_t *)(iVar5 - *(uint32_t *)0x413a3c);
        uVar4 = *(uint32_t *)0x413a3c;
    } else {
        uVar4 = *(uint32_t *)(*(int32_t *)0x413a38 + -4) & 0xfffffff0;
        if (0xb2f < uVar4) {
            fcn.004014d8();
            uVar4 = *(uint32_t *)(*(int32_t *)0x413a38 + -4) & 0xfffffff0;
        }
        piVar3 = (int32_t *)(*(int32_t *)0x413a38 - *(uint32_t *)0x413a3c);
        uVar4 = uVar4 + *(uint32_t *)0x413a3c;
    }
    piVar3[-1] = uVar4 + 3;
    *(uint32_t *)((uVar4 - 8) + (int32_t)piVar3) = uVar4;
    if (uVar4 < 0xb30) {
        return;
    }
    uVar4 = uVar4 - 0xb30 >> 8;
    iVar5 = (uVar4 - 0x3ff & -(uint32_t)(uVar4 < 0x3ff)) + 0x3ff;
    uVar4 = iVar5 * 8;
    ppiVar2 = *(int32_t ***)(uVar4 + 0x413ac8);
    *piVar3 = (int32_t)(int32_t **)(uVar4 + 0x413ac4);
    piVar3[1] = (int32_t)ppiVar2;
    *ppiVar2 = piVar3;
    *(int32_t **)(uVar4 + 0x413ac8) = piVar3;
    if (ppiVar2 != (int32_t **)(uVar4 + 0x413ac4)) {
        return;
    }
    uVar4 = uVar4 >> 8 & 0xff;
    puVar1 = (uint32_t *)(uVar4 * 4 + 0x413a44);
    *puVar1 = *puVar1 | 1 << ((uint8_t)iVar5 & 0x1f);
    *(uint32_t *)0x413a40 = *(uint32_t *)0x413a40 | 1 << ((uint8_t)uVar4 & 0x1f);
    return;
}


uint8_t __fastcall fcn.0040134c(uint8_t *param_1, uint8_t param_2)
{
    uint8_t uVar1;
    uint8_t in_AL;
    
    LOCK();
    uVar1 = *param_1;
    *param_1 = *param_1 ^ (in_AL == uVar1) * (*param_1 ^ param_2);
    return in_AL ^ (in_AL == uVar1) * (in_AL & *param_1);
}


void fcn.0040165c(void)
{
    char cVar1;
    
    if (*(char *)0x41304d != '\0') {
        while (cVar1 = fcn.0040134c(), cVar1 != '\0') {
            if (*(char *)0x4138d5 == '\0') {
                sub.kernel32.dll_Sleep(0);
                cVar1 = fcn.0040134c();
                if (cVar1 == '\0') {
                    return;
                }
                sub.kernel32.dll_Sleep();
            }
        }
    }
    return;
}


uint8_t ** fcn.004018f8(void)
{
    int32_t *piVar1;
    int32_t iVar2;
    uint8_t *puVar3;
    uint32_t *puVar4;
    uint16_t uVar5;
    uint8_t *puVar6;
    uint8_t uVar7;
    uint8_t **ppuVar8;
    uint8_t **ppuVar9;
    uint8_t *in_EAX;
    uint8_t **ppuVar10;
    uint32_t uVar11;
    uint32_t uVar12;
    int32_t iVar13;
    uint32_t uVar14;
    uint32_t uVar15;
    uint8_t *puVar16;
    uint32_t uVar17;
    uint32_t uVar18;
    bool bVar19;
    
    if ((uint8_t *)0xa2c < in_EAX) {
        if ((uint8_t *)0x40a2c < in_EAX) {
            if ((int32_t)in_EAX < 0) {
                return (uint8_t **)0x0;
            }
            ppuVar10 = (uint8_t **)
                       sub.kernel32.dll_VirtualAlloc(0, (uint32_t)(in_EAX + 0x10013) & 0xffff0000, 0x101000, 4);
            if (ppuVar10 != (uint8_t **)0x0) {
                ppuVar10[2] = in_EAX;
                ppuVar10[3] = (uint8_t *)((uint32_t)(in_EAX + 0x10013) & 0xffff0000 | 4);
                fcn.0040165c();
                ppuVar8 = *(uint8_t ***)0x415acc;
                *ppuVar10 = (uint8_t *)0x415ac8;
                ppuVar9 = ppuVar10;
                ppuVar10[1] = (uint8_t *)*(uint8_t ***)0x415acc;
                *(uint8_t ***)0x415acc = ppuVar9;
                *ppuVar8 = (uint8_t *)ppuVar10;
                *(undefined *)0x415ac4 = 0;
                ppuVar10 = ppuVar10 + 4;
            }
            return ppuVar10;
        }
        uVar17 = (uint32_t)(in_EAX + 0xd3) & 0xffffff00;
        uVar18 = uVar17 + 0x30;
        if (*(char *)0x41304d != '\0') {
            while( true ) {
                LOCK();
                bVar19 = *(uint8_t *)0x413a34 == 0;
                *(uint8_t *)0x413a34 = *(uint8_t *)0x413a34 ^ bVar19 * (*(uint8_t *)0x413a34 ^ 1);
                if (bVar19) break;
                if (*(char *)0x4138d5 == '\0') {
                    sub.kernel32.dll_Sleep();
                    LOCK();
                    bVar19 = *(uint8_t *)0x413a34 == 0;
                    *(uint8_t *)0x413a34 = *(uint8_t *)0x413a34 ^ bVar19 * (*(uint8_t *)0x413a34 ^ 1);
                    if (bVar19) break;
                    sub.kernel32.dll_Sleep();
                }
            }
        }
        uVar15 = uVar17 - 0xb00;
        uVar14 = uVar15 >> 0xd;
        uVar11 = -1 << ((uint8_t)(uVar15 >> 8) & 0x1f) & *(uint32_t *)(uVar14 * 4 + 0x413a44);
        if (uVar11 == 0) {
            uVar15 = -2 << ((uint8_t)uVar14 & 0x1f) & *(uint32_t *)0x413a40;
            if (uVar15 == 0) {
                if (*(uint32_t *)0x413a3c < uVar18) {
                    ppuVar10 = (uint8_t **)fcn.004015e4();
                } else {
                    ppuVar10 = (uint8_t **)((int32_t)*(uint8_t ***)0x413a38 - uVar18);
                    *(uint8_t ***)0x413a38 = ppuVar10;
                    *(uint32_t *)0x413a3c = *(uint32_t *)0x413a3c - uVar18;
                    ppuVar10[-1] = (uint8_t *)(uVar18 | 2);
                }
                *(undefined *)0x413a34 = 0;
                return ppuVar10;
            }
            uVar14 = 0;
            if (uVar15 != 0) {
                while ((uVar15 >> uVar14 & 1) == 0) {
                    uVar14 = uVar14 + 1;
                }
            }
            uVar15 = *(uint32_t *)(uVar14 * 4 + 0x413a44);
            uVar12 = 0;
            if (uVar15 != 0) {
                while ((uVar15 >> uVar12 & 1) == 0) {
                    uVar12 = uVar12 + 1;
                }
            }
            uVar12 = uVar12 | uVar14 << 5;
        } else {
            uVar12 = 0;
            if (uVar11 != 0) {
                while ((uVar11 >> uVar12 & 1) == 0) {
                    uVar12 = uVar12 + 1;
                }
            }
            uVar12 = uVar15 >> 8 & 0xffffffe0 | uVar12;
        }
        iVar13 = uVar12 * 8;
        ppuVar10 = *(uint8_t ***)(iVar13 + 0x413ac8);
        piVar1 = (int32_t *)ppuVar10[1];
        *(int32_t **)(iVar13 + 0x413ac8) = piVar1;
        *piVar1 = (int32_t)(int32_t *)(iVar13 + 0x413ac4);
        if ((int32_t *)(iVar13 + 0x413ac4) == piVar1) {
            uVar7 = (uint8_t)uVar12 & 0x1f;
            puVar4 = (uint32_t *)(uVar14 * 4 + 0x413a44);
            *puVar4 = *puVar4 & (-2 << uVar7 | 0xfffffffeU >> 0x20 - uVar7);
            if (*puVar4 == 0) {
                puVar3 = (uint8_t *)(((int32_t)uVar14 >> 3) + 0x413a40);
                *puVar3 = *puVar3 & ~('\x01' << (uVar14 & 7));
            }
        }
        uVar15 = ((uint32_t)ppuVar10[-1] & 0xfffffff0) - uVar18;
        if (uVar15 == 0) {
            puVar3 = (uint8_t *)((((uint32_t)ppuVar10[-1] & 0xfffffff0) - 4) + (int32_t)ppuVar10);
            *puVar3 = *puVar3 & 0xf7;
        } else {
            *(uint32_t *)(uVar18 + (int32_t)ppuVar10 + -4) = uVar15 + 3;
            *(uint32_t *)((uVar15 - 8) + uVar18 + (int32_t)ppuVar10) = uVar15;
            if (0xb2f < uVar15) {
                fcn.00401518();
            }
        }
        ppuVar10[-1] = (uint8_t *)(uVar17 + 0x32);
        *(undefined *)0x413a34 = 0;
        return ppuVar10;
    }
    iVar13 = (uint32_t)*(uint8_t *)(((uint32_t)(in_EAX + 3) >> 3) + 0x4138dc) * 8;
    puVar3 = (uint8_t *)(iVar13 + 0x41205c);
    puVar16 = puVar3;
    if (*(char *)0x41304d != '\0') {
        while( true ) {
            LOCK();
            uVar7 = *puVar3;
            *puVar3 = *puVar3 ^ (uVar7 == 0) * (*puVar3 ^ 1);
            puVar16 = puVar3;
            if (uVar7 == 0) break;
            puVar16 = (uint8_t *)(iVar13 + 0x41207c);
            LOCK();
            uVar7 = *puVar16;
            *puVar16 = *puVar16 ^ (uVar7 == 0) * (*puVar16 ^ 1);
            if (uVar7 == 0) break;
            puVar16 = (uint8_t *)(iVar13 + 0x41209c);
            LOCK();
            uVar7 = *puVar16;
            *puVar16 = *puVar16 ^ (uVar7 == 0) * (*puVar16 ^ 1);
            if (uVar7 == 0) break;
            if (*(char *)0x4138d5 == '\0') {
                sub.kernel32.dll_Sleep(0);
                LOCK();
                uVar7 = *puVar3;
                *puVar3 = *puVar3 ^ (uVar7 == 0) * (*puVar3 ^ 1);
                puVar16 = puVar3;
                if (uVar7 == 0) break;
                sub.kernel32.dll_Sleep();
            }
        }
    }
    puVar3 = *(uint8_t **)(puVar16 + 4);
    ppuVar10 = *(uint8_t ***)(puVar3 + 8);
    if (puVar3 != puVar16) {
        *(int32_t *)(puVar3 + 0xc) = *(int32_t *)(puVar3 + 0xc) + 1;
        puVar6 = ppuVar10[-1];
        *(uint32_t *)(puVar3 + 8) = (uint32_t)puVar6 & 0xfffffff8;
        ppuVar10[-1] = puVar3;
        if (((uint32_t)puVar6 & 0xfffffff8) != 0) {
            *puVar16 = 0;
            return ppuVar10;
        }
        iVar13 = *(int32_t *)(puVar3 + 4);
        *(uint8_t **)(iVar13 + 0x14) = puVar16;
        *(int32_t *)(puVar16 + 4) = iVar13;
        *puVar16 = 0;
        return ppuVar10;
    }
    puVar3 = *(uint8_t **)(puVar16 + 0x10);
    uVar5 = *(uint16_t *)(puVar16 + 2);
    if (ppuVar10 < *(uint8_t ***)(puVar16 + 0xc) || ppuVar10 == *(uint8_t ***)(puVar16 + 0xc)) {
        piVar1 = (int32_t *)(puVar3 + 0xc);
        *piVar1 = *piVar1 + 1;
        *(uint32_t *)(puVar16 + 8) = (uint32_t)uVar5 + (int32_t)ppuVar10;
        *puVar16 = 0;
        ppuVar10[-1] = puVar3;
        return ppuVar10;
    }
    if (*(char *)0x41304d != '\0') {
        while( true ) {
            LOCK();
            bVar19 = *(uint8_t *)0x413a34 == 0;
            *(uint8_t *)0x413a34 = *(uint8_t *)0x413a34 ^ bVar19 * (*(uint8_t *)0x413a34 ^ 1);
            if (bVar19) break;
            if (*(char *)0x4138d5 == '\0') {
                sub.kernel32.dll_Sleep();
                LOCK();
                bVar19 = *(uint8_t *)0x413a34 == 0;
                *(uint8_t *)0x413a34 = *(uint8_t *)0x413a34 ^ bVar19 * (*(uint8_t *)0x413a34 ^ 1);
                if (bVar19) break;
                sub.kernel32.dll_Sleep();
            }
        }
    }
    uVar17 = (int32_t)(char)puVar16[1] & *(uint32_t *)0x413a40;
    if (uVar17 == 0) {
        if (*(uint32_t *)0x413a3c < *(uint16_t *)(puVar16 + 0x18)) {
            uVar17 = (uint32_t)*(uint16_t *)(puVar16 + 0x1a);
            ppuVar10 = (uint8_t **)fcn.004015e4();
            if (ppuVar10 == (uint8_t **)0x0) {
                *(undefined *)0x413a34 = 0;
                *puVar16 = 0;
                return (uint8_t **)0x0;
            }
        } else {
            uVar17 = *(uint32_t *)0x413a3c;
            if (*(uint16_t *)(puVar16 + 0x1a) + 0xb30 <= *(uint32_t *)0x413a3c) {
                uVar17 = (uint32_t)*(uint16_t *)(puVar16 + 0x1a);
            }
            ppuVar10 = (uint8_t **)((int32_t)*(uint8_t ***)0x413a38 - uVar17);
            *(uint32_t *)0x413a3c = *(uint32_t *)0x413a3c - uVar17;
            *(uint8_t ***)0x413a38 = ppuVar10;
        }
    } else {
        uVar18 = 0;
        if (uVar17 != 0) {
            while ((uVar17 >> uVar18 & 1) == 0) {
                uVar18 = uVar18 + 1;
            }
        }
        uVar17 = *(uint32_t *)(uVar18 * 4 + 0x413a44);
        iVar13 = 0;
        if (uVar17 != 0) {
            while ((uVar17 >> iVar13 & 1) == 0) {
                iVar13 = iVar13 + 1;
            }
        }
        iVar13 = iVar13 + uVar18 * 0x20;
        iVar2 = iVar13 * 8;
        ppuVar10 = *(uint8_t ***)(iVar2 + 0x413ac8);
        piVar1 = (int32_t *)ppuVar10[1];
        *(int32_t **)(iVar2 + 0x413ac8) = piVar1;
        *piVar1 = (int32_t)(int32_t *)(iVar2 + 0x413ac4);
        if ((int32_t *)(iVar2 + 0x413ac4) == piVar1) {
            uVar7 = (uint8_t)iVar13 & 0x1f;
            puVar4 = (uint32_t *)(uVar18 * 4 + 0x413a44);
            *puVar4 = *puVar4 & (-2 << uVar7 | 0xfffffffeU >> 0x20 - uVar7);
            if (*puVar4 == 0) {
                puVar3 = (uint8_t *)(((int32_t)uVar18 >> 3) + 0x413a40);
                *puVar3 = *puVar3 & ~('\x01' << (uVar18 & 7));
            }
        }
        uVar17 = (uint32_t)ppuVar10[-1] & 0xfffffff0;
        if (uVar17 < 0x10a60) {
            puVar3 = (uint8_t *)((uVar17 - 4) + (int32_t)ppuVar10);
            *puVar3 = *puVar3 & 0xf7;
        } else {
            uVar18 = (uint32_t)*(uint16_t *)(puVar16 + 0x1a);
            iVar13 = uVar17 - uVar18;
            *(int32_t *)(uVar18 + (int32_t)ppuVar10 + -4) = iVar13 + 3;
            *(int32_t *)(iVar13 + -8 + uVar18 + (int32_t)ppuVar10) = iVar13;
            fcn.00401518();
            uVar17 = uVar18;
        }
    }
    ppuVar10[-1] = (uint8_t *)(uVar17 + 6);
    *(undefined *)0x413a34 = 0;
    *ppuVar10 = puVar16;
    ppuVar10[2] = (uint8_t *)0x0;
    ppuVar10[3] = (uint8_t *)0x1;
    *(uint8_t ***)(puVar16 + 0x10) = ppuVar10;
    *(uint32_t *)(puVar16 + 8) = (uint32_t)*(uint16_t *)(puVar16 + 2) + (int32_t)(ppuVar10 + 8);
    *(uint32_t *)(puVar16 + 0xc) = (int32_t)ppuVar10 + (uVar17 - *(uint16_t *)(puVar16 + 2));
    *puVar16 = 0;
    ppuVar10[7] = (uint8_t *)ppuVar10;
    return ppuVar10 + 8;
}


void __fastcall fcn.0040148c(int32_t param_1, int32_t param_2)
{
    int64_t iVar1;
    int32_t in_EAX;
    int32_t iVar2;
    int32_t iVar3;
    
    param_1 = param_1 + -0xc;
    iVar2 = in_EAX + param_1;
    param_2 = param_2 + param_1;
    iVar3 = -param_1;
    if (0 < param_1) {
        do {
            iVar1 = *(int64_t *)(iVar3 + iVar2);
            *(int64_t *)(iVar3 + 8 + param_2) = (int64_t)ROUND((unkfloat10)*(int64_t *)(iVar3 + 8 + iVar2));
            *(int64_t *)(iVar3 + param_2) = (int64_t)ROUND((unkfloat10)iVar1);
            iVar3 = iVar3 + 0x10;
        } while (iVar3 < 0);
    }
    *(int64_t *)(iVar3 + param_2) = (int64_t)ROUND((unkfloat10)*(int64_t *)(iVar3 + iVar2));
    *(undefined4 *)(iVar3 + 8 + param_2) = *(undefined4 *)(iVar3 + 8 + iVar2);
    return;
}


// WARNING: [r2ghidra] Failed to match type PMEMORY_BASIC_INFORMATION for variable lpBuffer to Decompiler type: Unknown
// type identifier PMEMORY_BASIC_INFORMATION

int32_t fcn.00401c7c(void)
{
    uint8_t uVar1;
    uint8_t *puVar2;
    int32_t iVar3;
    uint8_t **in_EAX;
    uint8_t *puVar4;
    int32_t iVar5;
    uint8_t **ppuVar6;
    uint32_t uVar7;
    uint8_t **ppuVar8;
    uint8_t *puVar9;
    bool bVar10;
    uint8_t **ppuVar11;
    undefined auStack32 [8];
    undefined4 uStack24;
    uint8_t **ppuStack20;
    
    ppuVar8 = (uint8_t **)in_EAX[-1];
    if (((uint32_t)ppuVar8 & 7) != 0) {
        if (((uint32_t)ppuVar8 & 5) != 0) {
            if (((uint32_t)ppuVar8 & 3) != 0) {
                return -1;
            }
            ppuVar8 = in_EAX + -4;
            fcn.0040165c();
            if (((uint32_t)in_EAX[-1] & 8) == 0) {
                ppuVar11 = (uint8_t **)0x0;
                iVar5 = sub.kernel32.dll_VirtualFree(ppuVar8, 0, 0x8000, *ppuVar8, in_EAX[-3]);
                ppuVar6 = ppuVar8;
                if (iVar5 == 0) {
                    iVar5 = -1;
                } else {
                    iVar5 = 0;
                }
            } else {
                uVar7 = (uint32_t)in_EAX[-1] & 0xfffffff0;
                iVar5 = 0;
                while( true ) {
                    sub.kernel32.dll_VirtualQuery(ppuVar8, auStack32);
                    ppuVar11 = (uint8_t **)0x0;
                    ppuVar6 = ppuVar8;
                    iVar3 = sub.kernel32.dll_VirtualFree(ppuVar8, 0, 0x8000);
                    if (iVar3 == 0) break;
                    if (uVar7 < 0x1d) goto code_r0x00401783;
                    uVar7 = uVar7 - 0x1c;
                    ppuVar8 = ppuVar8 + 7;
                }
                iVar5 = -1;
            }
code_r0x00401783:
            if (iVar5 == 0) {
                *ppuVar11 = (uint8_t *)ppuVar6;
                ppuVar6[1] = (uint8_t *)ppuVar11;
            }
            *(undefined *)0x415ac4 = 0;
            return iVar5;
        }
        goto code_r0x00401d7d;
    }
    puVar9 = *ppuVar8;
    ppuVar6 = in_EAX;
    if (*(char *)0x41304d != '\0') {
        while( true ) {
            LOCK();
            uVar1 = *puVar9;
            *puVar9 = *puVar9 ^ (uVar1 == 0) * (*puVar9 ^ 1);
            ppuVar6 = in_EAX;
            if (uVar1 == 0) break;
            if (*(char *)0x4138d5 == '\0') {
                in_EAX = (uint8_t **)0x0;
                ppuStack20 = (uint8_t **)0x401d17;
                ppuVar6 = ppuVar8;
                sub.kernel32.dll_Sleep();
                LOCK();
                uVar1 = *puVar9;
                *puVar9 = *puVar9 ^ (uVar1 == 0) * (*puVar9 ^ 1);
                ppuVar8 = in_EAX;
                if (uVar1 == 0) break;
                ppuStack20 = (uint8_t **)0xa;
                uStack24 = 0x401d31;
                sub.kernel32.dll_Sleep();
                ppuVar8 = ppuStack20;
            }
        }
    }
    in_EAX = ppuVar8;
    ppuVar8 = in_EAX + 3;
    *ppuVar8 = *ppuVar8 + -1;
    puVar4 = in_EAX[2];
    if (*ppuVar8 != (uint8_t *)0x0) {
        in_EAX[2] = (uint8_t *)ppuVar6;
        ppuVar6[-1] = puVar4 + 1;
        if (puVar4 != (uint8_t *)0x0) {
            *puVar9 = 0;
            return 0;
        }
        puVar4 = *(uint8_t **)(puVar9 + 4);
        in_EAX[5] = puVar9;
        in_EAX[1] = puVar4;
        *(uint8_t ***)(puVar4 + 0x14) = in_EAX;
        *(uint8_t ***)(puVar9 + 4) = in_EAX;
        *puVar9 = 0;
        return 0;
    }
    if (puVar4 == (uint8_t *)0x0) {
code_r0x00401ce3:
        *(uint8_t **)(puVar9 + 0xc) = puVar4;
    } else {
        puVar4 = in_EAX[5];
        puVar2 = in_EAX[1];
        *(uint8_t **)(puVar4 + 4) = puVar2;
        *(uint8_t **)(puVar2 + 0x14) = puVar4;
        puVar4 = (uint8_t *)0x0;
        if (*(uint8_t ***)(puVar9 + 0x10) == in_EAX) goto code_r0x00401ce3;
    }
    *puVar9 = (uint8_t)puVar4;
    ppuVar8 = (uint8_t **)in_EAX[-1];
code_r0x00401d7d:
    puVar9 = (uint8_t *)((uint32_t)ppuVar8 & 0xfffffff0);
    if (*(char *)0x41304d != '\0') {
        while( true ) {
            LOCK();
            bVar10 = *(uint8_t *)0x413a34 == 0;
            *(uint8_t *)0x413a34 = *(uint8_t *)0x413a34 ^ bVar10 * (*(uint8_t *)0x413a34 ^ 1);
            if (bVar10) break;
            if (*(char *)0x4138d5 == '\0') {
                sub.kernel32.dll_Sleep();
                LOCK();
                bVar10 = *(uint8_t *)0x413a34 == 0;
                *(uint8_t *)0x413a34 = *(uint8_t *)0x413a34 ^ bVar10 * (*(uint8_t *)0x413a34 ^ 1);
                if (bVar10) break;
                ppuStack20 = (uint8_t **)0x401d6f;
                sub.kernel32.dll_Sleep();
            }
        }
    }
    if ((*(uint32_t *)(puVar9 + -4 + (int32_t)in_EAX) & 1) == 0) {
        *(uint32_t *)(puVar9 + -4 + (int32_t)in_EAX) = *(uint32_t *)(puVar9 + -4 + (int32_t)in_EAX) | 8;
    } else {
        uVar7 = *(uint32_t *)(puVar9 + -4 + (int32_t)in_EAX) & 0xfffffff0;
        puVar9 = puVar9 + uVar7;
        if (0xb2f < uVar7) {
            fcn.004014d8();
        }
    }
    if ((*(uint8_t *)(in_EAX + -1) & 8) != 0) {
        puVar4 = in_EAX[-2];
        in_EAX = (uint8_t **)((int32_t)in_EAX - (int32_t)puVar4);
        puVar9 = puVar4 + (int32_t)puVar9;
        if ((uint8_t *)0xb2f < puVar4) {
            fcn.004014d8();
        }
    }
    if (puVar9 != (uint8_t *)0x13ffe0) {
        in_EAX[-1] = puVar9 + 3;
        *(uint8_t **)(puVar9 + -8 + (int32_t)in_EAX) = puVar9;
        fcn.00401518();
        *(undefined *)0x413a34 = 0;
        return 0;
    }
    if (*(int32_t *)0x413a3c == 0x13ffe0) {
        ppuStack20 = in_EAX + -4;
        puVar9 = *ppuStack20;
        ppuVar8 = (uint8_t **)in_EAX[-3];
        *(uint8_t ***)(puVar9 + 4) = ppuVar8;
        *ppuVar8 = puVar9;
        *(undefined *)0x413a34 = 0;
        uStack24 = 0x401e29;
        iVar5 = sub.kernel32.dll_VirtualFree();
        return -(uint32_t)(iVar5 == 0);
    }
    fcn.00401578();
    in_EAX[0x4fff7] = (uint8_t *)0x2;
    *(undefined *)0x413a34 = 0;
    *(uint8_t ***)0x413a38 = in_EAX + 0x4fff8;
    *(undefined4 *)0x413a3c = 0x13ffe0;
    return 0;
}


void __fastcall fcn.004014bc(int32_t param_1, int32_t param_2)
{
    int32_t in_EAX;
    int32_t iVar1;
    
    param_1 = param_1 + -4;
    iVar1 = -param_1;
    do {
        *(int64_t *)(iVar1 + param_2 + param_1) = (int64_t)ROUND((unkfloat10)*(int64_t *)(iVar1 + in_EAX + param_1));
        iVar1 = iVar1 + 8;
    } while (iVar1 < 0);
    *(undefined4 *)(iVar1 + param_2 + param_1) = *(undefined4 *)(iVar1 + in_EAX + param_1);
    return;
}


void __fastcall fcn.00401518(undefined4 param_1, int32_t param_2)
{
    uint32_t *puVar1;
    int32_t **ppiVar2;
    int32_t *in_EAX;
    uint32_t uVar3;
    int32_t iVar4;
    
    uVar3 = param_2 - 0xb30U >> 8;
    iVar4 = (uVar3 - 0x3ff & -(uint32_t)(uVar3 < 0x3ff)) + 0x3ff;
    uVar3 = iVar4 * 8;
    ppiVar2 = *(int32_t ***)(uVar3 + 0x413ac8);
    *in_EAX = (int32_t)(int32_t **)(uVar3 + 0x413ac4);
    in_EAX[1] = (int32_t)ppiVar2;
    *ppiVar2 = in_EAX;
    *(int32_t **)(uVar3 + 0x413ac8) = in_EAX;
    if (ppiVar2 != (int32_t **)(uVar3 + 0x413ac4)) {
        return;
    }
    uVar3 = uVar3 >> 8 & 0xff;
    puVar1 = (uint32_t *)(uVar3 * 4 + 0x413a44);
    *puVar1 = *puVar1 | 1 << ((uint8_t)iVar4 & 0x1f);
    *(uint32_t *)0x413a40 = *(uint32_t *)0x413a40 | 1 << ((uint8_t)uVar3 & 0x1f);
    return;
}


int32_t fcn.004015e4(void)
{
    undefined4 *puVar1;
    undefined4 *puVar2;
    uint32_t in_EAX;
    undefined4 *puVar3;
    int32_t iVar4;
    
    fcn.00401578();
    puVar3 = (undefined4 *)sub.kernel32.dll_VirtualAlloc(0, 0x13fff0, 0x1000, 4);
    puVar1 = *(undefined4 **)0x413a28;
    if (puVar3 != (undefined4 *)0x0) {
        *puVar3 = 0x413a24;
        puVar2 = puVar3;
        puVar3[1] = *(undefined4 **)0x413a28;
        *(undefined4 **)0x413a28 = puVar2;
        *puVar1 = puVar3;
        puVar3[0x4fffb] = 2;
        *(int32_t *)0x413a3c = 0x13ffe0 - in_EAX;
        *(int32_t *)0x413a38 = (int32_t)puVar3 + (0x13fff0 - in_EAX);
        iVar4 = *(int32_t *)0x413a38;
        *(uint32_t *)(*(int32_t *)0x413a38 + -4) = in_EAX | 2;
        return iVar4;
    }
    *(undefined4 *)0x413a3c = 0;
    return 0;
}


// WARNING: Control flow encountered bad instruction data

void __fastcall fcn.00402fbc(uint32_t param_1, int64_t *param_2)
{
    int64_t *piVar1;
    int64_t iVar2;
    int64_t iVar3;
    int64_t iVar4;
    undefined uVar5;
    undefined2 uVar6;
    undefined4 uVar7;
    int64_t *in_EAX;
    int32_t iVar8;
    int32_t iVar9;
    int32_t iVar10;
    int64_t *piVar11;
    bool bVar12;
    
    if (in_EAX != param_2) {
        if (0x20 < param_1) {
            if (0x20 < (int32_t)param_1) {
                if ((param_2 < in_EAX) ||
                   (piVar11 = (int64_t *)((int32_t)param_2 - param_1), param_2 = (int64_t *)(param_1 + (int32_t)piVar11)
                   , in_EAX <= piVar11)) {
                    iVar2 = *in_EAX;
                    piVar11 = (int64_t *)((param_1 - 8) + (int32_t)in_EAX);
                    piVar1 = (int64_t *)((int32_t)param_2 + (param_1 - 8));
                    iVar3 = *piVar11;
                    iVar8 = (((uint32_t)param_2 & 0xfffffff8) + 8) - (int32_t)piVar1;
                    do {
                        *(int64_t *)(iVar8 + (int32_t)piVar1) =
                             (int64_t)ROUND((unkfloat10)*(int64_t *)(iVar8 + (int32_t)piVar11));
                        bVar12 = SCARRY4(iVar8, 8);
                        iVar8 = iVar8 + 8;
                    } while (bVar12 != iVar8 < 0);
                    *piVar1 = (int64_t)ROUND((unkfloat10)iVar3);
                    *param_2 = (int64_t)ROUND((unkfloat10)iVar2);
                    return;
                }
                iVar9 = param_1 - 8;
                iVar2 = *(int64_t *)(iVar9 + (int32_t)in_EAX);
                iVar3 = *in_EAX;
                iVar8 = (iVar9 + (int32_t)param_2 & 0xfffffff8U) - (int32_t)param_2;
                do {
                    *(int64_t *)(iVar8 + (int32_t)param_2) =
                         (int64_t)ROUND((unkfloat10)*(int64_t *)(iVar8 + (int32_t)in_EAX));
                    iVar10 = iVar8 + -8;
                    bVar12 = 7 < iVar8;
                    iVar8 = iVar10;
                } while (iVar10 != 0 && bVar12);
                *param_2 = (int64_t)ROUND((unkfloat10)iVar3);
                *(int64_t *)(iVar9 + (int32_t)param_2) = (int64_t)ROUND((unkfloat10)iVar2);
            }
            return;
        }
        iVar8 = param_1 - 8;
        if (iVar8 == 0 || (int32_t)param_1 < 8) {
            switch(param_1) {
            case 0:
                goto code_r0x00402ff1;
            case 1:
                *(undefined *)param_2 = *(undefined *)in_EAX;
                return;
            case 2:
                *(undefined2 *)param_2 = *(undefined2 *)in_EAX;
                return;
            case 3:
                uVar5 = *(undefined *)((int32_t)in_EAX + 2);
                *(undefined2 *)param_2 = *(undefined2 *)in_EAX;
                *(undefined *)((int32_t)param_2 + 2) = uVar5;
                return;
            case 4:
                *(undefined4 *)param_2 = *(undefined4 *)in_EAX;
                return;
            case 5:
                uVar5 = *(undefined *)((int32_t)in_EAX + 4);
                *(undefined4 *)param_2 = *(undefined4 *)in_EAX;
                *(undefined *)((int32_t)param_2 + 4) = uVar5;
                return;
            case 6:
                uVar6 = *(undefined2 *)((int32_t)in_EAX + 4);
                *(undefined4 *)param_2 = *(undefined4 *)in_EAX;
                *(undefined2 *)((int32_t)param_2 + 4) = uVar6;
                return;
            case 7:
                uVar7 = *(undefined4 *)((int32_t)in_EAX + 3);
                *(undefined4 *)param_2 = *(undefined4 *)in_EAX;
                *(undefined4 *)((int32_t)param_2 + 3) = uVar7;
                return;
            case 8:
                *param_2 = (int64_t)ROUND((unkfloat10)*in_EAX);
                return;
            case 9:
    // WARNING: Bad instruction - Truncating control flow here
                halt_baddata();
            case 10:
    // WARNING: Bad instruction - Truncating control flow here
                halt_baddata();
            case 0xb:
    // WARNING: Bad instruction - Truncating control flow here
                halt_baddata();
            case 0xc:
    // WARNING: Bad instruction - Truncating control flow here
                halt_baddata();
            case 0xd:
    // WARNING: Bad instruction - Truncating control flow here
                halt_baddata();
            case 0xe:
    // WARNING: Bad instruction - Truncating control flow here
                halt_baddata();
            default:
    // WARNING: Bad instruction - Truncating control flow here
                halt_baddata();
            case 0x10:
    // WARNING: Bad instruction - Truncating control flow here
                halt_baddata();
            case 0x11:
    // WARNING: Bad instruction - Truncating control flow here
                halt_baddata();
            case 0x12:
    // WARNING: Bad instruction - Truncating control flow here
                halt_baddata();
            case 0x13:
    // WARNING: Bad instruction - Truncating control flow here
                halt_baddata();
            case 0x14:
    // WARNING: Bad instruction - Truncating control flow here
                halt_baddata();
            case 0x15:
    // WARNING: Bad instruction - Truncating control flow here
                halt_baddata();
            case 0x16:
    // WARNING: Bad instruction - Truncating control flow here
                halt_baddata();
            case 0x17:
    // WARNING: Bad instruction - Truncating control flow here
                halt_baddata();
            case 0x19:
    // WARNING: Bad instruction - Truncating control flow here
                halt_baddata();
            case 0x1a:
    // WARNING: Bad instruction - Truncating control flow here
                halt_baddata();
            case 0x1c:
    // WARNING: Bad instruction - Truncating control flow here
                halt_baddata();
            case 0x1d:
    // WARNING: Bad instruction - Truncating control flow here
                halt_baddata();
            case 0x1e:
    // WARNING: Bad instruction - Truncating control flow here
                halt_baddata();
            case 0x1f:
    // WARNING: Bad instruction - Truncating control flow here
                halt_baddata();
            case 0x20:
    // WARNING: Bad instruction - Truncating control flow here
                halt_baddata();
            }
        }
        iVar2 = *(int64_t *)(iVar8 + (int32_t)in_EAX);
        iVar3 = *in_EAX;
        if (8 < iVar8) {
            iVar4 = in_EAX[1];
            if (0x10 < iVar8) {
                param_2[2] = (int64_t)ROUND((unkfloat10)in_EAX[2]);
            }
            param_2[1] = (int64_t)ROUND((unkfloat10)iVar4);
        }
        *param_2 = (int64_t)ROUND((unkfloat10)iVar3);
        *(int64_t *)(iVar8 + (int32_t)param_2) = (int64_t)ROUND((unkfloat10)iVar2);
    }
code_r0x00402ff1:
    return;
}


int32_t __fastcall fcn.0040237c(int32_t param_1, int32_t param_2)
{
    fcn.00402fbc();
    return param_2 + param_1;
}


void fcn.00404914(void)
{
    char *in_EAX;
    
    if (in_EAX != (char *)0x0) {
        while ((((*in_EAX != '\0' && (in_EAX[1] != '\0')) && (in_EAX[2] != '\0')) && (in_EAX[3] != '\0'))) {
            in_EAX = in_EAX + 4;
        }
    }
    return;
}


// WARNING: [r2ghidra] Failed to match type PMEMORY_BASIC_INFORMATION for variable lpBuffer to Decompiler type: Unknown
// type identifier PMEMORY_BASIC_INFORMATION

undefined4 __cdecl fcn.004023c8(int32_t lpBuffer)
{
    uint32_t in_EAX;
    
    if ((0xffff < in_EAX) && ((in_EAX & 3) == 0)) {
        if ((in_EAX < *(uint32_t *)(lpBuffer + -0x1c)) ||
           (*(uint32_t *)(lpBuffer + -0x1c) + *(int32_t *)(lpBuffer + -0x10) < in_EAX + 4)) {
            *(undefined4 *)(lpBuffer + -0x10) = 0;
            sub.kernel32.dll_VirtualQuery();
        }
        if ((((3 < *(uint32_t *)(lpBuffer + -0x10)) && (*(int32_t *)(lpBuffer + -0xc) == 0x1000)) &&
            ((*(uint8_t *)(lpBuffer + -8) & 0xf6) != 0)) && ((*(uint8_t *)(lpBuffer + -7) & 1) == 0)) {
            return 1;
        }
    }
    return 0;
}


// WARNING: [r2ghidra] Failed to match type PMEMORY_BASIC_INFORMATION for variable lpBuffer to Decompiler type: Unknown
// type identifier PMEMORY_BASIC_INFORMATION

undefined4 __cdecl fcn.00402444(int32_t arg_8h)
{
    char cVar1;
    int32_t in_EAX;
    int32_t in_EDX;
    
    if (((999 < in_EDX) || (cVar1 = fcn.004023c8(arg_8h), cVar1 == '\0')) ||
       (cVar1 = fcn.004023c8(arg_8h), cVar1 == '\0')) {
        return 0;
    }
    if ((in_EAX == *(int32_t *)(in_EAX + -0x58)) &&
       ((*(int32_t *)(in_EAX + -0x30) == 0 ||
        ((cVar1 = fcn.004023c8(arg_8h), cVar1 != '\0' && (cVar1 = fcn.00402444(arg_8h), cVar1 != '\0')))))) {
        return 1;
    }
    return 0;
}


uint32_t fcn.004024ec(void)
{
    uint32_t in_EAX;
    
    if (*(char *)0x41304d != '\0') {
        while (in_EAX = fcn.0040134c(), (char)in_EAX != '\0') {
            if (*(char *)0x4138d5 == '\0') {
                sub.kernel32.dll_Sleep();
                in_EAX = fcn.0040134c();
                if ((char)in_EAX == '\0') break;
                sub.kernel32.dll_Sleep();
            }
        }
    }
    if (*(uint32_t *)0x415ad8 == 0) {
        in_EAX = sub.kernel32.dll_VirtualAlloc(0, 0x10000, 0x1000, 4);
        *(uint32_t *)0x415ad8 = in_EAX;
    }
    return in_EAX & 0xffffff00 | (uint32_t)(*(uint32_t *)0x415ad8 != 0);
}


void __fastcall fcn.00402224(int32_t *param_1, int32_t **param_2)
{
    int32_t iVar1;
    int32_t *in_EAX;
    
    *param_2 = in_EAX + 8;
    iVar1 = *in_EAX;
    if ((in_EAX == *(int32_t **)(iVar1 + 0x10)) &&
       (*(uint32_t *)(iVar1 + 8) < *(uint32_t *)(iVar1 + 0xc) || *(uint32_t *)(iVar1 + 8) == *(uint32_t *)(iVar1 + 0xc))
       ) {
        *param_1 = *(int32_t *)(iVar1 + 8) + -1;
        return;
    }
    *param_1 = (int32_t)in_EAX + ((in_EAX[-1] & 0xfffffff0U) - (uint32_t)*(uint16_t *)(iVar1 + 2));
    return;
}


undefined4 fcn.004025a0(void)
{
    char cVar1;
    int32_t in_EAX;
    int32_t iVar2;
    int32_t iVar3;
    undefined4 uVar4;
    
    uVar4 = 0;
    if (*(int32_t **)0x415ad8 != (int32_t *)0x0) {
        cVar1 = fcn.004024ec();
        if (cVar1 != '\0') {
            iVar3 = **(int32_t **)0x415ad8;
            if (-1 < iVar3 + -1) {
                iVar2 = 0;
                do {
                    if (in_EAX == (*(int32_t **)0x415ad8)[iVar2 + 1]) {
                        (*(int32_t **)0x415ad8)[iVar2 + 1] = (*(int32_t **)0x415ad8)[**(int32_t **)0x415ad8];
                        **(int32_t **)0x415ad8 = **(int32_t **)0x415ad8 + -1;
                        uVar4 = 1;
                        break;
                    }
                    iVar2 = iVar2 + 1;
                    iVar3 = iVar3 + -1;
                } while (iVar3 != 0);
            }
            *(undefined *)0x415adc = 0;
        }
    }
    return uVar4;
}


undefined4 fcn.004024c4(void)
{
    char cVar1;
    undefined4 *in_EAX;
    undefined4 uVar2;
    int32_t var_10h;
    
    uVar2 = *in_EAX;
    cVar1 = fcn.00402444((int32_t)&stack0xfffffffc);
    if (cVar1 == '\0') {
        uVar2 = 0;
    }
    return uVar2;
}


uint32_t fcn.004021e4(void)
{
    uint32_t in_EAX;
    uint32_t uVar1;
    
    if (((*(int32_t *)0x413a3c != 0) && (in_EAX <= *(uint32_t *)0x413a38)) &&
       (*(uint32_t *)0x413a38 <= in_EAX + 0x13fff0)) {
        uVar1 = *(uint32_t *)0x413a38;
        if (*(int32_t *)0x413a3c == 0x13ffe0) {
            uVar1 = 0;
        }
        return uVar1;
    }
    return in_EAX + 0x10;
}


// WARNING: [r2ghidra] Failed to match type signed int for variable var_ch to Decompiler type: Unknown type identifier
// signed
// WARNING: [r2ghidra] Failed to match type signed int for variable var_14h to Decompiler type: Unknown type identifier
// signed
// WARNING: [r2ghidra] Failed to match type signed int for variable var_10h to Decompiler type: Unknown type identifier
// signed
// WARNING: [r2ghidra] Detected overlap for variable var_1ch

void __cdecl fcn.004025f8(int32_t arg_8h)
{
    int32_t *piVar1;
    int32_t iVar2;
    char cVar3;
    bool bVar4;
    int32_t *in_EAX;
    int32_t iVar5;
    uint32_t uVar6;
    int32_t iVar7;
    int32_t var_2ch;
    uint32_t var_28h;
    int32_t var_24h;
    uint32_t var_1dh;
    int32_t var_18h;
    undefined4 var_14h;
    undefined4 var_10h;
    undefined4 var_ch;
    int32_t var_4h;
    
    iVar2 = arg_8h + -0x1b800 + (*in_EAX - 0x41205cU >> 5) * 0x800;
    fcn.00402224();
    do {
        if (var_28h < (uint32_t)var_24h) {
            return;
        }
        if (((*(uint8_t *)(var_24h + -4) & 1) == 0) && (cVar3 = fcn.004025a0(), cVar3 == '\0')) {
            *(undefined *)(arg_8h + -0x1b801) = 0;
            iVar7 = 0;
            iVar5 = fcn.004024c4();
            if (iVar5 == 0) {
                if (*(int32_t *)(var_24h + 4) < 0x100) {
                    var_2ch = *(int32_t *)(var_24h + 8);
                    uVar6 = (uint32_t)*(uint16_t *)(var_24h + 2);
                    if ((((uVar6 == 1) || (uVar6 == 2)) && (0 < var_2ch)) &&
                       ((int32_t)((var_2ch + 1) * uVar6 + 0xc) <= (int32_t)(*(uint16_t *)(*in_EAX + 2) - 4))) {
                        bVar4 = true;
                        if (uVar6 == 1) {
                            var_18h = var_24h + 0xc;
                            if (0 < var_2ch) {
                                do {
                                    if ((bVar4) && (0x1f < *(uint8_t *)var_18h)) {
                                        bVar4 = true;
                                    } else {
                                        bVar4 = false;
                                    }
                                    var_18h = var_18h + 1;
                                    var_2ch = var_2ch + -1;
                                } while (var_2ch != 0);
                            }
                            if ((bVar4) && (*(char *)var_18h == '\0')) {
                                iVar7 = 1;
                            }
                        } else {
                            *(uint16_t **)0x0 = var_24h + 0xc;
                            if (0 < var_2ch) {
                                do {
                                    if ((bVar4) && (0x1f < *(uint16_t *)stack0xffffffe0)) {
                                        bVar4 = true;
                                    } else {
                                        bVar4 = false;
                                    }
                                    unique0x00000f40 = stack0xffffffe0 + 2;
                                    var_2ch = var_2ch + -1;
                                } while (var_2ch != 0);
                            }
                            if ((bVar4) && (*(uint16_t *)stack0xffffffe0 == 0)) {
                                iVar7 = 2;
                            }
                        }
                    }
                }
            } else {
                iVar7 = 3;
                do {
                    if ((iVar5 == *(int32_t *)(iVar2 + iVar7 * 8)) || (*(int32_t *)(iVar2 + iVar7 * 8) == 0)) break;
                    iVar7 = iVar7 + 1;
                } while (iVar7 < 0x100);
                if (iVar7 < 0x100) {
                    *(int32_t *)(iVar2 + iVar7 * 8) = iVar5;
                } else {
                    iVar7 = 0;
                }
            }
            piVar1 = (int32_t *)(iVar2 + 4 + iVar7 * 8);
            *piVar1 = *piVar1 + 1;
        }
        var_24h = var_24h + (uint32_t)*(uint16_t *)(*in_EAX + 2);
    } while( true );
}


int32_t fcn.004021c0(void)
{
    int32_t in_EAX;
    int32_t iVar1;
    
    iVar1 = (*(uint32_t *)(in_EAX + -4) & 0xfffffff0) + in_EAX;
    if ((*(uint32_t *)(iVar1 + -4) & 0xfffffff0) == 0) {
        iVar1 = 0;
    }
    return iVar1;
}


uint8_t * __fastcall fcn.00402260(undefined4 param_1, uint8_t *param_2)
{
    int64_t iVar1;
    int32_t in_EAX;
    uint32_t uVar2;
    uint32_t uVar3;
    uint32_t uVar4;
    
    iVar1 = (uint64_t)(in_EAX + 1) * 0x89705f41;
    uVar3 = (uint32_t)((uint64_t)iVar1 >> 0x20);
    uVar2 = uVar3 >> 0x1d;
    uVar4 = (uVar3 & 0x1fffffff) * 5 + ((uint32_t)iVar1 >> 0x1e);
    *param_2 = (uint8_t)((uint64_t)iVar1 >> 0x3d) | 0x30;
    param_2 = param_2 + (uVar2 != 0);
    uVar2 = uVar2 | uVar4 >> 0x1c;
    *param_2 = (uint8_t)(uVar4 >> 0x1c) | 0x30;
    uVar3 = (uVar4 & 0xfffffff) * 5;
    param_2 = param_2 + (uVar2 != 0);
    uVar4 = (uVar4 & 0xfffffff) * 5 & 0x7ffffff;
    uVar2 = uVar2 | uVar3 >> 0x1b;
    *param_2 = (uint8_t)(uVar3 >> 0x1b) | 0x30;
    uVar3 = uVar4 * 5;
    param_2 = param_2 + (uVar2 != 0);
    uVar4 = uVar4 * 5 & 0x3ffffff;
    uVar2 = uVar2 | uVar3 >> 0x1a;
    *param_2 = (uint8_t)(uVar3 >> 0x1a) | 0x30;
    uVar3 = uVar4 * 5;
    param_2 = param_2 + (uVar2 != 0);
    uVar4 = uVar4 * 5 & 0x1ffffff;
    uVar2 = uVar2 | uVar3 >> 0x19;
    *param_2 = (uint8_t)(uVar3 >> 0x19) | 0x30;
    uVar3 = uVar4 * 5;
    param_2 = param_2 + (uVar2 != 0);
    uVar4 = uVar4 * 5 & 0xffffff;
    uVar2 = uVar2 | uVar3 >> 0x18;
    *param_2 = (uint8_t)(uVar3 >> 0x18) | 0x30;
    param_2 = param_2 + (uVar2 != 0);
    uVar3 = uVar4 * 5 >> 0x17;
    uVar4 = uVar4 * 5 & 0x7fffff;
    uVar2 = uVar2 | uVar3;
    *param_2 = (uint8_t)uVar3 | 0x30;
    param_2 = param_2 + (uVar2 != 0);
    uVar3 = uVar4 * 5 >> 0x16;
    uVar4 = uVar4 * 5 & 0x3fffff;
    uVar2 = uVar2 | uVar3;
    *param_2 = (uint8_t)uVar3 | 0x30;
    param_2 = param_2 + (uVar2 != 0);
    uVar3 = uVar4 * 5 >> 0x15;
    *param_2 = (uint8_t)uVar3 | 0x30;
    param_2[(uVar2 | uVar3) != 0] = (uint8_t)((uVar4 * 5 & 0x1fffff) * 5 >> 0x14) | 0x30;
    return param_2 + ((uVar2 | uVar3) != 0) + 1;
}


void fcn.00402394(void)
{
    int32_t in_EAX;
    
    if (in_EAX != 0) {
        fcn.0040237c();
        return;
    }
    fcn.00404914();
    fcn.0040237c();
    return;
}


void fcn.00402b9c(void)
{
    uint32_t uVar1;
    uint16_t *puVar2;
    int32_t iVar3;
    uint32_t uVar4;
    
    iVar3 = 0;
    puVar2 = (uint16_t *)0x41205e;
    uVar1 = 0;
    do {
        if ((*(char *)0x413a22 == '\0') || (uVar4 = uVar1, (*(uint8_t *)puVar2 & 0xf) == 0)) {
            uVar4 = (uint32_t)(*puVar2 >> 3);
            while (uVar1 < uVar4) {
                *(char *)(uVar1 + 0x4138dc) = (char)iVar3 * '\x04';
                uVar1 = uVar1 + 1;
            }
        }
        iVar3 = iVar3 + 1;
        puVar2 = puVar2 + 0x10;
        uVar1 = uVar4;
    } while (iVar3 != 0x37);
    return;
}


// WARNING: Variable defined which should be unmapped: var_27824h
// WARNING: [r2ghidra] Failed to match type signed int for variable var_1b808h to Decompiler type: Unknown type
// identifier signed
// WARNING: [r2ghidra] Failed to match type signed int for variable var_1b814h to Decompiler type: Unknown type
// identifier signed
// WARNING: [r2ghidra] Detected overlap for variable var_1b801h
// WARNING: [r2ghidra] Detected overlap for variable var_1b809h
// WARNING: [r2ghidra] Detected overlap for variable var_1b80ah
// WARNING: [r2ghidra] Failed to match type signed int for variable var_ch to Decompiler type: Unknown type identifier
// signed
// WARNING: [r2ghidra] Failed to match type signed int for variable var_14h to Decompiler type: Unknown type identifier
// signed
// WARNING: [r2ghidra] Failed to match type signed int for variable var_10h to Decompiler type: Unknown type identifier
// signed
// WARNING: [r2ghidra] Detected overlap for variable var_1ch

void fcn.004027b8(void)
{
    uint32_t uVar1;
    bool bVar2;
    bool bVar3;
    char cVar4;
    int32_t iVar5;
    int32_t iVar6;
    int32_t *piVar7;
    undefined *puVar8;
    int32_t *piVar9;
    int32_t var_27824h;
    int32_t var_20025h;
    int32_t var_1f824h;
    int32_t var_1b824h;
    int32_t var_1b820h;
    int32_t var_1b81ch;
    int32_t var_1b818h;
    undefined4 var_1b814h;
    int32_t var_1b810h;
    int32_t var_1b808h;
    int32_t var_1b800h;
    int32_t var_1b004h;
    int32_t var_4h;
    
    iVar5 = 0x27;
    do {
        iVar5 = iVar5 + -1;
    } while (iVar5 != 0);
    fcn.00403250();
    fcn.00403250();
    var_1b808h = 0;
    bVar2 = true;
    iVar5 = *(int32_t *)0x413a28;
    while (iVar6 = *(int32_t *)0x415acc, iVar5 != 0x413a24) {
        iVar6 = fcn.004021e4();
        while (iVar6 != 0) {
            uVar1 = *(uint32_t *)(iVar6 + -4);
            if ((uVar1 & 1) == 0) {
                if ((uVar1 & 4) == 0) {
                    if (var_1b808h < 0x1000) {
                        cVar4 = fcn.004025a0();
                        if (cVar4 == '\0') {
                            bVar2 = false;
                            (&var_1f824h)[var_1b808h] = (uVar1 & 0xfffffff0) - 4;
                            var_1b808h = var_1b808h + 1;
                        }
                    }
                } else {
                    fcn.004025f8((int32_t)&stack0xfffffffc);
                }
            }
            iVar6 = fcn.004021c0();
        }
        iVar5 = *(int32_t *)(iVar5 + 4);
    }
    while ((iVar6 != 0x415ac8 && (var_1b808h < 0x1000))) {
        cVar4 = fcn.004025a0();
        if (cVar4 == '\0') {
            bVar2 = false;
            (&var_1f824h)[var_1b808h] = (*(uint32_t *)(iVar6 + 0xc) & 0xfffffff0) - 0x14;
            var_1b808h = var_1b808h + 1;
        }
        iVar6 = *(int32_t *)(iVar6 + 4);
    }
    if (!bVar2) {
        bVar2 = false;
        fcn.00404914();
        piVar7 = (int32_t *)fcn.0040237c();
        var_1b810h = 0x37;
        var_1b824h = (int32_t)&var_1b004h;
        do {
            bVar3 = false;
            iVar5 = 0xff;
            piVar9 = (int32_t *)var_1b824h;
            do {
                if (&var_20025h < piVar7) break;
                if (*piVar9 != 0) {
                    if (!bVar2) {
                        fcn.00404914();
                        piVar7 = (int32_t *)fcn.0040237c();
                        bVar2 = true;
                    }
                    if (bVar3) {
                        *(undefined *)piVar7 = 0x2c;
                        *(undefined *)((int32_t)piVar7 + 1) = 0x20;
                    } else {
                        *(undefined *)piVar7 = 0xd;
                        *(undefined *)((int32_t)piVar7 + 1) = 10;
                        puVar8 = (undefined *)fcn.00402260();
                        *puVar8 = 0x20;
                        puVar8[1] = 0x2d;
                        puVar8[2] = 0x20;
                        fcn.00402260();
                        fcn.00404914();
                        fcn.0040237c();
                        bVar3 = true;
                    }
                    if (iVar5 == 0) {
                        fcn.00404914();
                        puVar8 = (undefined *)fcn.0040237c();
                    } else {
                        if (iVar5 == 1) {
                            fcn.00404914();
                            puVar8 = (undefined *)fcn.0040237c();
                        } else {
                            if (iVar5 == 2) {
                                fcn.00404914();
                                puVar8 = (undefined *)fcn.0040237c();
                            } else {
                                puVar8 = (undefined *)fcn.00402394();
                            }
                        }
                    }
                    *puVar8 = 0x20;
                    puVar8[1] = 0x78;
                    puVar8[2] = 0x20;
                    piVar7 = (int32_t *)fcn.00402260();
                }
                iVar5 = iVar5 + -1;
                piVar9 = piVar9 + -2;
            } while (iVar5 != -1);
            var_1b824h = var_1b824h + 0x800;
            var_1b810h = var_1b810h + -1;
        } while (var_1b810h != 0);
        if (0 < var_1b808h) {
            if (bVar2) {
                *(undefined *)piVar7 = 0xd;
                *(undefined *)((int32_t)piVar7 + 1) = 10;
                *(undefined *)((int32_t)piVar7 + 2) = 0xd;
                *(undefined *)((int32_t)piVar7 + 3) = 10;
            }
            fcn.00404914();
            piVar7 = (int32_t *)fcn.0040237c();
            iVar5 = 0;
            do {
                if (iVar5 != 0) {
                    *(undefined *)piVar7 = 0x2c;
                    *(undefined *)((int32_t)piVar7 + 1) = 0x20;
                }
                piVar7 = (int32_t *)fcn.00402260();
                if (&var_20025h < piVar7) break;
                iVar5 = iVar5 + 1;
                var_1b808h = var_1b808h + -1;
            } while (var_1b808h != 0);
        }
        fcn.00404914();
        fcn.0040237c();
        sub.user32.dll_MessageBoxA();
    }
    return;
}


void fcn.00402d08(void)
{
    int32_t iVar1;
    int32_t iVar2;
    int32_t iVar3;
    
    iVar1 = *(int32_t *)0x413a28;
    while (iVar1 != 0x413a24) {
        iVar1 = *(int32_t *)(iVar1 + 4);
        sub.kernel32.dll_VirtualFree();
    }
    iVar2 = 0x37;
    iVar1 = 0x41205c;
    do {
        *(int32_t *)(iVar1 + 0x14) = iVar1;
        *(int32_t *)(iVar1 + 4) = iVar1;
        *(undefined4 *)(iVar1 + 8) = 1;
        *(undefined4 *)(iVar1 + 0xc) = 0;
        iVar1 = iVar1 + 0x20;
        iVar2 = iVar2 + -1;
    } while (iVar2 != 0);
    *(undefined4 *)0x413a24 = 0x413a24;
    *(undefined4 *)0x413a28 = 0x413a24;
    iVar2 = 0x400;
    iVar1 = 0x413ac4;
    do {
        *(int32_t *)iVar1 = iVar1;
        *(int32_t *)(iVar1 + 4) = iVar1;
        iVar1 = iVar1 + 8;
        iVar2 = iVar2 + -1;
        iVar3 = *(int32_t *)0x415acc;
    } while (iVar2 != 0);
    while (iVar3 != 0x415ac8) {
        iVar3 = *(int32_t *)(iVar3 + 4);
        sub.kernel32.dll_VirtualFree();
    }
    *(undefined4 *)0x415ac8 = 0x415ac8;
    *(undefined4 *)0x415acc = 0x415ac8;
    return;
}


void __fastcall fcn.00402f08(undefined4 param_1, undefined4 param_2)
{
    *(undefined4 *)0x412004 = param_2;
    fcn.004046ac();
    return;
}


void fcn.00402f8c(void)
{
    undefined4 in_EAX;
    int32_t iVar1;
    
    iVar1 = fcn.00406588();
    *(undefined4 *)(iVar1 + 4) = in_EAX;
    return;
}


int32_t __fastcall fcn.00403134(undefined4 param_1, code *param_2)
{
    int32_t in_EAX;
    int32_t iVar1;
    
    if (*(int16_t *)(in_EAX + 4) == -0x284f) {
        iVar1 = 0;
    } else {
        if ((uint16_t)(*(int16_t *)(in_EAX + 4) + 0x284eU) < 2) {
            iVar1 = (*param_2)();
        } else {
            if ((in_EAX == 0x413324) || (in_EAX == 0x4135f4)) {
                iVar1 = 0;
            } else {
                iVar1 = 0x67;
            }
        }
    }
    if (iVar1 != 0) {
        fcn.00402f8c();
    }
    return iVar1;
}


undefined4 fcn.0040385c(void)
{
    int32_t in_EAX;
    
    return *(undefined4 *)(in_EAX + -0x34);
}


// WARNING: Removing unreachable block (ram,0x004038d5)
// WARNING: Removing unreachable block (ram,0x004038db)
// WARNING: Removing unreachable block (ram,0x004038e2)
// WARNING: Removing unreachable block (ram,0x004038e8)
// WARNING: Removing unreachable block (ram,0x004038ee)

void __fastcall fcn.004038a0(undefined4 param_1, int32_t *param_2)
{
    int32_t in_EAX;
    uint32_t uVar1;
    uint32_t uVar2;
    int32_t *piVar3;
    
    *param_2 = in_EAX;
    uVar2 = *(uint32_t *)(in_EAX + -0x34);
    uVar1 = uVar2 >> 2;
    piVar3 = param_2 + 1;
    while (uVar1 = uVar1 - 1, uVar1 != 0) {
        *piVar3 = 0;
        piVar3 = piVar3 + 1;
    }
    uVar2 = uVar2 & 3;
    while (uVar2 != 0) {
        uVar2 = uVar2 - 1;
        *(undefined *)piVar3 = 0;
        piVar3 = (int32_t *)((int32_t)piVar3 + 1);
    }
    while (*(int32_t **)(in_EAX + -0x30) != (int32_t *)0x0) {
        in_EAX = **(int32_t **)(in_EAX + -0x30);
    }
    return;
}


void fcn.004038f8(void)
{
    int32_t iVar1;
    int32_t *in_EAX;
    
    do {
        iVar1 = *in_EAX;
        in_EAX = *(int32_t **)(iVar1 + -0x30);
        if (*(int32_t *)(iVar1 + -0x4c) != 0) {
            fcn.004054f8();
        }
    } while (in_EAX != (int32_t *)0x0);
    fcn.00403a9c();
    return;
}


// WARNING: [r2ghidra] Var arg_10h is stack pointer based, which is not supported for decompilation.

void __fastcall
fcn.004039e4(undefined4 param_1, char param_2, undefined4 param_3, undefined4 param_4, undefined4 param_5,
            undefined4 param_6)
{
    int32_t in_EAX;
    int32_t *in_FS_OFFSET;
    
    if (-1 < param_2) {
        (**(code **)(in_EAX + -0xc))();
    }
    *in_FS_OFFSET = (int32_t)&param_3;
    return;
}


int32_t fcn.00403a3c(void)
{
    int32_t *in_EAX;
    undefined4 *in_FS_OFFSET;
    undefined4 uStack32;
    undefined4 uStack28;
    undefined *puStack24;
    int32_t var_4h;
    
    puStack24 = &stack0xfffffffc;
    uStack28 = 0x403a6b;
    uStack32 = *in_FS_OFFSET;
    *in_FS_OFFSET = &uStack32;
    var_4h = (int32_t)in_EAX;
    (**(code **)(*in_EAX + -0x1c))();
    *in_FS_OFFSET = uStack32;
    return var_4h;
}


void loc.00403a84(void)
{
    return;
}


undefined8 __fastcall fcn.00403a8c(undefined4 param_1, undefined4 param_2)
{
    int32_t *in_EAX;
    
    if ((char)param_2 < '\x01') {
        return CONCAT44(param_2, in_EAX);
    }
    (**(code **)(*in_EAX + -0x18))();
    return CONCAT44(param_2, in_EAX);
}


void fcn.00403a34(void)
{
    int32_t *in_EAX;
    
    (**(code **)(*in_EAX + -8))();
    return;
}


void __fastcall fcn.004054f8(undefined4 param_1, int32_t param_2)
{
    bool bVar1;
    int32_t iVar2;
    int32_t iVar3;
    
    iVar2 = *(int32_t *)(*(uint8_t *)(param_2 + 1) + 6 + param_2);
    if (iVar2 != 0) {
        do {
            fcn.00405548();
            iVar3 = iVar2 + -1;
            bVar1 = 0 < iVar2;
            iVar2 = iVar3;
        } while (iVar3 != 0 && bVar1);
    }
    return;
}


void fcn.00403a9c(void)
{
    int32_t *piVar1;
    
    piVar1 = (int32_t *)fcn.00403ae0();
    if (*piVar1 != 0) {
        *piVar1 = 0;
        fcn.00403ab4();
    }
    return;
}


int32_t fcn.00403ae0(void)
{
    int32_t *in_EAX;
    
    return (int32_t)in_EAX + *(int32_t *)(*in_EAX + -0x34) + -4;
}


void fcn.00403ab4(void)
{
    int32_t in_EAX;
    
    if ((*(int32_t *)0x4138c4 != 0) && (*(int32_t *)(in_EAX + 0xc) != 0)) {
        (**(code **)(*(int32_t *)0x4138c4 + 4))();
    }
    fcn.00402e20();
    return;
}


int32_t * __fastcall fcn.00403980(undefined4 param_1, int32_t param_2)
{
    int32_t *piVar1;
    int32_t in_EAX;
    
    while( true ) {
        if (in_EAX == param_2) {
            return (int32_t *)0x1;
        }
        piVar1 = *(int32_t **)(in_EAX + -0x30);
        if (piVar1 == (int32_t *)0x0) break;
        in_EAX = *piVar1;
    }
    return piVar1;
}


void fcn.00403950(void)
{
    int32_t in_EAX;
    uint32_t uVar1;
    uint16_t unaff_SI;
    uint16_t *puVar2;
    bool bVar3;
    
    do {
        puVar2 = *(uint16_t **)(in_EAX + -0x3c);
        if (puVar2 != (uint16_t *)0x0) {
            uVar1 = (uint32_t)*puVar2;
            bVar3 = puVar2 + 1 == (uint16_t *)0x0;
            puVar2 = puVar2 + 1;
            do {
                if (uVar1 == 0) break;
                uVar1 = uVar1 - 1;
                bVar3 = unaff_SI == *puVar2;
                puVar2 = puVar2 + 1;
            } while (!bVar3);
            if (bVar3) {
                return;
            }
        }
        if (*(int32_t **)(in_EAX + -0x30) == (int32_t *)0x0) {
            return;
        }
        in_EAX = **(int32_t **)(in_EAX + -0x30);
    } while( true );
}


// WARNING: [r2ghidra] Var arg_30h is stack pointer based, which is not supported for decompilation.

undefined4 fcn.00403ff8(void)
{
    uint32_t *puVar1;
    int32_t *piVar2;
    int32_t *piVar3;
    undefined4 *in_FS_OFFSET;
    undefined4 *in_stack_00000014;
    int32_t in_stack_00000030;
    
    *(undefined4 *)(in_stack_00000030 + 4) = 0x404043;
    piVar3 = (int32_t *)fcn.00406588();
    piVar2 = (int32_t *)*piVar3;
    *piVar3 = *piVar2;
    piVar2 = (int32_t *)piVar2[3];
    puVar1 = (uint32_t *)(piVar2 + 1);
    *puVar1 = *puVar1 & 0xfffffffd;
    if (*piVar2 != 0xeedfade) {
        fcn.00403894();
        fcn.00403af0();
    }
    *in_stack_00000014 = *(undefined4 *)*in_FS_OFFSET;
    return 1;
}


void fcn.00403af0(void)
{
    if (1 < *(uint8_t *)0x412020) {
        (**(code **)0x413014)(0xeedfadf, 0, 0, 0);
    }
    return;
}


void fcn.00403b70(void)
{
    return;
}


void __fastcall fcn.00403b0c(undefined4 param_1, undefined4 param_2)
{
    undefined4 auStack12 [3];
    
    if (*(char *)0x412020 != '\0') {
        auStack12[0] = param_2;
        (**(code **)0x413014)(0xeedfae4, 0, 2, auStack12);
    }
    return;
}


undefined4 fcn.00403b5c(void)
{
    undefined4 in_EAX;
    undefined4 uVar1;
    
    if (1 < *(uint8_t *)0x412020) {
        uVar1 = 0;
        (**(code **)0x413014)(0xeedfae0, 0, 1, &stack0xfffffff8);
        return uVar1;
    }
    return in_EAX;
}


undefined4 fcn.00403b48(void)
{
    undefined4 in_EAX;
    int32_t unaff_EBX;
    undefined4 uVar1;
    undefined4 auStack8 [2];
    
    if (1 < *(uint8_t *)0x412020) {
        auStack8[0] = *(undefined4 *)(unaff_EBX + 4);
        uVar1 = 0;
        (**(code **)0x413014)(0xeedfae0, 0, 1, auStack8);
        return uVar1;
    }
    return in_EAX;
}


void __fastcall fcn.00403b90(undefined4 param_1, undefined4 param_2)
{
    undefined4 auStack16 [2];
    undefined4 uStack8;
    
    if (1 < *(uint8_t *)0x412020) {
        auStack16[0] = 0x403ba1;
        uStack8 = param_2;
        fcn.00403b70();
        (**(code **)0x413014)(0xeedfae1, 0, 1, auStack16);
    }
    return;
}


void fcn.004046b8(void)
{
    undefined4 in_EAX;
    undefined4 unaff_retaddr;
    
    *(undefined4 *)0x412000 = in_EAX;
    *(undefined4 *)0x412004 = unaff_retaddr;
    fcn.00404580();
    return;
}


undefined4 fcn.00402efc(void)
{
    undefined4 *puVar1;
    
    puVar1 = (undefined4 *)fcn.00406588();
    return *puVar1;
}


void __fastcall fcn.00403bb8(undefined4 param_1, undefined4 param_2)
{
    undefined4 uStack4;
    
    if (1 < *(uint8_t *)0x412020) {
        uStack4 = param_2;
        (**(code **)0x413014)(0xeedfae2, 0, 1, &uStack4);
    }
    return;
}


undefined8 __fastcall fcn.00403bd4(undefined4 param_1, undefined4 param_2)
{
    undefined4 in_EAX;
    undefined4 uStack8;
    undefined4 uStack4;
    
    uStack8 = param_2;
    uStack4 = in_EAX;
    if (1 < *(uint8_t *)0x412020) {
        (**(code **)0x413014)(0xeedfae3, 0, 2, &uStack8);
    }
    return CONCAT44(uStack8, uStack4);
}


void fcn.00404204(void)
{
    int32_t iVar1;
    code *pcVar2;
    int32_t iVar3;
    undefined4 *in_FS_OFFSET;
    undefined4 uStack28;
    undefined4 uStack24;
    undefined *puStack20;
    
    iVar3 = *(int32_t *)0x415af0;
    puStack20 = &stack0xfffffffc;
    if (*(int32_t *)0x415aec != 0) {
        iVar1 = *(int32_t *)(*(int32_t *)0x415aec + 4);
        uStack24 = 0x40424d;
        uStack28 = *in_FS_OFFSET;
        *in_FS_OFFSET = &uStack28;
        if (0 < iVar3) {
            do {
                iVar3 = iVar3 + -1;
                pcVar2 = *(code **)(iVar1 + 4 + iVar3 * 8);
                *(int32_t *)0x415af0 = iVar3;
                if (pcVar2 != (code *)0x0) {
                    (*pcVar2)();
                }
            } while (0 < iVar3);
        }
        *in_FS_OFFSET = uStack28;
    }
    return;
}


void fcn.00404458(void)
{
    int32_t iVar1;
    uint32_t uVar2;
    uint32_t uVar3;
    
    uVar2 = 0x10;
    iVar1 = *(int32_t *)0x412000;
    do {
        "Runtime error     at 00000000"[uVar2 & 0xff] = (char)(iVar1 % 10) + '0';
        iVar1 = iVar1 / 10;
        uVar2 = uVar2 - 1;
    } while (iVar1 != 0);
    uVar3 = 0x1c;
    uVar2 = *(uint32_t *)0x412004;
    do {
        "Runtime error     at 00000000"[uVar3 & 0xff] = *(char *)(*(int32_t *)0x412798 + (uVar2 & 0xf));
        uVar2 = uVar2 / 0x10;
        uVar3 = uVar3 - 1;
    } while (uVar2 != 0);
    return;
}


void fcn.004044f0(void)
{
    undefined4 uVar1;
    undefined4 uStack28;
    undefined4 uStack24;
    char *pcStack20;
    char *pcStack16;
    char *pcStack12;
    undefined4 uStack8;
    undefined auStack4 [4];
    
    if (*(char *)0x41304c != '\0') {
        if ((*(int16_t *)0x413328 == -0x284e) && (*(int32_t *)0x413330 != 0)) {
            uStack8 = 0x404519;
            (**(code **)0x413340)();
        }
        pcStack12 = auStack4;
        uStack8 = 0;
        pcStack16 = (char *)0x1d;
        pcStack20 = "Runtime error     at 00000000";
        uStack24 = 0xfffffff5;
        uStack28 = 0x40452e;
        uStack28 = sub.kernel32.dll_GetStdHandle();
        sub.kernel32.dll_WriteFile();
        uVar1 = sub.kernel32.dll_GetStdHandle(0xfffffff5, 0x40457c, 2, &uStack28, 0);
        sub.kernel32.dll_WriteFile(uVar1);
        return;
    }
    if (*(char *)0x412028 == '\0') {
        uStack8 = 0;
        pcStack12 = "Error";
        pcStack16 = "Runtime error     at 00000000";
        pcStack20 = (char *)0x0;
        uStack24 = 0x40456d;
        sub.user32.dll_MessageBoxA();
    }
    return;
}


void fcn.004041dc(void)
{
    int32_t **ppiVar1;
    int32_t in_EAX;
    int32_t **ppiVar2;
    int32_t *in_FS_OFFSET;
    
    ppiVar1 = *(int32_t ***)(in_EAX + 4);
    if (ppiVar1 != (int32_t **)0x0) {
        ppiVar2 = (int32_t **)*in_FS_OFFSET;
        if (ppiVar1 == ppiVar2) {
            *in_FS_OFFSET = (int32_t)*ppiVar1;
            return;
        }
        while (ppiVar2 != (int32_t **)0xffffffff) {
            if ((int32_t **)*ppiVar2 == ppiVar1) {
                *ppiVar2 = *ppiVar1;
                return;
            }
            ppiVar2 = (int32_t **)*ppiVar2;
        }
    }
    return;
}


bool fcn.004044c4(void)
{
    undefined4 *in_EAX;
    int32_t iVar1;
    undefined4 *puVar2;
    bool bVar3;
    
    iVar1 = 0xc;
    puVar2 = (undefined4 *)*in_EAX;
    while (iVar1 != 0) {
        iVar1 = iVar1 + -1;
        *in_EAX = *puVar2;
        puVar2 = puVar2 + 1;
        in_EAX = in_EAX + 1;
    }
    bVar3 = *(int32_t *)0x412000 == 0;
    *(undefined4 *)0x412000 = 0;
    return bVar3;
}


undefined4 fcn.00402ec8(void)
{
    int32_t iVar1;
    int32_t *piVar2;
    undefined4 uVar3;
    
    piVar2 = (int32_t *)fcn.00406588();
    iVar1 = *piVar2;
    if (iVar1 == 0) {
        uVar3 = 0;
    } else {
        uVar3 = *(undefined4 *)(iVar1 + 8);
        *(undefined4 *)(iVar1 + 8) = 0;
        if (*(code **)0x413020 != (code *)0x0) {
            (**(code **)0x413020)();
        }
    }
    return uVar3;
}


void fcn.00406204(void)
{
    int32_t **ppiVar1;
    uint32_t in_EAX;
    undefined4 *in_FS_OFFSET;
    undefined4 uStack20;
    undefined4 uStack16;
    undefined *puStack12;
    uint32_t var_4h;
    
    puStack12 = &stack0xfffffffc;
    uStack16 = 0x406268;
    uStack20 = *in_FS_OFFSET;
    *in_FS_OFFSET = &uStack20;
    var_4h = in_EAX;
    fcn.00406198();
    *in_FS_OFFSET = uStack20;
    ppiVar1 = *(int32_t ***)0x41202c;
    if ((int32_t **)var_4h == *(int32_t ***)0x41202c) {
        *(int32_t ***)0x41202c = *(int32_t ***)var_4h;
    } else {
        while (ppiVar1 != (int32_t **)0x0) {
            if (*ppiVar1 == (int32_t *)var_4h) {
                *ppiVar1 = *(int32_t **)var_4h;
                return;
            }
            ppiVar1 = (int32_t **)*ppiVar1;
        }
    }
    return;
}


// WARNING: Removing unreachable block (ram,0x00402f34)

undefined2 * __fastcall fcn.00404774(undefined4 param_1, int32_t param_2)
{
    int32_t in_EAX;
    uint32_t uVar1;
    undefined2 *puVar2;
    
    if (in_EAX < 1) {
        return (undefined2 *)0x0;
    }
    if (SCARRY4(in_EAX, 0xe)) {
        if (*(code **)0x413008 != (code *)0x0) {
            (**(code **)0x413008)();
        }
        puVar2 = (undefined2 *)fcn.00402f08();
        return puVar2;
    }
    uVar1 = in_EAX + 0xeU & 0xfffffffe;
    puVar2 = (undefined2 *)fcn.00402e04();
    *(undefined2 *)((uVar1 - 2) + (int32_t)puVar2) = 0;
    *(int32_t *)(puVar2 + 4) = in_EAX;
    *(undefined4 *)(puVar2 + 2) = 1;
    if (param_2 == 0) {
        param_2 = *(int32_t *)0x4138c8;
    }
    *puVar2 = (int16_t)param_2;
    puVar2[1] = 1;
    return puVar2 + 6;
}


// WARNING: Removing unreachable block (ram,0x00402f34)

void fcn.0040380c(void)
{
    if (*(code **)0x413008 != (code *)0x0) {
        (**(code **)0x413008)();
    }
    fcn.00402f08();
    return;
}


// WARNING: Possible PIC construction at 0x00404dcc: Changing call to branch
// WARNING: Removing unreachable block (ram,0x00404dd1)
// WARNING: [r2ghidra] Failed to match type UINT for variable CodePage to Decompiler type: Unknown type identifier UINT

void __fastcall fcn.00404e6c(undefined4 param_1, int32_t param_2)
{
    int32_t *piVar1;
    int32_t iVar2;
    int32_t *in_EAX;
    int32_t iVar3;
    uint32_t unaff_retaddr;
    
    do {
        iVar3 = 0;
        if (param_2 == 0) {
code_r0x00404d30:
            if (iVar3 < 1) {
                fcn.00404c88();
            } else {
                if ((iVar3 + 1 < 0x7ff) && (iVar2 = fcn.004047ec(unaff_retaddr, iVar3), 0 < iVar2)) {
                    fcn.00404dd4();
                } else {
                    fcn.00404f00();
                    fcn.004047ec(unaff_retaddr, iVar3);
                    fcn.00404f00();
                }
            }
            return;
        }
        if (*(int16_t *)(param_2 + -10) != 2) {
            unaff_retaddr = (uint32_t)*(uint16_t *)(param_2 + -0xc);
            iVar3 = *(int32_t *)(param_2 + -4);
            goto code_r0x00404d30;
        }
        if (param_2 == 0) goto code_r0x00404cce;
    } while (*(int16_t *)(param_2 + -10) != 2);
    iVar3 = *(int32_t *)(param_2 + -8);
    if (iVar3 == -1 || SCARRY4(iVar3, 1) != iVar3 + 1 < 0) {
        param_2 = fcn.004054b4(param_2);
        fcn.00402fbc();
    } else {
        LOCK();
        *(int32_t *)(param_2 + -8) = *(int32_t *)(param_2 + -8) + 1;
    }
code_r0x00404cce:
    iVar3 = *in_EAX;
    *in_EAX = param_2;
    if ((iVar3 != 0) && (0 < *(int32_t *)(iVar3 + -8))) {
        LOCK();
        piVar1 = (int32_t *)(iVar3 + -8);
        *piVar1 = *piVar1 + -1;
        if (*piVar1 == 0) {
            fcn.00402e20();
        }
    }
    return;
}


undefined4 fcn.00404820(void)
{
    undefined4 *in_EAX;
    
    fcn.00404e6c();
    return *in_EAX;
}


void fcn.004046c4(void)
{
    int32_t *piVar1;
    int32_t iVar2;
    int32_t *in_EAX;
    
    iVar2 = *in_EAX;
    if ((iVar2 != 0) && (*in_EAX = 0, 0 < *(int32_t *)(iVar2 + -8))) {
        LOCK();
        piVar1 = (int32_t *)(iVar2 + -8);
        *piVar1 = *piVar1 + -1;
        if (*piVar1 == 0) {
            fcn.00402e20();
        }
    }
    return;
}


void __cdecl fcn.004047c0(int32_t arg_8h, int32_t arg_ch)
{
    if (arg_8h == 0) {
        arg_8h = *(int32_t *)0x4138c8;
    }
    sub.kernel32.dll_WideCharToMultiByte(arg_8h, 0);
    return;
}


// WARNING: Removing unreachable block (ram,0x00402f34)

void __fastcall fcn.004049c4(undefined4 param_1, int32_t param_2)
{
    int32_t *in_EAX;
    int32_t iVar1;
    int32_t iVar2;
    
    iVar1 = 0;
    if (0 < param_2) {
        iVar2 = *in_EAX;
        if (iVar2 != 0) {
            if (*(int16_t *)(iVar2 + -10) != 1) {
                iVar2 = 0;
                fcn.00404e94(0);
                iVar1 = *in_EAX;
                *in_EAX = iVar2;
            }
            if (*(int32_t *)(iVar2 + -8) == 1) {
                iVar2 = iVar2 + -0xc;
                if (SCARRY4(param_2, 0xd)) {
                    if (*(code **)0x413008 != (code *)0x0) {
                        (**(code **)0x413008)(param_2);
                    }
                    fcn.00402f08();
                    return;
                }
                fcn.00402e38();
                *in_EAX = iVar2 + 0xc;
                *(int32_t *)(iVar2 + 8) = param_2;
                *(undefined *)(param_2 + iVar2 + 0xc) = 0;
                if (iVar1 == 0) {
                    return;
                }
                fcn.004046c4(iVar1);
                return;
            }
        }
        iVar1 = fcn.00404774();
        if (*in_EAX != 0) {
            fcn.00402fbc();
        }
    }
    fcn.004046c4();
    *in_EAX = iVar1;
    return;
}


void fcn.00404808(void)
{
    int32_t unaff_retaddr;
    
    fcn.00404e94(unaff_retaddr);
    return;
}


void __fastcall fcn.00402e38(undefined4 param_1, int32_t param_2)
{
    char cVar1;
    int32_t *in_EAX;
    int32_t iVar2;
    
    if (*in_EAX == 0) {
        if (param_2 == 0) {
            return;
        }
        iVar2 = (**(code **)0x41273c)();
        if (iVar2 != 0) {
            *in_EAX = iVar2;
            return;
        }
    } else {
        if (param_2 == 0) {
            *in_EAX = 0;
            iVar2 = (**(code **)0x412740)();
            if (iVar2 == 0) {
                return;
            }
            cVar1 = '\x02';
            goto code_r0x00402f14;
        }
        iVar2 = (**(code **)0x412744)();
        if (iVar2 != 0) {
            *in_EAX = iVar2;
            return;
        }
    }
    cVar1 = '\x01';
code_r0x00402f14:
    if (*(code **)0x413008 != (code *)0x0) {
        (**(code **)0x413008)();
    }
    if (cVar1 == '\0') {
        fcn.00406588();
    }
    fcn.00402f08();
    return;
}


// WARNING: [r2ghidra] Failed to match type UINT for variable CodePage to Decompiler type: Unknown type identifier UINT

void __cdecl fcn.004047ec(undefined4 CodePage, int32_t arg_ch)
{
    sub.kernel32.dll_MultiByteToWideChar(CodePage, 0);
    return;
}


void __fastcall fcn.00404c2c(undefined4 param_1, int32_t param_2)
{
    uint32_t *in_EAX;
    uint32_t uVar1;
    
    if (0 < param_2) {
        fcn.00404a64(param_1);
        uVar1 = *in_EAX;
        if (uVar1 != 0) {
            uVar1 = *(uint32_t *)(uVar1 - 4) >> 1;
        }
        if (0 < (int32_t)uVar1) {
            fcn.00402fbc();
        }
    }
    fcn.00404a7c();
    return;
}


int32_t fcn.00404c1c(void)
{
    int32_t in_EAX;
    
    if (in_EAX != 0) {
        return in_EAX;
    }
    return 0x404c22;
}


// WARNING: [r2ghidra] Failed to match type UINT for variable CodePage to Decompiler type: Unknown type identifier UINT

void __thiscall fcn.00404af0(int32_t param_1, undefined4 param_2)
{
    int32_t iVar1;
    
    if (param_1 < 1) {
        fcn.00404a8c();
    } else {
        if ((param_1 + 1 < 0x7ff) && (iVar1 = fcn.004047ec(param_2, param_1), 0 < iVar1)) {
            fcn.00404b9c();
        } else {
            fcn.00404c2c();
            fcn.00404c1c();
            fcn.004047ec(param_2, param_1);
            fcn.00404c2c();
        }
    }
    return;
}


// WARNING: Removing unreachable block (ram,0x00402f34)

void fcn.00404a64(void)
{
    int32_t in_EAX;
    int32_t iVar1;
    
    if ((in_EAX != 0) && (iVar1 = sub.oleaut32.dll_SysAllocStringLen(0), iVar1 == 0)) {
        if (*(code **)0x413008 != (code *)0x0) {
            (**(code **)0x413008)();
        }
        fcn.00402f08();
        return;
    }
    return;
}


void __fastcall fcn.00404a7c(undefined4 param_1, int32_t param_2)
{
    int32_t iVar1;
    int32_t *in_EAX;
    
    iVar1 = *in_EAX;
    *in_EAX = param_2;
    if (iVar1 != 0) {
        sub.oleaut32.dll_SysFreeString(iVar1);
    }
    return;
}


// WARNING: Removing unreachable block (ram,0x00402f34)

undefined2 * fcn.004054b4(void)
{
    int32_t in_EAX;
    undefined2 *puVar1;
    
    if (in_EAX < 1) {
        return (undefined2 *)0x0;
    }
    if ((!SCARRY4(in_EAX, in_EAX)) && (!SCARRY4(in_EAX * 2, 0xe))) {
        puVar1 = (undefined2 *)fcn.00402e04();
        *(undefined4 *)(puVar1 + 2) = 1;
        *(int32_t *)(puVar1 + 4) = in_EAX;
        (puVar1 + 6)[in_EAX] = 0;
        puVar1[1] = 2;
        *puVar1 = *(undefined2 *)0x4138cc;
        return puVar1 + 6;
    }
    if (*(code **)0x413008 != (code *)0x0) {
        (**(code **)0x413008)();
    }
    puVar1 = (undefined2 *)fcn.00402f08();
    return puVar1;
}


void __fastcall fcn.00404dd4(undefined4 param_1, int32_t param_2)
{
    undefined4 *in_EAX;
    undefined4 uVar1;
    
    uVar1 = fcn.004054b4();
    if (param_2 != 0) {
        fcn.00402fbc();
    }
    fcn.004046c4();
    *in_EAX = uVar1;
    return;
}


// WARNING: Removing unreachable block (ram,0x00402f34)

void __fastcall fcn.00404f00(undefined4 param_1, int32_t param_2)
{
    int32_t *in_EAX;
    int32_t iVar1;
    int32_t iVar2;
    
    iVar1 = 0;
    if (0 < param_2) {
        iVar2 = *in_EAX;
        if (iVar2 != 0) {
            if (*(int16_t *)(iVar2 + -10) != 2) {
                iVar2 = 0;
                fcn.00404e6c();
                iVar1 = *in_EAX;
                *in_EAX = iVar2;
            }
            if (*(int32_t *)(iVar2 + -8) == 1) {
                iVar2 = iVar2 + -0xc;
                if ((!SCARRY4(param_2, param_2)) && (!SCARRY4(param_2 * 2, 0xe))) {
                    fcn.00402e38();
                    *in_EAX = iVar2 + 0xc;
                    *(int32_t *)(iVar2 + 8) = param_2;
                    *(undefined2 *)(iVar2 + 0xc + param_2 * 2) = 0;
                    if (iVar1 == 0) {
                        return;
                    }
                    fcn.004046c4(iVar1);
                    return;
                }
                if (*(code **)0x413008 != (code *)0x0) {
                    (**(code **)0x413008)(param_2);
                }
                fcn.00402f08();
                return;
            }
        }
        iVar1 = fcn.004054b4();
        if (*in_EAX != 0) {
            fcn.00402fbc();
        }
    }
    fcn.004046c4();
    *in_EAX = iVar1;
    return;
}


int32_t fcn.00404830(void)
{
    int32_t *in_EAX;
    int32_t iVar1;
    
    iVar1 = *in_EAX;
    if ((iVar1 != 0) && (*(int16_t *)(iVar1 + -10) != 2)) {
        iVar1 = fcn.00404820();
    }
    return iVar1;
}


void fcn.00404c80(void)
{
    int32_t iVar1;
    int32_t in_EAX;
    
    if ((in_EAX != 0) && (iVar1 = *(int32_t *)(in_EAX + -8), iVar1 != -1 && SCARRY4(iVar1, 1) == iVar1 + 1 < 0)) {
        LOCK();
        *(int32_t *)(in_EAX + -8) = *(int32_t *)(in_EAX + -8) + 1;
    }
    return;
}


void __fastcall fcn.004046e8(undefined4 param_1, int32_t param_2)
{
    int32_t *piVar1;
    int32_t iVar2;
    int32_t *in_EAX;
    
    do {
        iVar2 = *in_EAX;
        if ((iVar2 != 0) && (*in_EAX = 0, 0 < *(int32_t *)(iVar2 + -8))) {
            LOCK();
            piVar1 = (int32_t *)(iVar2 + -8);
            *piVar1 = *piVar1 + -1;
            if (*piVar1 == 0) {
                fcn.00402e20();
            }
        }
        in_EAX = in_EAX + 1;
        param_2 = param_2 + -1;
    } while (param_2 != 0);
    return;
}


void fcn.00404dc4(void)
{
    func_0x00404d30(*(undefined4 *)0x4138c8);
    return;
}


void fcn.00404818(void)
{
    fcn.00404e6c();
    return;
}


// WARNING: Removing unreachable block (ram,0x00402f34)

void __fastcall fcn.00404b9c(int32_t param_1, int32_t *param_2)
{
    int32_t iVar1;
    int32_t *in_EAX;
    int32_t iVar2;
    
    if (param_1 == 0) {
        iVar2 = *in_EAX;
        if (iVar2 != 0) {
            *in_EAX = 0;
            sub.oleaut32.dll_SysFreeString(iVar2);
        }
        return;
    }
    iVar2 = sub.oleaut32.dll_SysAllocStringLen(param_2, param_1);
    if (iVar2 == 0) {
        if (*(code **)0x413008 != (code *)0x0) {
            (**(code **)0x413008)();
        }
        fcn.00402f08();
        return;
    }
    iVar1 = *param_2;
    *param_2 = iVar2;
    sub.oleaut32.dll_SysFreeString(iVar1);
    return;
}


void __fastcall fcn.00404aa4(undefined4 param_1, int32_t param_2)
{
    int32_t iVar1;
    int32_t *in_EAX;
    
    do {
        iVar1 = *in_EAX;
        if (iVar1 != 0) {
            *in_EAX = 0;
            sub.oleaut32.dll_SysFreeString(iVar1);
        }
        in_EAX = in_EAX + 1;
        param_2 = param_2 + -1;
    } while (param_2 != 0);
    return;
}


void fcn.00405530(void)
{
    if (*(code **)0x412010 != (code *)0x0) {
        (**(code **)0x412010)();
        return;
    }
    fcn.00402f60();
    return;
}


void fcn.00406274(void)
{
    int32_t *piVar1;
    int32_t **in_EAX;
    
    piVar1 = *in_EAX;
    if (piVar1 != (int32_t *)0x0) {
        *in_EAX = (int32_t *)0x0;
        (**(code **)(*piVar1 + 8))(piVar1);
    }
    return;
}


void __fastcall fcn.00405ae4(undefined4 param_1, int32_t param_2)
{
    int32_t *piVar1;
    int32_t iVar2;
    int32_t *in_EAX;
    
    iVar2 = *in_EAX;
    if (iVar2 != 0) {
        *in_EAX = 0;
        LOCK();
        piVar1 = (int32_t *)(iVar2 + -8);
        *piVar1 = *piVar1 + -1;
        if (*piVar1 == 0) {
            if ((*(int32_t *)(*(uint8_t *)(param_2 + 1) + 6 + param_2) != 0) && (*(int32_t *)(iVar2 + -4) != 0)) {
                fcn.00405548();
            }
            fcn.00402e20();
        }
    }
    return;
}


void __fastcall fcn.00404718(undefined4 param_1, int32_t param_2)
{
    int32_t *piVar1;
    int32_t *in_EAX;
    int32_t iVar2;
    int32_t iVar3;
    uint32_t uVar4;
    
    do {
        if (param_2 == 0) {
code_r0x00404756:
            iVar3 = *in_EAX;
            *in_EAX = param_2;
            if ((iVar3 != 0) && (0 < *(int32_t *)(iVar3 + -8))) {
                LOCK();
                piVar1 = (int32_t *)(iVar3 + -8);
                *piVar1 = *piVar1 + -1;
                if (*piVar1 == 0) {
                    fcn.00402e20();
                }
            }
            return;
        }
        if (*(int16_t *)(param_2 + -10) == 1) {
            iVar3 = *(int32_t *)(param_2 + -8);
            if (iVar3 == -1 || SCARRY4(iVar3, 1) != iVar3 + 1 < 0) {
                param_2 = fcn.00404774(param_2);
                fcn.00402fbc();
            } else {
                LOCK();
                *(int32_t *)(param_2 + -8) = *(int32_t *)(param_2 + -8) + 1;
            }
            goto code_r0x00404756;
        }
        iVar3 = 0;
        if (param_2 == 0) goto code_r0x00404ea8;
    } while (*(int16_t *)(param_2 + -10) == 1);
    iVar3 = *(int32_t *)(param_2 + -4);
code_r0x00404ea8:
    if (iVar3 < 1) {
        fcn.004046c4();
    } else {
        uVar4 = *(uint32_t *)0x4138c8;
        if ((int16_t)*(uint32_t *)0x4138c8 == 0) {
            uVar4 = *(uint32_t *)0x4138c8 & 0xffff;
        }
        iVar2 = fcn.004047c0(uVar4 & 0xffff, iVar3);
        fcn.004049c4();
        if (iVar2 < 1) {
            fcn.004046c4();
        } else {
            fcn.004047c0(uVar4 & 0xffff, iVar3);
            *(int16_t *)(*in_EAX + -0xc) = (int16_t)uVar4;
        }
    }
    return;
}


// WARNING: Removing unreachable block (ram,0x00402f34)

void __fastcall fcn.00404ac8(undefined4 param_1, int32_t param_2)
{
    int32_t *in_EAX;
    int32_t iVar1;
    
    if (*in_EAX != param_2) {
        if ((param_2 == 0) || (*(uint32_t *)(param_2 + -4) >> 1 == 0)) {
            iVar1 = *in_EAX;
            if (iVar1 != 0) {
                *in_EAX = 0;
                sub.oleaut32.dll_SysFreeString(iVar1);
            }
            return;
        }
        iVar1 = sub.oleaut32.dll_SysReAllocStringLen();
        if (iVar1 == 0) {
            if (*(code **)0x413008 != (code *)0x0) {
                (**(code **)0x413008)();
            }
            fcn.00402f08();
            return;
        }
    }
    return;
}


void fcn.00405664(void)
{
    if (*(code **)0x412014 != (code *)0x0) {
        (**(code **)0x412014)();
        return;
    }
    fcn.00402f60();
    return;
}


// WARNING: Removing unreachable block (ram,0x00402f34)
// WARNING: [r2ghidra] Var arg_14h is stack pointer based, which is not supported for decompilation.

void __thiscall fcn.004057bc(char *param_1, int32_t param_2)
{
    char cVar1;
    int32_t unaff_EBP;
    
    cVar1 = *param_1;
    if (cVar1 == '\n') {
        do {
            fcn.00404718();
            param_2 = param_2 + -1;
        } while (param_2 != 0);
    } else {
        if (cVar1 == '\v') {
            do {
                fcn.00404ac8();
                param_2 = param_2 + -1;
            } while (param_2 != 0);
        } else {
            if (cVar1 == '\x12') {
                do {
                    fcn.00404c98(unaff_EBP);
                    param_2 = param_2 + -1;
                } while (param_2 != 0);
            } else {
                if (cVar1 == '\f') {
                    do {
                        fcn.00405664();
                        param_2 = param_2 + -1;
                    } while (param_2 != 0);
                } else {
                    if (cVar1 == '\r') {
                        do {
                            fcn.004057bc();
                            param_2 = param_2 + -1;
                        } while (param_2 != 0);
                    } else {
                        if (cVar1 == '\x0e') {
                            do {
                                fcn.0040567c();
                                param_2 = param_2 + -1;
                            } while (param_2 != 0);
                        } else {
                            if (cVar1 == '\x0f') {
                                do {
                                    fcn.0040628c();
                                    param_2 = param_2 + -1;
                                } while (param_2 != 0);
                            } else {
                                if (cVar1 != '\x11') {
                                    if (*(code **)0x413008 != (code *)0x0) {
                                        (**(code **)0x413008)();
                                    }
                                    fcn.00402f08();
                                    return;
                                }
                                do {
                                    fcn.00405b20();
                                    param_2 = param_2 + -1;
                                } while (param_2 != 0);
                            }
                        }
                    }
                }
            }
        }
    }
    return;
}


// WARNING: Removing unreachable block (ram,0x00402f34)
// WARNING: [r2ghidra] Var arg_14h is stack pointer based, which is not supported for decompilation.

void __fastcall fcn.0040567c(int32_t param_1)
{
    char cVar1;
    char *pcVar2;
    int32_t iVar3;
    char *pcVar4;
    undefined4 unaff_ESI;
    undefined4 unaff_EDI;
    char **ppcVar5;
    char *arg_8h;
    
    ppcVar5 = (char **)(*(uint8_t *)(param_1 + 1) + 10 + param_1);
    pcVar4 = ppcVar5[-1];
    pcVar2 = (char *)0x0;
    arg_8h = ppcVar5[-2];
    do {
        if (pcVar4 == (char *)0x0) {
            if ((int32_t)pcVar2 < (int32_t)arg_8h) {
                fcn.00402fbc();
            }
            return;
        }
        if ((int32_t)pcVar2 < (int32_t)ppcVar5[1]) {
            fcn.00402fbc();
        }
        pcVar2 = *(char **)*ppcVar5;
        cVar1 = *pcVar2;
        if (cVar1 == '\n') {
            fcn.00404718();
            iVar3 = 4;
        } else {
            if (cVar1 == '\v') {
                fcn.00404ac8();
                iVar3 = 4;
            } else {
                if (cVar1 == '\x12') {
                    fcn.00404c98((int32_t)arg_8h);
                    iVar3 = 4;
                } else {
                    if (cVar1 == '\f') {
                        fcn.00405664();
                        iVar3 = 0x10;
                    } else {
                        if (cVar1 == '\r') {
                            iVar3 = *(int32_t *)(pcVar2 + (uint8_t)pcVar2[1] + 6);
                            fcn.004057bc(iVar3, *(undefined4 *)(pcVar2 + (uint8_t)pcVar2[1] + 2));
                        } else {
                            if (cVar1 == '\x0e') {
                                iVar3 = *(int32_t *)(pcVar2 + (uint8_t)pcVar2[1] + 2);
                                fcn.0040567c();
                            } else {
                                if (cVar1 == '\x0f') {
                                    fcn.0040628c();
                                    iVar3 = 4;
                                } else {
                                    if (cVar1 != '\x11') {
                                        if (*(code **)0x413008 != (code *)0x0) {
                                            (**(code **)0x413008)(unaff_EDI, unaff_ESI);
                                        }
                                        fcn.00402f08();
                                        return;
                                    }
                                    fcn.00405b20();
                                    iVar3 = 4;
                                }
                            }
                        }
                    }
                }
            }
        }
        pcVar2 = ppcVar5[1] + iVar3;
        ppcVar5 = ppcVar5 + 2;
        pcVar4 = pcVar4 + -1;
    } while( true );
}


void __fastcall fcn.0040628c(undefined4 param_1, int32_t **param_2)
{
    int32_t *piVar1;
    int32_t **in_EAX;
    int32_t **ppiVar2;
    
    if (param_2 == (int32_t **)0x0) {
        piVar1 = *in_EAX;
        *in_EAX = (int32_t *)0x0;
        if (piVar1 != (int32_t *)0x0) {
            (**(code **)(*piVar1 + 8))(piVar1);
        }
        return;
    }
    ppiVar2 = param_2;
    (*(code *)(*param_2)[1])();
    piVar1 = *param_2;
    *param_2 = (int32_t *)in_EAX;
    if (piVar1 == (int32_t *)0x0) {
        return;
    }
    (**(code **)(*piVar1 + 8))(piVar1, ppiVar2);
    return;
}


void __fastcall fcn.00405b20(undefined4 param_1, int32_t param_2)
{
    int32_t *piVar1;
    int32_t iVar2;
    int32_t *in_EAX;
    
    iVar2 = *in_EAX;
    if (param_2 != 0) {
        LOCK();
        *(int32_t *)(param_2 + -8) = *(int32_t *)(param_2 + -8) + 1;
    }
    if (iVar2 != 0) {
        LOCK();
        piVar1 = (int32_t *)(iVar2 + -8);
        *piVar1 = *piVar1 + -1;
        if (*piVar1 == 0) {
            *(int32_t *)(iVar2 + -8) = *(int32_t *)(iVar2 + -8) + 1;
            fcn.00405ae4();
        }
    }
    *in_EAX = param_2;
    return;
}


// WARNING: Removing unreachable block (ram,0x00402f34)
// WARNING: Removing unreachable block (ram,0x004055db)
// WARNING: Removing unreachable block (ram,0x004055c1)
// WARNING: Removing unreachable block (ram,0x004055a4)

void __fastcall fcn.00405658(undefined4 param_1, char *param_2)
{
    char cVar1;
    bool bVar2;
    int32_t iVar3;
    int32_t iVar4;
    
    iVar3 = 1;
    cVar1 = *param_2;
    if (cVar1 == '\n') {
        fcn.004046c4();
    } else {
        if (cVar1 == '\x12') {
            fcn.00404c88();
        } else {
            if (cVar1 == '\v') {
                fcn.00404a8c();
            } else {
                if (cVar1 == '\f') {
                    do {
                        fcn.00405530();
                        iVar4 = iVar3 + -1;
                        bVar2 = 0 < iVar3;
                        iVar3 = iVar4;
                    } while (iVar4 != 0 && bVar2);
                } else {
                    if (cVar1 == '\r') {
                        do {
                            fcn.00405548();
                            iVar4 = iVar3 + -1;
                            bVar2 = 0 < iVar3;
                            iVar3 = iVar4;
                        } while (iVar4 != 0 && bVar2);
                    } else {
                        if (cVar1 == '\x0e') {
                            do {
                                fcn.004054f8();
                                iVar4 = iVar3 + -1;
                                bVar2 = 0 < iVar3;
                                iVar3 = iVar4;
                            } while (iVar4 != 0 && bVar2);
                        } else {
                            if (cVar1 == '\x0f') {
                                do {
                                    fcn.00406274();
                                    iVar4 = iVar3 + -1;
                                    bVar2 = 0 < iVar3;
                                    iVar3 = iVar4;
                                } while (iVar4 != 0 && bVar2);
                            } else {
                                if (cVar1 != '\x11') {
                                    if (*(code **)0x413008 != (code *)0x0) {
                                        (**(code **)0x413008)();
                                    }
                                    fcn.00402f08();
                                    return;
                                }
                                do {
                                    fcn.00405ae4();
                                    iVar4 = iVar3 + -1;
                                    bVar2 = 0 < iVar3;
                                    iVar3 = iVar4;
                                } while (iVar4 != 0 && bVar2);
                            }
                        }
                    }
                }
            }
        }
    }
    return;
}


void fcn.00405910(void)
{
    return;
}


void fcn.00405938(void)
{
    fcn.00405ae4();
    return;
}


// WARNING: Removing unreachable block (ram,0x00402f34)

void __fastcall fcn.00405930(int32_t param_1, char *param_2)
{
    char cVar1;
    bool bVar2;
    int32_t iVar3;
    
    if (param_1 != 0) {
        cVar1 = *param_2;
        if (cVar1 == '\n') {
            if (param_1 < 2) {
                fcn.004046c4();
            } else {
                fcn.004046e8();
            }
        } else {
            if (cVar1 == '\x12') {
                if (param_1 < 2) {
                    fcn.00404c88();
                } else {
                    fcn.00404c90();
                }
            } else {
                if (cVar1 == '\v') {
                    if (param_1 < 2) {
                        fcn.00404a8c();
                    } else {
                        fcn.00404aa4();
                    }
                } else {
                    if (cVar1 == '\f') {
                        do {
                            fcn.00405530();
                            iVar3 = param_1 + -1;
                            bVar2 = 0 < param_1;
                            param_1 = iVar3;
                        } while (iVar3 != 0 && bVar2);
                    } else {
                        if (cVar1 == '\r') {
                            do {
                                fcn.00405548();
                                iVar3 = param_1 + -1;
                                bVar2 = 0 < param_1;
                                param_1 = iVar3;
                            } while (iVar3 != 0 && bVar2);
                        } else {
                            if (cVar1 == '\x0e') {
                                do {
                                    fcn.004054f8();
                                    iVar3 = param_1 + -1;
                                    bVar2 = 0 < param_1;
                                    param_1 = iVar3;
                                } while (iVar3 != 0 && bVar2);
                            } else {
                                if (cVar1 == '\x0f') {
                                    do {
                                        fcn.00406274();
                                        iVar3 = param_1 + -1;
                                        bVar2 = 0 < param_1;
                                        param_1 = iVar3;
                                    } while (iVar3 != 0 && bVar2);
                                } else {
                                    if (cVar1 != '\x11') {
                                        if (*(code **)0x413008 != (code *)0x0) {
                                            (**(code **)0x413008)();
                                        }
                                        fcn.00402f08();
                                        return;
                                    }
                                    do {
                                        fcn.00405ae4();
                                        iVar3 = param_1 + -1;
                                        bVar2 = 0 < param_1;
                                        param_1 = iVar3;
                                    } while (iVar3 != 0 && bVar2);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return;
}


// WARNING: [r2ghidra] Failed to match type signed int for variable arg_8h to Decompiler type: Unknown type identifier
// signed
// WARNING: [r2ghidra] Var arg_14h is stack pointer based, which is not supported for decompilation.

void __cdecl fcn.00405920(undefined4 arg_8h)
{
    fcn.004057bc(arg_8h);
    return;
}


// WARNING: [r2ghidra] Failed to match type signed int for variable var_8h to Decompiler type: Unknown type identifier
// signed
// WARNING: [r2ghidra] Failed to match type signed int for variable var_10h to Decompiler type: Unknown type identifier
// signed
// WARNING: [r2ghidra] Failed to match type signed int for variable var_18h to Decompiler type: Unknown type identifier
// signed
// WARNING: [r2ghidra] Failed to match type signed int for variable var_1ch to Decompiler type: Unknown type identifier
// signed
// WARNING: [r2ghidra] Failed to match type signed int for variable var_14h to Decompiler type: Unknown type identifier
// signed
// WARNING: [r2ghidra] Failed to match type signed int for variable arg_8h to Decompiler type: Unknown type identifier
// signed

void __cdecl fcn.00405940(int32_t arg_8h)
{
    int32_t iVar1;
    int32_t *piVar2;
    int32_t **in_EAX;
    int32_t iVar3;
    int32_t *piVar4;
    int32_t in_ECX;
    int32_t in_EDX;
    int32_t iVar5;
    int32_t iVar6;
    int32_t var_20h;
    undefined4 var_1ch;
    undefined4 var_18h;
    int32_t var_14h;
    int32_t var_10h;
    int32_t var_ch;
    undefined4 var_8h;
    int32_t var_4h;
    
    piVar4 = *in_EAX;
    iVar6 = *(int32_t *)arg_8h;
    if (iVar6 < 1) {
        if (iVar6 < 0) {
            fcn.00402f60();
        }
        fcn.00405938();
    } else {
        var_10h = 0;
        if (piVar4 != (int32_t *)0x0) {
            var_10h = piVar4[-1];
            piVar4 = piVar4 + -2;
        }
        iVar5 = in_EDX + (uint32_t)*(uint8_t *)(in_EDX + 1);
        iVar1 = *(int32_t *)(iVar5 + 2);
        piVar2 = *(int32_t **)(iVar5 + 6);
        if (piVar2 == (int32_t *)0x0) {
            iVar5 = 0;
        } else {
            iVar5 = *piVar2;
        }
        iVar3 = iVar6 * iVar1;
        if (iVar3 / iVar6 != iVar1) {
            fcn.00402f60();
        }
        if (iVar3 + 8 < 0) {
            fcn.00402f60();
        }
        if ((piVar4 == (int32_t *)0x0) || (*piVar4 == 1)) {
            if ((iVar6 < var_10h) && (iVar5 != 0)) {
                fcn.00405930();
            }
            fcn.00402e38();
        } else {
            *piVar4 = *piVar4 + -1;
            piVar4 = (int32_t *)fcn.00402e04();
            var_14h = var_10h;
            if (iVar6 < var_10h) {
                var_14h = iVar6;
            }
            if (iVar5 == 0) {
                fcn.00402fbc();
            } else {
                fcn.00403250();
                fcn.00405920(var_14h);
            }
        }
        *piVar4 = 1;
        piVar4[1] = iVar6;
        fcn.00403250();
        if ((1 < in_ECX) && (-1 < iVar6 + -1)) {
            do {
                fcn.00405940(arg_8h + 4);
                iVar6 = iVar6 + -1;
            } while (iVar6 != 0);
        }
        *in_EAX = piVar4 + 2;
    }
    return;
}


// WARNING: Could not reconcile some variable overlaps
// WARNING: [r2ghidra] Failed to match type LPCWSTR for variable lpString2 to Decompiler type: Unknown type identifier
// LPCWSTR
// WARNING: [r2ghidra] Failed to match type LPCWSTR for variable lpLibFileName to Decompiler type: Unknown type
// identifier LPCWSTR
// WARNING: [r2ghidra] Failed to match type LPCWSTR for variable var_1ch to Decompiler type: Unknown type identifier
// LPCWSTR
// WARNING: [r2ghidra] Failed to match type HKEY for variable hKey to Decompiler type: Unknown type identifier HKEY
// WARNING: [r2ghidra] Failed to match type LPCWSTR for variable var_12h to Decompiler type: Unknown type identifier
// LPCWSTR
// WARNING: [r2ghidra] Failed to match type LPWSTR for variable lpString1 to Decompiler type: Unknown type identifier
// LPWSTR
// WARNING: [r2ghidra] Failed to match type HMODULE for variable hFindFile to Decompiler type: Unknown type identifier
// HMODULE
// WARNING: [r2ghidra] Failed to match type LPCWSTR for variable lpFileName to Decompiler type: Unknown type identifier
// LPCWSTR
// WARNING: [r2ghidra] Failed to match type LPWIN32_FIND_DATAW for variable lpFindFileData to Decompiler type: Unknown
// type identifier LPWIN32_FIND_DATAW

int32_t fcn.00405de8(void)
{
    undefined4 placeholder_0;
    int32_t iVar1;
    int16_t *piVar2;
    undefined4 *in_FS_OFFSET;
    undefined4 in_stack_fffffd30;
    undefined4 in_stack_fffffd6c;
    undefined4 in_stack_fffffd70;
    undefined4 in_stack_fffffd74;
    undefined4 in_stack_fffffd78;
    undefined4 *in_stack_fffffd7c;
    undefined4 in_stack_fffffd80;
    undefined4 in_stack_fffffd84;
    undefined4 in_stack_fffffd88;
    undefined4 in_stack_fffffd8c;
    undefined4 *in_stack_fffffd90;
    undefined4 in_stack_fffffd94;
    undefined4 in_stack_fffffd98;
    undefined4 in_stack_fffffd9c;
    undefined4 in_stack_fffffda0;
    undefined4 *puVar3;
    undefined4 uVar4;
    undefined4 placeholder_19;
    undefined4 placeholder_20;
    int32_t iVar5;
    undefined4 *puStack584;
    undefined4 uStack580;
    undefined4 *puStack576;
    undefined4 uStack572;
    undefined4 lpLibFileName;
    int32_t var_20h;
    undefined4 var_1ch;
    undefined4 var_12h;
    int32_t var_eh;
    undefined4 hKey;
    undefined4 lpString2;
    
    uStack572 = 0x105;
    puStack576 = &lpLibFileName;
    uStack580 = 0;
    puStack584 = (undefined4 *)0x405e09;
    sub.kernel32.dll_GetModuleFileNameW();
    var_1ch._0_2_ = 0;
    puStack584 = &hKey;
    iVar5 = 0xf0019;
    placeholder_20 = 0;
    placeholder_19 = 0x406068;
    uVar4 = 0x80000001;
    puVar3 = (undefined4 *)0x405e29;
    iVar1 = sub.advapi32.dll_RegOpenKeyExW();
    if (iVar1 != 0) {
        puVar3 = &hKey;
        in_stack_fffffda0 = 0xf0019;
        in_stack_fffffd9c = 0;
        in_stack_fffffd98 = 0x406068;
        in_stack_fffffd94 = 0x80000002;
        in_stack_fffffd90 = (undefined4 *)0x405e47;
        iVar1 = sub.advapi32.dll_RegOpenKeyExW();
        if (iVar1 != 0) {
            in_stack_fffffd90 = &hKey;
            in_stack_fffffd8c = 0xf0019;
            in_stack_fffffd88 = 0;
            in_stack_fffffd84 = 0x40609c;
            in_stack_fffffd80 = 0x80000001;
            in_stack_fffffd7c = (undefined4 *)0x405e65;
            iVar1 = sub.advapi32.dll_RegOpenKeyExW();
            if (iVar1 != 0) {
                in_stack_fffffd7c = &hKey;
                in_stack_fffffd78 = 0xf0019;
                in_stack_fffffd74 = 0;
                in_stack_fffffd70 = 0x4060d0;
                in_stack_fffffd6c = 0x80000001;
                iVar1 = sub.advapi32.dll_RegOpenKeyExW();
                if (iVar1 != 0) {
                    sub.kernel32.dll_lstrcpynW();
                    uVar4 = sub.kernel32.dll_GetThreadLocale(3, &var_12h, 5);
                    sub.kernel32.dll_GetLocaleInfoW(uVar4);
                    iVar1 = 0;
                    if (((int16_t)lpLibFileName != 0) && (((int16_t)var_12h != 0 || ((int16_t)var_1ch != 0)))) {
                        iVar5 = sub.kernel32.dll_lstrlenW(&lpLibFileName);
                        puVar3 = (undefined4 *)((int32_t)&lpLibFileName + iVar5 * 2);
                        while ((*(int16_t *)puVar3 != 0x2e && (puVar3 != &lpLibFileName))) {
                            puVar3 = (undefined4 *)((int32_t)puVar3 + -2);
                        }
                        if (puVar3 != &lpLibFileName) {
                            piVar2 = (int16_t *)((int32_t)puVar3 + 2);
                            if ((int16_t)var_1ch != 0) {
                                sub.kernel32.dll_lstrcpynW
                                          (piVar2, &var_1ch, 
                                           0x105 - ((int32_t)((int32_t)piVar2 - (int32_t)&lpLibFileName) >> 1));
                                iVar1 = sub.kernel32.dll_LoadLibraryExW(&lpLibFileName, 0, 2);
                            }
                            if ((iVar1 == 0) && ((int16_t)var_12h != 0)) {
                                sub.kernel32.dll_lstrcpynW
                                          (piVar2, &var_12h, 
                                           0x105 - ((int32_t)((int32_t)piVar2 - (int32_t)&lpLibFileName) >> 1));
                                iVar1 = sub.kernel32.dll_LoadLibraryExW(&lpLibFileName, 0, 2);
                                if (iVar1 == 0) {
                                    sub.kernel32.dll_lstrcpynW
                                              (piVar2, &var_12h, 
                                               0x105 - ((int32_t)((int32_t)piVar2 - (int32_t)&lpLibFileName) >> 1));
                                    iVar1 = sub.kernel32.dll_LoadLibraryExW(&lpLibFileName, 0, 2);
                                }
                            }
                        }
                    }
                    return iVar1;
                }
            }
        }
    }
    placeholder_0 = *in_FS_OFFSET;
    *in_FS_OFFSET = &stack0xfffffd60;
    var_20h = 10;
    fcn.00405bec(placeholder_0, 0x405f1c, &stack0xfffffffc, in_stack_fffffd6c, in_stack_fffffd70, in_stack_fffffd74, 
                 in_stack_fffffd78, in_stack_fffffd7c, in_stack_fffffd80, in_stack_fffffd84, in_stack_fffffd88, 
                 in_stack_fffffd8c, in_stack_fffffd90, in_stack_fffffd94, in_stack_fffffd98, in_stack_fffffd9c, 
                 in_stack_fffffda0, puVar3, uVar4, placeholder_19, placeholder_20, iVar5);
    iVar1 = sub.advapi32.dll_RegQueryValueExW(hKey, &lpLibFileName, 0, 0, &var_1ch, &var_20h);
    if ((iVar1 != 0) &&
       (in_stack_fffffd30 = hKey, iVar1 = sub.advapi32.dll_RegQueryValueExW(hKey, 0x406110, 0, 0, &var_1ch, &var_20h),
       iVar1 != 0)) {
        var_1ch._0_2_ = 0;
    }
    iVar1 = var_20h >> 1;
    if (iVar1 < 0) {
        iVar1 = iVar1 + (uint32_t)((var_20h & 1U) != 0);
    }
    *(undefined2 *)((int32_t)&var_1ch + iVar1 * 2) = 0;
    *in_FS_OFFSET = in_stack_fffffd30;
    iVar1 = sub.advapi32.dll_RegCloseKey(hKey, 0x405f23);
    return iVar1;
}


// WARNING: [r2ghidra] Failed to match type LPWSTR * for variable lpFilename to Decompiler type: Unknown type identifier
// LPWSTR
// WARNING: [r2ghidra] Failed to match type LPCWSTR for variable lpString2 to Decompiler type: Unknown type identifier
// LPCWSTR
// WARNING: [r2ghidra] Failed to match type LPCWSTR for variable lpLibFileName to Decompiler type: Unknown type
// identifier LPCWSTR
// WARNING: [r2ghidra] Failed to match type LPCWSTR for variable var_1ch to Decompiler type: Unknown type identifier
// LPCWSTR
// WARNING: [r2ghidra] Failed to match type HKEY for variable hKey to Decompiler type: Unknown type identifier HKEY
// WARNING: [r2ghidra] Failed to match type LPCWSTR for variable var_12h to Decompiler type: Unknown type identifier
// LPCWSTR

undefined4 fcn.00405b48(void)
{
    int32_t in_EAX;
    int32_t iVar1;
    undefined auStack532 [524];
    
    if (*(int32_t *)(in_EAX + 0x10) == 0) {
        sub.kernel32.dll_GetModuleFileNameW(*(undefined4 *)(in_EAX + 4), auStack532, 0x20a);
        iVar1 = fcn.00405de8();
        *(int32_t *)(in_EAX + 0x10) = iVar1;
        if (iVar1 == 0) {
            *(undefined4 *)(in_EAX + 0x10) = *(undefined4 *)(in_EAX + 4);
        }
    }
    return *(undefined4 *)(in_EAX + 0x10);
}


int16_t * fcn.00405bc8(void)
{
    int16_t *in_EAX;
    
    while ((*in_EAX != 0 && (*in_EAX != 0x5c))) {
        in_EAX = (int16_t *)sub.user32.dll_CharNextW();
    }
    return in_EAX;
}


// WARNING: [r2ghidra] Failed to match type LPWSTR for variable lpString1 to Decompiler type: Unknown type identifier
// LPWSTR
// WARNING: [r2ghidra] Failed to match type HMODULE for variable hFindFile to Decompiler type: Unknown type identifier
// HMODULE
// WARNING: [r2ghidra] Failed to match type LPCWSTR for variable lpFileName to Decompiler type: Unknown type identifier
// LPCWSTR
// WARNING: [r2ghidra] Failed to match type LPWIN32_FIND_DATAW for variable lpFindFileData to Decompiler type: Unknown
// type identifier LPWIN32_FIND_DATAW
// WARNING: [r2ghidra] Failed to match type LPCWSTR for variable lpString2 to Decompiler type: Unknown type identifier
// LPCWSTR

int16_t * __cdecl
fcn.00405bec(undefined4 placeholder_0, undefined4 placeholder_1, undefined4 placeholder_2, undefined4 placeholder_3,
            undefined4 placeholder_4, undefined4 placeholder_5, undefined4 placeholder_6, undefined4 placeholder_7,
            undefined4 placeholder_8, undefined4 placeholder_9, undefined4 placeholder_10, undefined4 placeholder_11,
            undefined4 placeholder_12, undefined4 placeholder_13, undefined4 placeholder_14, undefined4 placeholder_15,
            undefined4 placeholder_16, undefined4 placeholder_17, undefined4 placeholder_18, undefined4 placeholder_19,
            undefined4 placeholder_20, int32_t arg_5ch)
{
    int16_t *in_EAX;
    int32_t iVar1;
    code *pcVar2;
    int16_t *piVar3;
    int16_t *piVar4;
    int32_t iVar5;
    int32_t in_EDX;
    undefined4 *puVar6;
    undefined4 lpFileName;
    undefined4 lpFindFileData;
    undefined4 lpString2;
    undefined4 hFindFile;
    int32_t var_ch;
    int32_t iMaxLength;
    int16_t *lpString1;
    
    iVar1 = sub.kernel32.dll_GetModuleHandleW(0x405db8);
    var_ch = (int32_t)in_EAX;
    if (((iVar1 == 0) || (pcVar2 = (code *)sub.kernel32.dll_GetProcAddress(iVar1, 0x405dd4), pcVar2 == (code *)0x0)) ||
       (iVar1 = (*pcVar2)(in_EAX, &lpFileName, 0x105), iVar1 == 0)) {
        if (*in_EAX == 0x5c) {
            if (in_EAX[1] != 0x5c) {
                return in_EAX;
            }
            piVar3 = (int16_t *)fcn.00405bc8();
            if (*piVar3 == 0) {
                return in_EAX;
            }
            piVar3 = (int16_t *)fcn.00405bc8();
            if (*piVar3 == 0) {
                return in_EAX;
            }
        } else {
            piVar3 = in_EAX + 2;
        }
        iVar1 = (int32_t)(int16_t *)((int32_t)piVar3 - (int32_t)in_EAX) >> 1;
        if (iVar1 < 0) {
            iVar1 = iVar1 + (uint32_t)(((uint32_t)(int16_t *)((int32_t)piVar3 - (int32_t)in_EAX) & 1) != 0);
        }
        puVar6 = &lpFileName;
        sub.kernel32.dll_lstrcpynW(puVar6, in_EAX, iVar1 + 1);
        iMaxLength = in_EDX;
        lpString1 = in_EAX;
        while (*piVar3 != 0) {
            piVar4 = (int16_t *)fcn.00405bc8(puVar6);
            iVar5 = (int32_t)(int16_t *)((int32_t)piVar4 - (int32_t)piVar3) >> 1;
            if (iVar5 < 0) {
                iVar5 = iVar5 + (uint32_t)(((uint32_t)(int16_t *)((int32_t)piVar4 - (int32_t)piVar3) & 1) != 0);
            }
            if (0x105 < iVar5 + iVar1 + 1) {
                return (int16_t *)var_ch;
            }
            iVar5 = (int32_t)(int16_t *)((int32_t)piVar4 - (int32_t)piVar3) >> 1;
            if (iVar5 < 0) {
                iVar5 = iVar5 + (uint32_t)(((uint32_t)(int16_t *)((int32_t)piVar4 - (int32_t)piVar3) & 1) != 0);
            }
            sub.kernel32.dll_lstrcpynW((undefined4 *)((int32_t)&lpFileName + iVar1 * 2), piVar3, iVar5 + 1);
            iVar5 = sub.kernel32.dll_FindFirstFileW(&lpFileName, &lpFindFileData);
            if (iVar5 == -1) {
                return (int16_t *)var_ch;
            }
            sub.kernel32.dll_FindClose(iVar5);
            iVar5 = sub.kernel32.dll_lstrlenW(&lpString2);
            if (0x105 < iVar5 + iVar1 + 2) {
                return (int16_t *)var_ch;
            }
            *(undefined2 *)((int32_t)&lpFileName + iVar1 * 2) = 0x5c;
            sub.kernel32.dll_lstrcpynW((int32_t)&lpFileName + iVar1 * 2 + 2, &lpString2, 0x104 - iVar1);
            puVar6 = &lpString2;
            iVar5 = sub.kernel32.dll_lstrlenW();
            iVar1 = iVar1 + iVar5 + 1;
            piVar3 = piVar4;
        }
        sub.kernel32.dll_lstrcpynW(lpString1, &lpFileName, iMaxLength);
    } else {
        sub.kernel32.dll_lstrcpynW(in_EAX, &lpFileName, in_EDX);
    }
    return (int16_t *)var_ch;
}


void fcn.00406198(void)
{
    undefined4 *in_FS_OFFSET;
    undefined4 uStack36;
    undefined4 uStack32;
    undefined *puStack28;
    uint32_t var_8h;
    uint32_t var_4h;
    
    var_8h = *(uint32_t *)0x412030;
    if (*(uint32_t *)0x412030 != 0) {
        do {
            uStack32 = 0x4061d3;
            uStack36 = *in_FS_OFFSET;
            *in_FS_OFFSET = &uStack36;
            puStack28 = &stack0xfffffffc;
            (**(code **)(var_8h + 4))();
            *in_FS_OFFSET = uStack36;
            var_8h = *(uint32_t *)var_8h;
        } while (var_8h != 0);
    }
    return;
}


uint32_t __cdecl fcn.004062b8(int32_t arg_8h)
{
    int32_t in_EAX;
    uint32_t uVar1;
    int32_t in_ECX;
    uint32_t in_EDX;
    
    uVar1 = 0;
    if (in_ECX != 0) {
        if ((in_EAX == 0) || (in_EDX == 0)) {
            uVar1 = sub.kernel32.dll_MultiByteToWideChar(0xfde9, 0);
        } else {
            uVar1 = sub.kernel32.dll_MultiByteToWideChar(0xfde9, 0);
            if (((uVar1 != 0) && (uVar1 <= in_EDX)) && (*(int16_t *)(in_EAX + -2 + uVar1 * 2) != 0)) {
                if (in_EDX == uVar1) {
                    if (((1 < uVar1) && (0xdbff < *(uint16_t *)(in_EAX + -2 + uVar1 * 2))) &&
                       (*(uint16_t *)(in_EAX + -2 + uVar1 * 2) < 0xe000)) {
                        uVar1 = uVar1 - 1;
                    }
                } else {
                    uVar1 = uVar1 + 1;
                }
                *(undefined2 *)(in_EAX + -2 + uVar1 * 2) = 0;
            }
        }
    }
    return uVar1;
}


// WARNING: [r2ghidra] Failed to match type LPWSTR * for variable lpFilename to Decompiler type: Unknown type identifier
// LPWSTR

int32_t fcn.00405b90(void)
{
    int32_t in_EAX;
    int32_t iVar1;
    int32_t *piVar2;
    
    piVar2 = *(int32_t **)0x41202c;
    if (*(int32_t **)0x41202c != (int32_t *)0x0) {
        do {
            if (((in_EAX == piVar2[1]) || (in_EAX == piVar2[2])) || (in_EAX == piVar2[3])) {
                iVar1 = fcn.00405b48();
                return iVar1;
            }
            piVar2 = (int32_t *)*piVar2;
        } while (piVar2 != (int32_t *)0x0);
    }
    return in_EAX;
}


int32_t fcn.00403188(void)
{
    uint16_t uVar1;
    int32_t in_EAX;
    int32_t iVar2;
    
    iVar2 = 0;
    uVar1 = *(uint16_t *)(in_EAX + 4);
    if ((uVar1 < 0xd7b1) || (0xd7b3 < uVar1)) {
        if (in_EAX != 0x413054) {
            fcn.00402f8c();
        }
    } else {
        if ((uVar1 & 0xd7b2) == 0xd7b2) {
            iVar2 = (**(code **)(in_EAX + 0x1c))();
        }
        if (iVar2 == 0) {
            iVar2 = (**(code **)(in_EAX + 0x24))();
        }
        if (iVar2 != 0) {
            fcn.00402f8c();
        }
    }
    return iVar2;
}


// WARNING: [r2ghidra] Failed to match type signed int for variable var_1b808h to Decompiler type: Unknown type
// identifier signed
// WARNING: [r2ghidra] Failed to match type signed int for variable var_1b814h to Decompiler type: Unknown type
// identifier signed
// WARNING: [r2ghidra] Detected overlap for variable var_1b801h
// WARNING: [r2ghidra] Detected overlap for variable var_1b809h
// WARNING: [r2ghidra] Detected overlap for variable var_1b80ah

void fcn.00402d98(void)
{
    if (*(int32_t *)0x415ae0 != 0) {
        sub.kernel32.dll_CloseHandle(*(int32_t *)0x415ae0);
        *(int32_t *)0x415ae0 = 0;
    }
    if (*(char *)0x4138d4 != '\0') {
        fcn.004027b8();
    }
    if (*(int32_t *)0x415ad8 != 0) {
        sub.kernel32.dll_VirtualFree(*(int32_t *)0x415ad8, 0, 0x8000);
        *(int32_t *)0x415ad8 = 0;
    }
    fcn.00402d08();
    return;
}


undefined4 fcn.0040653c(void)
{
    return 8;
}


void fcn.00406530(void)
{
    sub.kernel32.dll_LocalAlloc(0x40);
    return;
}


void __fastcall fcn.004048d4(uint16_t param_1, int16_t *param_2)
{
    int32_t iVar1;
    int32_t *in_EAX;
    uint32_t arg_ch;
    int16_t *piVar2;
    
    arg_ch = 0;
    piVar2 = param_2;
    if (param_2 != (int16_t *)0x0) {
        while (*piVar2 != 0) {
            if (piVar2[1] == 0) {
code_r0x00404901:
                piVar2 = piVar2 + 1;
                break;
            }
            if (piVar2[2] == 0) {
code_r0x004048fe:
                piVar2 = piVar2 + 1;
                goto code_r0x00404901;
            }
            if (piVar2[3] == 0) {
                piVar2 = piVar2 + 1;
                goto code_r0x004048fe;
            }
            piVar2 = piVar2 + 4;
        }
        arg_ch = (uint32_t)((int32_t)piVar2 - (int32_t)param_2) >> 1;
    }
    if (arg_ch == 0) {
        fcn.004046c4();
    } else {
        if (param_1 == 0) {
            param_1 = *(uint16_t *)0x4138c8;
        }
        iVar1 = fcn.004047c0((uint32_t)param_1, arg_ch);
        fcn.004049c4();
        if (iVar1 < 1) {
            fcn.004046c4();
        } else {
            fcn.004047c0((uint32_t)param_1, arg_ch);
            *(uint16_t *)(*in_EAX + -0xc) = param_1;
        }
    }
    return;
}


int32_t fcn.0040494c(void)
{
    int32_t in_EAX;
    
    if (in_EAX != 0) {
        return in_EAX;
    }
    return 0x40495d;
}


// WARNING: [r2ghidra] Var arg_10h is stack pointer based, which is not supported for decompilation.
// WARNING: [r2ghidra] Var arg_2000h is stack pointer based, which is not supported for decompilation.

void __cdecl fcn.0040991c(int32_t arg_8h, int32_t arg_ch)
{
    char in_DL;
    int32_t **in_FS_OFFSET;
    int32_t *arg_8h_00;
    int32_t *piStack52;
    undefined4 uStack48;
    undefined *puStack44;
    int32_t var_8h;
    int32_t var_4h;
    
    var_4h = 0;
    var_8h = 0;
    if (in_DL != '\0') {
        puStack44 = (undefined *)0x409932;
        fcn.004039e4();
    }
    uStack48 = 0x409988;
    piStack52 = *in_FS_OFFSET;
    *in_FS_OFFSET = (int32_t *)&piStack52;
    arg_8h_00 = &var_4h;
    puStack44 = &stack0xfffffffc;
    fcn.004063e4();
    fcn.004082d4((int32_t)arg_8h_00);
    fcn.00404c98((int32_t)arg_8h_00);
    *in_FS_OFFSET = arg_8h_00;
    uStack48 = 0x40998f;
    piStack52 = (int32_t *)0x409987;
    fcn.00404c90();
    return;
}


void __fastcall fcn.00407cf4(undefined4 param_1, uint32_t param_2)
{
    uint64_t uVar1;
    int32_t iVar2;
    uint32_t in_EAX;
    uint32_t uVar3;
    uint16_t uVar4;
    int32_t iVar5;
    uint16_t *unaff_ESI;
    uint16_t *puVar6;
    
    puVar6 = unaff_ESI;
    do {
        uVar1 = (uint64_t)in_EAX;
        in_EAX = in_EAX / 10;
        uVar4 = (int16_t)(uVar1 % 10);
        uVar4 = uVar4 + 0x30;
        puVar6 = puVar6 + -1;
        if (0x39 < uVar4) {
            uVar4 = uVar4 + 0x37;
        }
        *puVar6 = uVar4;
    } while (in_EAX != 0);
    uVar3 = (uint32_t)((int32_t)unaff_ESI - (int32_t)puVar6) >> 1;
    iVar5 = param_2 - uVar3;
    if (uVar3 <= param_2 && iVar5 != 0) {
        iVar2 = iVar5 * 0x7fffffff;
        while (iVar5 = iVar5 + -1, iVar5 != 0) {
            (puVar6 + iVar2)[iVar5] = 0x30;
        }
        puVar6[iVar2] = 0x30;
    }
    return;
}


void __fastcall fcn.00407d70(int16_t param_1, uint32_t param_2)
{
    int32_t iVar1;
    uint16_t uVar2;
    uint64_t *in_EAX;
    uint32_t uVar3;
    int32_t iVar4;
    uint16_t *unaff_ESI;
    uint16_t *puVar5;
    unkfloat10 Var6;
    unkfloat10 Var7;
    
    if ((*(uint32_t *)((int32_t)in_EAX + 4) & 0x80000000) == 0) {
        Var7 = (unkfloat10)*in_EAX;
    } else {
        Var7 = (unkfloat10)0x7fffffffffffffff + (unkfloat10)1 + (unkfloat10)(*in_EAX & 0x7fffffffffffffff);
    }
    Var6 = (unkfloat10)param_1;
    puVar5 = unaff_ESI;
    do {
        puVar5 = puVar5 + -1;
        *puVar5 = (int16_t)ROUND(Var7 - (Var7 / Var6) * Var6);
        Var7 = Var7 / Var6;
        uVar2 = *puVar5 + 0x30;
        if (0x39 < uVar2) {
            uVar2 = *puVar5 + 0x37;
        }
        *puVar5 = uVar2;
    } while ((unkfloat10)1 <= Var7);
    uVar3 = (uint32_t)((int32_t)unaff_ESI - (int32_t)puVar5) >> 1;
    if ((-1 < (int32_t)param_2) && (iVar4 = param_2 - uVar3, uVar3 <= param_2 && iVar4 != 0)) {
        iVar1 = iVar4 * 0x7fffffff;
        while (iVar4 = iVar4 + -1, iVar4 != 0) {
            (puVar5 + iVar1)[iVar4] = 0x30;
        }
        puVar5[iVar1] = 0x30;
    }
    return;
}


void __fastcall fcn.00407e50(int16_t param_1, uint8_t *param_2)
{
    int32_t iVar1;
    uint8_t uVar2;
    uint64_t *in_EAX;
    uint8_t *puVar3;
    uint8_t *unaff_ESI;
    uint8_t *puVar4;
    unkfloat10 Var5;
    unkfloat10 Var6;
    unkfloat10 Var7;
    char cStack8;
    
    if ((*(uint32_t *)((int32_t)in_EAX + 4) & 0x80000000) == 0) {
        Var7 = (unkfloat10)*in_EAX;
    } else {
        Var7 = (unkfloat10)0x7fffffffffffffff + (unkfloat10)1 + (unkfloat10)(*in_EAX & 0x7fffffffffffffff);
    }
    Var5 = (unkfloat10)param_1;
    puVar4 = unaff_ESI;
    do {
        puVar4 = puVar4 + -1;
        Var6 = Var7 - (Var7 / Var5) * Var5;
        Var7 = Var7 / Var5;
        cStack8 = (char)(int16_t)ROUND(Var6);
        uVar2 = cStack8 + 0x30;
        if (0x39 < uVar2) {
            uVar2 = cStack8 + 0x37;
        }
        *puVar4 = uVar2;
    } while ((unkfloat10)1 <= Var7);
    puVar3 = param_2 + -(int32_t)(unaff_ESI + -(int32_t)puVar4);
    if (unaff_ESI + -(int32_t)puVar4 <= param_2 && puVar3 != (uint8_t *)0x0) {
        iVar1 = -(int32_t)puVar3;
        while (puVar3 = puVar3 + -1, puVar3 != (uint8_t *)0x0) {
            puVar3[(int32_t)(puVar4 + iVar1)] = 0x30;
        }
        puVar4[iVar1] = 0x30;
    }
    return;
}


void __fastcall fcn.00407e1c(int16_t param_1, uint8_t *param_2)
{
    int32_t iVar1;
    uint8_t uVar2;
    uint64_t *in_EAX;
    uint8_t *puVar3;
    uint8_t *unaff_ESI;
    uint8_t *puVar4;
    unkfloat10 Var5;
    unkfloat10 Var6;
    unkfloat10 Var7;
    char cVar8;
    
    if (((char)param_1 == '\0') && (param_1 = 10, (*(uint32_t *)((int32_t)in_EAX + 4) & 0x80000000) != 0)) {
        fcn.00407e50(-*(int32_t *)in_EAX, -(*(int32_t *)((int32_t)in_EAX + 4) + (uint32_t)(*(int32_t *)in_EAX != 0)));
        unaff_ESI[-1] = 0x2d;
        return;
    }
    if ((*(uint32_t *)((int32_t)in_EAX + 4) & 0x80000000) == 0) {
        Var7 = (unkfloat10)*in_EAX;
    } else {
        Var7 = (unkfloat10)0x7fffffffffffffff + (unkfloat10)1 + (unkfloat10)(*in_EAX & 0x7fffffffffffffff);
    }
    Var5 = (unkfloat10)param_1;
    puVar4 = unaff_ESI;
    do {
        puVar4 = puVar4 + -1;
        Var6 = Var7 - (Var7 / Var5) * Var5;
        Var7 = Var7 / Var5;
        cVar8 = (char)(int16_t)ROUND(Var6);
        uVar2 = cVar8 + 0x30;
        if (0x39 < uVar2) {
            uVar2 = cVar8 + 0x37;
        }
        *puVar4 = uVar2;
    } while ((unkfloat10)1 <= Var7);
    puVar3 = param_2 + -(int32_t)(unaff_ESI + -(int32_t)puVar4);
    if (unaff_ESI + -(int32_t)puVar4 <= param_2 && puVar3 != (uint8_t *)0x0) {
        iVar1 = -(int32_t)puVar3;
        while (puVar3 = puVar3 + -1, puVar3 != (uint8_t *)0x0) {
            puVar3[(int32_t)(puVar4 + iVar1)] = 0x30;
        }
        puVar4[iVar1] = 0x30;
    }
    return;
}


void __fastcall fcn.004032ec(undefined4 param_1, uint32_t *param_2)
{
    bool bVar1;
    uint16_t *in_EAX;
    uint32_t uVar2;
    uint16_t uVar3;
    uint16_t uVar4;
    uint16_t *puVar5;
    uint16_t *puVar6;
    
    puVar6 = in_EAX;
    if (in_EAX == (uint16_t *)0x0) {
code_r0x0040337d:
        puVar6 = puVar6 + 1;
    } else {
        uVar2 = 0;
        do {
            puVar5 = puVar6;
            uVar3 = *puVar5;
            puVar6 = puVar5 + 1;
        } while (uVar3 == 0x20);
        bVar1 = false;
        if (uVar3 == 0x2d) {
            bVar1 = true;
code_r0x0040338f:
            uVar3 = *puVar6;
            puVar6 = puVar5 + 2;
        } else {
            if (uVar3 == 0x2b) goto code_r0x0040338f;
        }
        if (((uVar3 == 0x24) || (uVar3 == 0x78)) || (uVar3 == 0x58)) {
code_r0x00403397:
            uVar3 = *puVar6;
            puVar6 = puVar6 + 1;
            if (uVar3 != 0) {
                do {
                    if (0x60 < uVar3) {
                        uVar3 = uVar3 - 0x20;
                    }
                    uVar4 = uVar3 - 0x30;
                    if (9 < uVar4) {
                        if (5 < (uint16_t)(uVar3 - 0x41)) goto code_r0x00403388;
                        uVar4 = uVar3 - 0x37;
                    }
                    if (0xfffffff < uVar2) goto code_r0x00403388;
                    uVar2 = uVar2 * 0x10 + (uint32_t)uVar4;
                    uVar3 = *puVar6;
                    puVar6 = puVar6 + 1;
                } while (uVar3 != 0);
code_r0x004033e3:
                puVar6 = (uint16_t *)0x0;
                goto code_r0x004033e6;
            }
            goto code_r0x0040337d;
        }
        if (uVar3 != 0x30) {
            if (uVar3 != 0) goto code_r0x00403353;
            goto code_r0x00403388;
        }
        uVar3 = *puVar6;
        puVar6 = puVar6 + 1;
        if ((uVar3 == 0x78) || (uVar3 == 0x58)) goto code_r0x00403397;
        while (uVar3 != 0) {
code_r0x00403353:
            if ((9 < (uint16_t)(uVar3 - 0x30)) || (0xccccccc < uVar2)) goto code_r0x00403388;
            uVar2 = uVar2 * 10 + (uint32_t)(uint16_t)(uVar3 - 0x30);
            uVar3 = *puVar6;
            puVar6 = puVar6 + 1;
        }
        if (bVar1) {
            if ((-1 < (int32_t)uVar2) || (0 < (int32_t)uVar2)) goto code_r0x004033e3;
        } else {
            if (-1 < (int32_t)uVar2) goto code_r0x004033e3;
        }
    }
code_r0x00403388:
    puVar6 = (uint16_t *)((int32_t)puVar6 - (int32_t)in_EAX);
code_r0x004033e6:
    *param_2 = (uint32_t)puVar6 >> 1;
    return;
}


int16_t * __fastcall fcn.004081d0(undefined4 param_1, int16_t param_2)
{
    int16_t *in_EAX;
    
    while( true ) {
        if (param_2 == *in_EAX) {
            return in_EAX;
        }
        if (*in_EAX == 0) break;
        in_EAX = in_EAX + 1;
    }
    return (int16_t *)0x0;
}


void __fastcall fcn.00407f4c(undefined4 param_1, int32_t param_2)
{
    int32_t iVar1;
    int32_t iVar2;
    undefined4 *in_FS_OFFSET;
    undefined4 uStack36;
    undefined4 uStack32;
    undefined *puStack28;
    int32_t var_8h;
    int32_t var_4h;
    
    puStack28 = (undefined *)0x407f62;
    fcn.00404c80();
    uStack32 = 0x408018;
    uStack36 = *in_FS_OFFSET;
    *in_FS_OFFSET = &uStack36;
    iVar1 = param_2;
    puStack28 = &stack0xfffffffc;
    if ((param_2 != 0) && (puStack28 = &stack0xfffffffc, *(int16_t *)(param_2 + -10) != 2)) {
        puStack28 = &stack0xfffffffc;
        iVar1 = fcn.00404820();
    }
    if (iVar1 != 0) {
        iVar1 = *(int32_t *)(iVar1 + -4);
    }
    var_8h = fcn.00404d24();
    while (0 < iVar1) {
        iVar2 = param_2;
        if ((param_2 != 0) && (*(int16_t *)(param_2 + -10) != 2)) {
            iVar2 = fcn.00404820();
        }
        if (*(int16_t *)(iVar2 + -2 + iVar1 * 2) != 0) {
            if ((param_2 != 0) && (*(int16_t *)(param_2 + -10) != 2)) {
                fcn.00404820();
            }
            iVar2 = fcn.004081d0();
            if (iVar2 != 0) break;
        }
        iVar1 = iVar1 + -1;
    }
    *in_FS_OFFSET = uStack36;
    puStack28 = (undefined *)0x40801f;
    uStack32 = 0x408017;
    fcn.00404c88();
    return;
}


// WARNING: [r2ghidra] Var arg_10h is stack pointer based, which is not supported for decompilation.
// WARNING: [r2ghidra] Var arg_ch is stack pointer based, which is not supported for decompilation.

uint64_t __fastcall fcn.004058ec(undefined4 param_1, int32_t param_2, uint32_t param_3, int32_t param_4)
{
    uint32_t in_EAX;
    
    return (uint64_t)in_EAX * (uint64_t)param_3 & 0xffffffff |
           (uint64_t)((int32_t)((uint64_t)in_EAX * (uint64_t)param_3 >> 0x20) + param_4 * in_EAX + param_2 * param_3) <<
           0x20;
}


uint32_t fcn.004080dc(void)
{
    int16_t iVar1;
    int16_t *in_EAX;
    int16_t *piVar2;
    
    if (*in_EAX != 0) {
        piVar2 = in_EAX;
        do {
            iVar1 = *piVar2;
            piVar2 = piVar2 + 1;
        } while (iVar1 != 0);
        return (uint32_t)((-2 - (int32_t)in_EAX) + (int32_t)piVar2) >> 1;
    }
    return 0;
}


undefined8 __fastcall fcn.004080fc(undefined4 param_1, undefined4 param_2)
{
    int16_t *piVar1;
    int16_t *in_EAX;
    int16_t *piVar2;
    
    if (*in_EAX != 0) {
        piVar1 = in_EAX;
        do {
            piVar2 = piVar1;
            piVar1 = piVar2 + 1;
        } while (*piVar2 != 0);
        return CONCAT44(-(int32_t)in_EAX, piVar2);
    }
    return CONCAT44(param_2, in_EAX);
}


void fcn.00408118(void)
{
    fcn.00402fbc();
    return;
}


void __fastcall fcn.00407bb8(int32_t param_1, int32_t param_2)
{
    fcn.0040991c(param_1, param_2);
    fcn.00403f88();
    return;
}


// WARNING: [r2ghidra] Detected overlap for variable var_16h
// WARNING: [r2ghidra] Failed to match type signed int for variable arg_8h to Decompiler type: Unknown type identifier
// signed

void __cdecl fcn.00408540(undefined4 placeholder_0, undefined4 placeholder_1, int32_t arg_10h)
{
    int16_t iVar1;
    int16_t iVar2;
    int16_t *in_EAX;
    int16_t *in_ECX;
    int16_t *piVar3;
    int16_t *extraout_ECX;
    int16_t *extraout_ECX_00;
    int16_t *extraout_ECX_01;
    int16_t *piVar4;
    int16_t *in_EDX;
    int16_t *extraout_EDX;
    int16_t *extraout_EDX_00;
    int16_t *piVar5;
    int16_t *piVar6;
    int16_t *piVar7;
    int32_t unaff_ESI;
    int16_t *piVar8;
    undefined4 unaff_EDI;
    bool bVar9;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_14h;
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    
    piVar3 = in_ECX + arg_10h;
code_r0x0040856c:
    piVar4 = in_ECX;
    if (in_EDX != (int16_t *)0x0) {
        do {
            if (piVar4 == piVar3) break;
            piVar5 = piVar4 + 1;
            iVar1 = *piVar4;
            piVar7 = piVar5;
            if (iVar1 == 0x25) {
                if (piVar5 == piVar3) break;
                piVar7 = piVar4 + 2;
                iVar1 = *piVar5;
                if (iVar1 != 0x25) goto code_r0x0040859f;
            }
            *in_EAX = iVar1;
            in_EDX = (int16_t *)((int32_t)in_EDX + -1);
            piVar4 = piVar7;
            in_EAX = in_EAX + 1;
            if (in_EDX == (int16_t *)0x0) break;
        } while( true );
    }
code_r0x00408914:
    fcn.00408904();
    return;
code_r0x0040859f:
    in_ECX = piVar7;
    if (iVar1 == 0x2d) {
        if (piVar7 == piVar3) goto code_r0x00408914;
        in_ECX = piVar7 + 1;
    }
    iVar2 = fcn.0040862e(unaff_EDI, unaff_ESI);
    piVar3 = extraout_ECX;
    if (iVar2 != 0x3a) goto code_r0x004085c5;
    if (in_ECX == extraout_ECX) goto code_r0x00408914;
    piVar7 = in_ECX + 1;
    iVar1 = *in_ECX;
    goto code_r0x0040859f;
code_r0x004085c5:
    piVar5 = extraout_EDX;
    if (iVar2 == 0x2e) {
        if (in_ECX == extraout_ECX) goto code_r0x00408914;
        in_ECX = in_ECX + 1;
        fcn.0040862e(unaff_EDI, unaff_ESI);
        piVar3 = extraout_ECX_00;
        piVar5 = extraout_EDX_00;
    }
    fcn.0040867d(piVar5, (int32_t)piVar3);
    piVar7 = (int16_t *)((int32_t)piVar4 - (int32_t)extraout_ECX_01);
    if (piVar4 < extraout_ECX_01) {
        piVar7 = (int16_t *)0x0;
    }
    piVar4 = extraout_ECX_01;
    piVar8 = in_ECX;
    if (iVar1 == 0x2d) {
        bVar9 = piVar5 < extraout_ECX_01;
        piVar5 = (int16_t *)((int32_t)piVar5 - (int32_t)extraout_ECX_01);
        if (bVar9) {
            piVar4 = (int16_t *)((int32_t)extraout_ECX_01 + (int32_t)piVar5);
            piVar5 = (int16_t *)0x0;
        }
        while (piVar4 != (int16_t *)0x0) {
            piVar4 = (int16_t *)((int32_t)piVar4 + -1);
            *in_EAX = *piVar8;
            piVar8 = piVar8 + 1;
            in_EAX = in_EAX + 1;
        }
    }
    piVar6 = (int16_t *)((int32_t)piVar5 - (int32_t)piVar7);
    if (piVar5 < piVar7) {
        piVar7 = (int16_t *)((int32_t)piVar7 + (int32_t)piVar6);
        piVar6 = (int16_t *)0x0;
    }
    while (piVar7 != (int16_t *)0x0) {
        piVar7 = (int16_t *)((int32_t)piVar7 + -1);
        *in_EAX = 0x20;
        in_EAX = in_EAX + 1;
    }
    in_EDX = (int16_t *)((int32_t)piVar6 - (int32_t)piVar4);
    if (piVar6 < piVar4) {
        piVar4 = (int16_t *)((int32_t)piVar4 + (int32_t)in_EDX);
        in_EDX = (int16_t *)0x0;
    }
    while (piVar4 != (int16_t *)0x0) {
        piVar4 = (int16_t *)((int32_t)piVar4 + -1);
        *in_EAX = *piVar8;
        piVar8 = piVar8 + 1;
        in_EAX = in_EAX + 1;
    }
    goto code_r0x0040856c;
}


// WARNING: [r2ghidra] Detected overlap for variable var_16h

void __cdecl fcn.00408274(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h)
{
    fcn.00408540(arg_8h, arg_ch, arg_10h);
    return;
}


// WARNING: Removing unreachable block (ram,0x00402f34)

void __fastcall fcn.00404b9c(int32_t param_1, int32_t *param_2)
{
    int32_t iVar1;
    int32_t *in_EAX;
    int32_t iVar2;
    
    if (param_1 == 0) {
        iVar2 = *in_EAX;
        if (iVar2 != 0) {
            *in_EAX = 0;
            sub.oleaut32.dll_SysFreeString(iVar2);
        }
        return;
    }
    iVar2 = sub.oleaut32.dll_SysAllocStringLen(param_2, param_1);
    if (iVar2 == 0) {
        if (*(code **)0x413008 != (code *)0x0) {
            (**(code **)0x413008)();
        }
        fcn.00402f08();
        return;
    }
    iVar1 = *param_2;
    *param_2 = iVar2;
    sub.oleaut32.dll_SysFreeString(iVar1);
    return;
}


void __fastcall fcn.00404eb8(undefined4 param_1, int32_t param_2)
{
    undefined4 uVar1;
    undefined4 *in_EAX;
    
    uVar1 = fcn.004054b4();
    if (param_2 != 0) {
        fcn.00402fbc();
    }
    fcn.004046c4();
    *in_EAX = uVar1;
    return;
}


void __fastcall fcn.0040822c(uint32_t param_1)
{
    undefined2 auStack80 [32];
    undefined2 *puStack16;
    undefined uStack12;
    
    puStack16 = auStack80;
    if (0x1f < param_1) {
        param_1 = 0x1f;
    }
    fcn.00408118();
    auStack80[param_1] = 0;
    uStack12 = 10;
    fcn.00407bb8();
    return;
}


// WARNING: Could not reconcile some variable overlaps
// WARNING: [r2ghidra] Failed to match type signed int for variable arg_ch to Decompiler type: Unknown type identifier
// signed
// WARNING: [r2ghidra] Detected overlap for variable var_ah
// WARNING: [r2ghidra] Detected overlap for variable var_ch
// WARNING: [r2ghidra] Detected overlap for variable var_dh
// WARNING: [r2ghidra] Detected overlap for variable var_eh
// WARNING: [r2ghidra] Detected overlap for variable var_23h

uint32_t __cdecl fcn.00408988(int32_t arg_8h, int32_t arg_ch, uint32_t arg_10h)
{
    undefined2 *in_EAX;
    int32_t iVar1;
    int32_t iVar2;
    char in_CL;
    int32_t extraout_ECX;
    undefined2 *puVar3;
    undefined2 *puVar4;
    int32_t var_26h;
    int32_t var_8h;
    int32_t var_4h;
    
    iVar1 = 0x13;
    if (in_CL == '\0') {
        iVar1 = arg_ch;
        if (arg_ch < 2) {
            iVar1 = 2;
        }
        if (0x12 < iVar1) {
            iVar1 = 0x12;
        }
    }
    iVar2 = 9999;
    if (1 < (uint8_t)arg_10h) {
        iVar2 = arg_8h;
    }
    fcn.00408c88(iVar2, iVar1);
    puVar4 = in_EAX;
    if ((uint16_t)var_26h - 0x7fff < 2) {
        fcn.00408a88();
        iVar1 = 3;
        puVar3 = (undefined2 *)(extraout_ECX * 6 + 0x408a71);
        while (iVar1 != 0) {
            iVar1 = iVar1 + -1;
            *puVar4 = *puVar3;
            puVar3 = puVar3 + 1;
            puVar4 = puVar4 + 1;
        }
    } else {
        arg_10h = arg_10h & 0xff;
        if (((uint8_t)arg_10h != 1) && ((4 < (uint8_t)arg_10h || (iVar1 < (int16_t)(uint16_t)var_26h)))) {
            arg_10h = 0;
        }
        (**(code **)(arg_10h * 4 + 0x408a5d))();
    }
    return (uint32_t)((int32_t)puVar4 - (int32_t)in_EAX) >> 1;
}


// WARNING: [r2ghidra] Failed to match type signed int for variable arg_8h to Decompiler type: Unknown type identifier
// signed

void __cdecl fcn.0040862e(undefined4 arg_8h, int32_t arg_ch)
{
    uint16_t in_AX;
    uint16_t *in_ECX;
    int32_t unaff_EBP;
    uint16_t *unaff_ESI;
    int32_t var_ch;
    
    if (in_AX == 0x2a) {
        if (*(int32_t *)(unaff_EBP + -0xc) <= *(int32_t *)(unaff_EBP + 8)) {
            *(int32_t *)(unaff_EBP + -0xc) = *(int32_t *)(unaff_EBP + -0xc) + 1;
        }
        if (unaff_ESI == in_ECX) {
code_r0x00408914:
            fcn.00408904();
            return;
        }
    } else {
        while ((0x2f < in_AX && (in_AX < 0x3a))) {
            if (unaff_ESI == in_ECX) goto code_r0x00408914;
            in_AX = *unaff_ESI;
            unaff_ESI = unaff_ESI + 1;
        }
    }
    return;
}


// WARNING: Variable defined which should be unmapped: var_a6h
// WARNING: [r2ghidra] Failed to match type signed int for variable arg_8h to Decompiler type: Unknown type identifier
// signed

void __cdecl fcn.0040867d(undefined4 arg_8h, int32_t arg_ch)
{
    int32_t iVar1;
    uint16_t uVar2;
    uint64_t *puVar3;
    char cVar4;
    int16_t iVar5;
    uint32_t uVar6;
    undefined4 extraout_ECX;
    unkbyte3 Var7;
    int32_t iVar8;
    uint32_t uVar9;
    int32_t unaff_EBP;
    uint16_t *puVar10;
    unkfloat10 Var11;
    unkfloat10 Var12;
    int32_t var_a6h;
    int32_t var_86h;
    int32_t var_66h;
    int32_t var_24h;
    uint32_t var_20h;
    int32_t var_14h;
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_4h;
    
    iVar8 = *(int32_t *)(unaff_EBP + -0xc);
    if (iVar8 <= *(int32_t *)(unaff_EBP + 8)) {
        *(int32_t *)(unaff_EBP + -0xc) = *(int32_t *)(unaff_EBP + -0xc) + 1;
    // WARNING: Could not recover jumptable at 0x0040869d. Too many branches
    // WARNING: Treating indirect jump as call
    // switch table (5 cases) at 0x4086a4
        (**(code **)((uint32_t)*(uint8_t *)(*(int32_t *)(unaff_EBP + 0xc) + iVar8 * 8 + 4) * 4 + 0x4086a4))();
        return;
    }
    do {
        fcn.00408904();
        puVar3 = (uint64_t *)fcn.00408480();
        uVar9 = *(uint32_t *)(unaff_EBP + -0x20);
        if (0x20 < uVar9) {
            uVar9 = 0;
        }
        cVar4 = (char)extraout_ECX;
        Var7 = (unkbyte3)((uint32_t)extraout_ECX >> 8);
        cVar4 = cVar4 + -0x44;
        if (cVar4 == '\0') break;
        cVar4 = '\x10';
        Var7 = 0;
        if (cVar4 == 'X') break;
        cVar4 = '\n';
        Var7 = 0;
    } while (cVar4 != 'U');
    iVar5 = (int16_t)CONCAT31(Var7, cVar4);
    if ((cVar4 == '\0') && (iVar5 = 10, (*(uint32_t *)((int32_t)puVar3 + 4) & 0x80000000) != 0)) {
        fcn.00407d70(-*(int32_t *)puVar3, -(*(int32_t *)((int32_t)puVar3 + 4) + (uint32_t)(*(int32_t *)puVar3 != 0)));
        *(undefined2 *)(unaff_EBP + -0x68) = 0x2d;
        return;
    }
    if ((*(uint32_t *)((int32_t)puVar3 + 4) & 0x80000000) == 0) {
        Var12 = (unkfloat10)*puVar3;
    } else {
        Var12 = (unkfloat10)0x7fffffffffffffff + (unkfloat10)1 + (unkfloat10)(*puVar3 & 0x7fffffffffffffff);
    }
    Var11 = (unkfloat10)iVar5;
    puVar10 = (uint16_t *)(unaff_EBP + -0x66);
    do {
        puVar10 = puVar10 + -1;
        *puVar10 = (int16_t)ROUND(Var12 - (Var12 / Var11) * Var11);
        Var12 = Var12 / Var11;
        uVar2 = *puVar10 + 0x30;
        if (0x39 < uVar2) {
            uVar2 = *puVar10 + 0x37;
        }
        *puVar10 = uVar2;
    } while ((unkfloat10)1 <= Var12);
    uVar6 = (uint32_t)((int32_t)(uint16_t *)(unaff_EBP + -0x66) - (int32_t)puVar10) >> 1;
    if ((-1 < (int32_t)uVar9) && (iVar8 = uVar9 - uVar6, uVar6 <= uVar9 && iVar8 != 0)) {
        iVar1 = iVar8 * 0x7fffffff;
        while (iVar8 = iVar8 + -1, iVar8 != 0) {
            (puVar10 + iVar1)[iVar8] = 0x30;
        }
        puVar10[iVar1] = 0x30;
    }
    return;
}


undefined4 fcn.00408904(void)
{
    undefined4 in_EAX;
    int32_t var_10h;
    int32_t var_4h;
    
    fcn.00404a8c();
    return in_EAX;
}


void fcn.00408480(void)
{
    undefined4 *in_FS_OFFSET;
    undefined4 uStack36;
    undefined4 uStack32;
    undefined *puStack28;
    int32_t var_8h;
    int32_t var_4h;
    
    puStack28 = &stack0xfffffffc;
    var_8h = 0;
    uStack32 = 0x4084f0;
    uStack36 = *in_FS_OFFSET;
    *in_FS_OFFSET = &uStack36;
    fcn.00404c2c();
    fcn.00404b9c();
    fcn.00404eb8();
    fcn.00404d24();
    fcn.0040822c();
    *in_FS_OFFSET = uStack36;
    puStack28 = (undefined *)0x4084f7;
    uStack32 = 0x4084e7;
    fcn.00404c88();
    uStack32 = 0x4084ef;
    fcn.00404a8c();
    return;
}


// WARNING: [r2ghidra] Failed to match type signed int for variable arg_ch to Decompiler type: Unknown type identifier
// signed
// WARNING: [r2ghidra] Detected overlap for variable var_ah
// WARNING: [r2ghidra] Detected overlap for variable var_ch
// WARNING: [r2ghidra] Detected overlap for variable var_dh
// WARNING: [r2ghidra] Detected overlap for variable var_eh
// WARNING: [r2ghidra] Detected overlap for variable var_23h

void __cdecl fcn.00408524(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h)
{
    fcn.00408988(arg_8h, arg_ch, arg_10h & 0xff);
    return;
}


void fcn.00408500(void)
{
    if (**(code ***)0x412c14 != (code *)0x0) {
        (***(code ***)0x412c14)();
        return;
    }
    fcn.00402f60();
    return;
}


// WARNING: [r2ghidra] Detected overlap for variable var_ah

void __fastcall fcn.00408c88(char param_1)
{
    int32_t unaff_EBX;
    uint32_t unaff_ESI;
    int32_t var_4h;
    
    if (param_1 == '\0') {
        fcn.00408cb5(unaff_EBX, unaff_ESI);
    } else {
        fcn.00408dd7(unaff_EBX);
    }
    return;
}


void fcn.00408a88(void)
{
    int32_t unaff_EBP;
    undefined2 *unaff_EDI;
    uint32_t var_24h;
    
    if (*(char *)(unaff_EBP + -0x24) != '\0') {
        *unaff_EDI = 0x2d;
    }
    return;
}


char fcn.00408a7d(void)
{
    char cVar1;
    char *unaff_ESI;
    
    cVar1 = *unaff_ESI;
    if (cVar1 == '\0') {
        cVar1 = '0';
    }
    return cVar1;
}


uint32_t __fastcall fcn.00408924(int32_t param_1, uint32_t param_2)
{
    char cVar2;
    uint32_t in_EAX;
    uint32_t uVar1;
    char cVar4;
    undefined4 unaff_EBX;
    char *pcVar3;
    undefined *unaff_EDI;
    char *pcVar5;
    char *pcVar6;
    char acStack20 [4];
    char *pcStack16;
    uint32_t uStack8;
    
    *unaff_EDI = (char)in_EAX;
    cVar4 = (char)((uint32_t)unaff_EBX >> 8);
    pcVar3 = unaff_EDI + 1;
    if (cVar4 != '\0') {
        in_EAX = in_EAX & 0xffffff00;
        pcVar3 = unaff_EDI + 2;
        unaff_EDI[1] = '\0';
    }
    if ((char)unaff_EBX == '\0') {
        param_2 = 0;
code_r0x00408942:
        cVar2 = (char)(in_EAX >> 8);
        pcVar5 = pcVar3;
        if (cVar2 == '\0') goto code_r0x00408951;
    } else {
        if (-1 < (int32_t)param_2) goto code_r0x00408942;
        cVar2 = '-';
        param_2 = -param_2;
    }
    *pcVar3 = cVar2;
    pcVar5 = pcVar3 + 1;
    if (cVar4 != '\0') {
        pcVar5 = pcVar3 + 2;
        pcVar3[1] = '\0';
    }
code_r0x00408951:
    pcVar3 = acStack20;
    pcStack16 = pcVar3;
    uStack8 = param_2;
    do {
        do {
            uVar1 = param_2 / *(uint32_t *)0x412830;
            *pcVar3 = (char)(param_2 % *(uint32_t *)0x412830) + '0';
            pcVar3 = pcVar3 + 1;
            param_1 = param_1 + -1;
            param_2 = uVar1;
        } while (uVar1 != 0);
    } while (0 < param_1);
    do {
        pcVar3 = pcVar3 + -1;
        *pcVar5 = *pcVar3;
        pcVar6 = pcVar5 + 1;
        if ((char)((uint32_t)unaff_EBX >> 8) != '\0') {
            pcVar6 = pcVar5 + 2;
            pcVar5[1] = '\0';
        }
        pcVar5 = pcVar6;
    } while (pcVar3 != pcStack16);
    return uStack8;
}


void fcn.00408c0e(void)
{
    int32_t iVar1;
    int32_t unaff_EBP;
    undefined2 *puVar2;
    undefined2 *unaff_EDI;
    int32_t var_8h;
    
    puVar2 = *(undefined2 **)(unaff_EBP + -8);
    if (puVar2 != (undefined2 *)0x0) {
        iVar1 = *(int32_t *)(puVar2 + -2);
        while (iVar1 != 0) {
            iVar1 = iVar1 + -1;
            *unaff_EDI = *puVar2;
            puVar2 = puVar2 + 1;
            unaff_EDI = unaff_EDI + 1;
        }
    }
    return;
}


// WARNING: [r2ghidra] Detected overlap for variable var_ch

void __cdecl fcn.00408b47(int32_t arg_8h, undefined4 placeholder_1, uint32_t arg_10h)
{
    int16_t iVar1;
    int32_t iVar2;
    int32_t extraout_ECX;
    uint32_t uVar3;
    uint32_t extraout_EDX;
    int32_t extraout_EDX_00;
    int32_t iVar4;
    int32_t unaff_EBP;
    int16_t *unaff_EDI;
    int16_t *piVar5;
    int16_t *piVar6;
    int32_t var_26h;
    int32_t var_ah;
    
    uVar3 = *(uint32_t *)(unaff_EBP + 8);
    if (0x11 < uVar3) {
        uVar3 = 0x12;
    }
    iVar2 = (int32_t)*(int16_t *)(unaff_EBP + -0x26);
    if (iVar2 < 1) {
        piVar5 = unaff_EDI + 1;
        *unaff_EDI = 0x30;
    } else {
        iVar4 = 0;
        if (*(char *)(unaff_EBP + 0x10) != '\x02') {
            iVar4 = (uint8_t)((uint16_t)(*(int16_t *)(unaff_EBP + -0x26) - 1U) % 3) + 1;
        }
        while( true ) {
            piVar6 = unaff_EDI;
            iVar1 = fcn.00408a7d();
            piVar5 = piVar6 + 1;
            *piVar6 = iVar1;
            iVar2 = extraout_ECX + -1;
            uVar3 = extraout_EDX;
            if (iVar2 == 0) break;
            iVar4 = iVar4 + -1;
            unaff_EDI = piVar5;
            if ((iVar4 == 0) && (*(int16_t *)(unaff_EBP + -0xc) != 0)) {
                *piVar5 = *(int16_t *)(unaff_EBP + -0xc);
                iVar4 = 3;
                unaff_EDI = piVar6 + 2;
            }
        }
    }
    if (uVar3 != 0) {
        piVar6 = piVar5;
        if (*(int16_t *)(unaff_EBP + -10) != 0) {
            piVar6 = piVar5 + 1;
            *piVar5 = *(int16_t *)(unaff_EBP + -10);
        }
        while (iVar2 != 0) {
            *piVar6 = 0x30;
            uVar3 = uVar3 - 1;
            if (uVar3 == 0) {
                return;
            }
            iVar2 = iVar2 + 1;
            piVar6 = piVar6 + 1;
        }
        do {
            iVar1 = fcn.00408a7d();
            *piVar6 = iVar1;
            piVar6 = piVar6 + 1;
        } while (extraout_EDX_00 != 1);
    }
    return;
}


void __cdecl fcn.00408dd7(int32_t arg_8h)
{
    uint32_t uVar1;
    uint32_t uVar2;
    int32_t iVar3;
    uint8_t uVar7;
    uint16_t uVar4;
    int16_t iVar5;
    uint32_t uVar6;
    int32_t iVar8;
    uint8_t uVar9;
    uint32_t uVar10;
    int16_t *unaff_EBX;
    int32_t unaff_EBP;
    uint32_t *unaff_ESI;
    int32_t iVar11;
    int16_t *piVar12;
    int16_t *piVar13;
    bool bVar14;
    unkfloat10 Var15;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_4h;
    
    uVar6 = *unaff_ESI;
    uVar10 = unaff_ESI[1];
    if ((uVar6 | uVar10) != 0) {
        if ((int32_t)uVar10 < 0) {
            bVar14 = uVar6 != 0;
            uVar6 = -uVar6;
            uVar10 = -(uint32_t)bVar14 - uVar10;
        }
        iVar8 = 0;
        iVar11 = *(int32_t *)(unaff_EBP + 8);
        if (iVar11 < 0) {
            iVar11 = 0;
        }
        if (3 < iVar11) {
            iVar11 = 4;
            uVar2 = uVar6;
            iVar3 = iVar8;
            do {
                iVar8 = iVar3;
                uVar6 = uVar2;
                bVar14 = 0xde0b6b2 < uVar10;
                uVar1 = uVar10 + 0xf21f494d;
                uVar10 = uVar1 - (uVar6 < 0xa7640000);
                uVar2 = uVar6 + 0x589c0000;
                iVar3 = iVar8 + 1;
            } while (bVar14 && (uVar6 < 0xa7640000) <= uVar1);
            uVar10 = uVar10 + 0xde0b6b3 + (uint32_t)(0x589bffff < uVar6 + 0x589c0000);
        }
        *(uint32_t *)(unaff_EBP + -0x20) = uVar6;
        *(uint32_t *)(unaff_EBP + -0x1c) = uVar10;
        Var15 = (unkfloat10)*(int64_t *)(unaff_EBP + -0x20);
        if (4 - iVar11 != 0) {
            Var15 = Var15 / (unkfloat10)*(int32_t *)(*(int32_t *)(unaff_EBP + -4) + 0x408dc3 + (4 - iVar11) * 4);
        }
        *(unkfloat10 *)(unaff_EBP + -0x18) = Var15;
        piVar12 = (int16_t *)((int32_t)unaff_EBX + 3);
        if (iVar8 != 0) {
            piVar13 = unaff_EBX + 2;
            *(char *)piVar12 = (char)iVar8 + '0';
            iVar8 = 9;
            goto code_r0x00408e6e;
        }
        iVar8 = 9;
        do {
            uVar9 = *(uint8_t *)(iVar8 + -0x19 + unaff_EBP);
            uVar4 = CONCAT11(uVar9, uVar9 >> 4);
            piVar13 = piVar12;
            if (uVar9 >> 4 != 0) goto code_r0x00408e77;
            uVar7 = (uint8_t)((uint32_t)uVar4 >> 8);
            if ((uVar9 & 0xf) != 0) goto code_r0x00408e7e;
            iVar8 = iVar8 + -1;
        } while (iVar8 != 0);
    }
    iVar5 = 0;
    uVar9 = 0;
    *(undefined *)((int32_t)unaff_EBX + 3) = 0;
code_r0x00408ea4:
    *unaff_EBX = iVar5;
    *(uint8_t *)(unaff_EBX + 1) = uVar9;
    return;
code_r0x00408e7e:
    while( true ) {
        piVar13 = (int16_t *)((int32_t)piVar12 + 1);
        *(uint8_t *)piVar12 = (uVar7 & 0xf) + 0x30;
        iVar8 = iVar8 + -1;
        if (iVar8 == 0) break;
code_r0x00408e6e:
        uVar9 = *(uint8_t *)(iVar8 + -0x19 + unaff_EBP);
        uVar4 = CONCAT11(uVar9, uVar9 >> 4);
code_r0x00408e77:
        uVar7 = (uint8_t)(uVar4 >> 8);
        piVar12 = (int16_t *)((int32_t)piVar13 + 1);
        *(char *)piVar13 = (char)uVar4 + '0';
    }
    iVar5 = (int16_t)piVar13 - ((int16_t)unaff_EBX + 3 + (int16_t)iVar11);
    do {
        *(char *)piVar13 = '\0';
        piVar13 = (int16_t *)((int32_t)piVar13 + -1);
    } while (*(char *)piVar13 == '0');
    uVar9 = (uint8_t)(unaff_ESI[1] >> 0x1f);
    goto code_r0x00408ea4;
}


// WARNING: [r2ghidra] Detected overlap for variable var_ah

void __cdecl fcn.00408cb5(int32_t arg_8h, uint32_t arg_ch)
{
    char *pcVar1;
    unkfloat10 Var2;
    int16_t *piVar3;
    undefined2 uVar4;
    uint32_t uVar5;
    uint16_t uVar6;
    uint8_t uVar8;
    int32_t iVar7;
    undefined2 *unaff_EBX;
    int32_t unaff_EBP;
    int32_t *unaff_ESI;
    int16_t *piVar9;
    unkfloat10 Var10;
    int32_t var_8h;
    int32_t var_4h;
    
    uVar6 = *(uint16_t *)(unaff_ESI + 2);
    uVar5 = uVar6 & 0x7fff;
    if ((uVar6 & 0x7fff) == 0) {
code_r0x00408ce0:
        uVar6 = 0;
    } else {
        if (uVar5 != 0x7fff) {
            *(int32_t *)(unaff_EBP + -8) = ((int32_t)((uVar5 - 0x3fff) * 0x4d10) >> 0x10) + 1;
            Var10 = (unkfloat10)fcn.004033f0();
            Var10 = ROUND(Var10);
            Var2 = *(unkfloat10 *)(*(int32_t *)(unaff_EBP + -4) + 0x412824);
            *(uint16_t *)(unaff_EBP + -10) = (uint16_t)(Var2 < Var10) << 8 | (uint16_t)(Var2 == Var10) << 0xe;
            if ((*(uint16_t *)(unaff_EBP + -10) & 0x4100) != 0) {
                Var10 = Var10 / (unkfloat10)*(int32_t *)(*(int32_t *)(unaff_EBP + -4) + 0x412830);
                *(int32_t *)(unaff_EBP + -8) = *(int32_t *)(unaff_EBP + -8) + 1;
            }
            *(unkfloat10 *)(unaff_EBP + -0x18) = Var10;
            iVar7 = 9;
            piVar9 = (int16_t *)((int32_t)unaff_EBX + 3);
            do {
                uVar8 = *(uint8_t *)(iVar7 + -0x19 + unaff_EBP);
                piVar3 = piVar9 + 1;
                *piVar9 = (CONCAT11(uVar8, uVar8 >> 4) & 0xfff) + 0x3030;
                iVar7 = iVar7 + -1;
                piVar9 = piVar3;
            } while (iVar7 != 0);
            *(undefined *)piVar3 = 0;
            uVar5 = *(int32_t *)(unaff_EBP + -8) + *(int32_t *)(unaff_EBP + 8);
            if ((int32_t)uVar5 < 0) {
                uVar5 = 0;
                goto code_r0x00408ce0;
            }
            if (*(uint32_t *)(unaff_EBP + 0xc) <= uVar5) {
                uVar5 = *(uint32_t *)(unaff_EBP + 0xc);
            }
            if (uVar5 < 0x12) {
                if (*(uint8_t *)((int32_t)unaff_EBX + uVar5 + 3) < 0x35) goto code_r0x00408da2;
                do {
                    *(undefined *)((int32_t)unaff_EBX + uVar5 + 3) = 0;
                    if ((int32_t)(uVar5 - 1) < 0) {
                        *(undefined2 *)((int32_t)unaff_EBX + 3) = 0x31;
                        *(int32_t *)(unaff_EBP + -8) = *(int32_t *)(unaff_EBP + -8) + 1;
                        break;
                    }
                    pcVar1 = (char *)((int32_t)unaff_EBX + uVar5 + 2);
                    *pcVar1 = *pcVar1 + '\x01';
                    iVar7 = uVar5 + 2;
                    uVar5 = uVar5 - 1;
                } while (0x39 < *(uint8_t *)((int32_t)unaff_EBX + iVar7));
            } else {
                uVar5 = 0x12;
code_r0x00408da2:
                do {
                    *(undefined *)((int32_t)unaff_EBX + uVar5 + 3) = 0;
                    if ((int32_t)(uVar5 - 1) < 0) {
                        uVar8 = 0;
                        goto code_r0x00408db5;
                    }
                    iVar7 = uVar5 + 2;
                    uVar5 = uVar5 - 1;
                } while (*(char *)((int32_t)unaff_EBX + iVar7) == '0');
            }
            uVar8 = (uint8_t)((uint16_t)*(undefined2 *)(unaff_ESI + 2) >> 8);
code_r0x00408db5:
            uVar4 = (undefined2)*(undefined4 *)(unaff_EBP + -8);
            goto code_r0x00408db8;
        }
        if (((*(uint16_t *)((int32_t)unaff_ESI + 6) & 0x8000) != 0) &&
           ((*unaff_ESI != 0 || (unaff_ESI[1] != -0x80000000)))) {
            uVar5 = 0x8000;
            goto code_r0x00408ce0;
        }
    }
    uVar8 = (uint8_t)(uVar6 >> 8);
    uVar4 = (undefined2)uVar5;
    *(undefined *)((int32_t)unaff_EBX + 3) = 0;
code_r0x00408db8:
    *unaff_EBX = uVar4;
    *(uint8_t *)(unaff_EBX + 1) = uVar8 >> 7;
    return;
}


void fcn.004033f0(void)
{
    return;
}


// WARNING: [r2ghidra] Failed to match type LPWSTR for variable lpLCData to Decompiler type: Unknown type identifier
// LPWSTR

void __cdecl fcn.00408eb4(int32_t arg_8h)
{
    int32_t in_EAX;
    int32_t iVar1;
    undefined4 lpLCData;
    
    iVar1 = sub.kernel32.dll_GetLocaleInfoW_1();
    if (iVar1 < 1) {
        fcn.00404c98(in_EAX);
    } else {
        fcn.00404dd4();
    }
    return;
}


// WARNING: [r2ghidra] Failed to match type LPWSTR for variable lpLCData to Decompiler type: Unknown type identifier
// LPWSTR
// WARNING: [r2ghidra] Var arg_2000h is stack pointer based, which is not supported for decompilation.

void __cdecl fcn.00408f2c(int32_t arg_8h, undefined4 placeholder_1, int32_t arg_10h)
{
    int32_t var_4h;
    
    fcn.00408eb4(arg_8h);
    if (*(int32_t *)arg_8h == 0) {
        fcn.004063e4();
    }
    return;
}


undefined8 __fastcall fcn.00407f10(int32_t param_1, undefined4 param_2)
{
    undefined4 uVar1;
    
    uVar1 = fcn.004032ec();
    if (param_1 != 0) {
        uVar1 = param_2;
    }
    return CONCAT44(param_1, uVar1);
}


void __fastcall fcn.00404e04(undefined4 param_1, undefined4 param_2)
{
    fcn.00404dd4(param_2);
    return;
}


void fcn.00404ef4(void)
{
    return;
}


void __fastcall fcn.0040a3f8(undefined4 param_1, int32_t param_2)
{
    uint16_t uVar1;
    int32_t in_EAX;
    undefined4 *in_FS_OFFSET;
    undefined4 uStack28;
    undefined4 uStack24;
    undefined *puStack20;
    int32_t var_4h;
    
    puStack20 = (undefined *)0x40a40b;
    var_4h = in_EAX;
    fcn.00404c80();
    uStack24 = 0x40a47c;
    uStack28 = *in_FS_OFFSET;
    *in_FS_OFFSET = &uStack28;
    puStack20 = &stack0xfffffffc;
    if ((var_4h != 0) && (puStack20 = &stack0xfffffffc, *(int16_t *)(var_4h + -10) != 2)) {
        puStack20 = &stack0xfffffffc;
        var_4h = fcn.00404820();
    }
    uVar1 = *(uint16_t *)(var_4h + -2 + param_2 * 2);
    if ((0xd7ff < uVar1) && (uVar1 < 0xe000)) {
        fcn.00404d24();
        fcn.0040a3c8();
    }
    *in_FS_OFFSET = uStack28;
    puStack20 = (undefined *)0x40a483;
    uStack24 = 0x40a47b;
    fcn.00404c88();
    return;
}


undefined8 __fastcall fcn.00408164(uint32_t param_1, uint16_t *param_2)
{
    uint16_t uVar1;
    uint16_t *in_EAX;
    uint32_t uVar2;
    uint16_t uVar3;
    int32_t iStack16;
    
    uVar2 = 0;
    if (param_1 != 0) {
        do {
            uVar1 = *in_EAX;
            uVar3 = *param_2;
            if ((uint16_t)(uVar1 - 0x61) < 0x1a) {
                uVar1 = uVar1 ^ 0x20;
            }
            if ((uint16_t)(uVar3 - 0x61) < 0x1a) {
                uVar3 = uVar3 ^ 0x20;
            }
            if ((uVar3 != uVar1) || (uVar1 == 0)) {
                iStack16 = (uint32_t)uVar1 - (uint32_t)uVar3;
                goto code_r0x004081c6;
            }
            in_EAX = in_EAX + 1;
            param_2 = param_2 + 1;
            uVar2 = uVar2 + 1;
        } while (uVar2 < param_1);
    }
    iStack16 = 0;
code_r0x004081c6:
    return CONCAT44(iStack16, iStack16);
}


void fcn.004094b4(void)
{
    return;
}


void fcn.0040a48c(void)
{
    fcn.004081e8();
    return;
}


int16_t * __fastcall fcn.004081e8(undefined4 param_1, int16_t param_2)
{
    int16_t *in_EAX;
    int16_t *piVar1;
    int16_t *piVar2;
    
    if (param_2 == 0) {
        piVar1 = (int16_t *)fcn.004080fc();
    } else {
        piVar1 = (int16_t *)0x0;
        while( true ) {
            while (piVar2 = in_EAX, param_2 == *piVar2) {
                in_EAX = piVar2 + 1;
                piVar1 = piVar2;
            }
            if (*piVar2 == 0) break;
            in_EAX = piVar2 + 1;
        }
    }
    return piVar1;
}


undefined8 __fastcall fcn.00408128(uint32_t param_1)
{
    int32_t in_EAX;
    uint32_t uVar1;
    
    uVar1 = fcn.004080dc();
    if (param_1 < uVar1) {
        uVar1 = param_1;
    }
    fcn.00402fbc();
    *(undefined2 *)(in_EAX + uVar1 * 2) = 0;
    return CONCAT44(in_EAX, in_EAX);
}


// WARNING: [r2ghidra] Detected overlap for variable var_16h

void __cdecl fcn.00408290(int32_t arg_8h, int32_t arg_ch)
{
    int32_t in_EAX;
    int32_t iVar1;
    int32_t in_ECX;
    
    if ((in_EAX != 0) && (in_ECX != 0)) {
        iVar1 = fcn.004080dc();
        iVar1 = fcn.00408540(arg_8h, arg_ch, iVar1);
        *(undefined2 *)(in_EAX + iVar1 * 2) = 0;
    }
    return;
}


// WARNING: [r2ghidra] Failed to match type PMEMORY_BASIC_INFORMATION for variable lpBuffer to Decompiler type: Unknown
// type identifier PMEMORY_BASIC_INFORMATION
// WARNING: [r2ghidra] Failed to match type LPWSTR for variable lpFilename to Decompiler type: Unknown type identifier
// LPWSTR
// WARNING: [r2ghidra] Failed to match type HMODULE for variable hModule to Decompiler type: Unknown type identifier
// HMODULE

void __cdecl fcn.004094c0(int32_t arg_8h)
{
    char cVar1;
    int32_t iVar2;
    undefined4 uVar3;
    undefined4 *in_FS_OFFSET;
    undefined4 uStack1664;
    undefined4 uStack1660;
    undefined *puStack1656;
    int32_t var_664h;
    int32_t var_660h;
    int32_t var_65ch;
    int32_t var_658h;
    int32_t var_654h;
    int32_t var_650h;
    int32_t var_64ch;
    int32_t var_648h;
    int32_t var_644h;
    int32_t var_640h;
    int32_t var_63ch;
    undefined4 lpBuffer;
    undefined4 hModule;
    uint32_t var_628h;
    int32_t var_61ch;
    undefined4 lpFilename;
    int32_t var_212h;
    int32_t var_8h;
    int32_t var_4h;
    
    puStack1656 = &stack0xfffffffc;
    var_664h = 0;
    uStack1660 = 0x40966c;
    uStack1664 = *in_FS_OFFSET;
    *in_FS_OFFSET = &uStack1664;
    sub.kernel32.dll_VirtualQuery_1();
    if ((var_628h != 0x1000) || (iVar2 = sub.kernel32.dll_GetModuleFileNameW_1(hModule, &lpFilename, 0x105), iVar2 == 0)
       ) {
        hModule = *(undefined4 *)0x415b48;
        sub.kernel32.dll_GetModuleFileNameW_1();
        fcn.004094b4();
    }
    fcn.0040a48c(hModule);
    fcn.00408128();
    cVar1 = fcn.0040392c();
    if (cVar1 != '\0') {
        fcn.00404d24();
        fcn.004080dc();
    }
    uVar3 = fcn.00405b90(*(undefined4 *)(*(int32_t *)0x412c74 + 4), &var_61ch, 0x100);
    sub.user32.dll_LoadStringW_1(uVar3);
    fcn.00403814();
    var_660h = var_664h;
    uVar3 = 4;
    fcn.00408290(4, (int32_t)&var_660h);
    fcn.004080dc();
    *in_FS_OFFSET = uVar3;
    fcn.00404c88(0x409673);
    return;
}


void fcn.0040317c(void)
{
    fcn.00403134();
    return;
}


// WARNING: Removing unreachable block (ram,0x00402f41)
// WARNING: Removing unreachable block (ram,0x00402f46)

void __fastcall fcn.00402f6c(undefined4 param_1, undefined4 param_2)
{
    int32_t iVar1;
    
    iVar1 = fcn.00406588(param_1, param_2);
    if (*(int32_t *)(iVar1 + 4) != 0) {
        if (*(code **)0x413008 != (code *)0x0) {
            (**(code **)0x413008)();
        }
        fcn.00406588();
        fcn.00402f08();
        return;
    }
    return;
}


// WARNING: [r2ghidra] Failed to match type signed int for variable var_8h to Decompiler type: Unknown type identifier
// signed
// WARNING: [r2ghidra] Failed to match type signed int for variable var_10h to Decompiler type: Unknown type identifier
// signed
// WARNING: [r2ghidra] Failed to match type signed int for variable var_18h to Decompiler type: Unknown type identifier
// signed
// WARNING: [r2ghidra] Failed to match type signed int for variable var_1ch to Decompiler type: Unknown type identifier
// signed
// WARNING: [r2ghidra] Failed to match type signed int for variable var_14h to Decompiler type: Unknown type identifier
// signed

void fcn.00405ad8(void)
{
    fcn.00405940((int32_t)&stack0x00000004);
    return;
}


void fcn.0040ac74(void)
{
    undefined4 *in_EAX;
    
    *in_EAX = 0;
    fcn.00403894();
    return;
}


void fcn.00403884(void)
{
    char extraout_DL;
    
    fcn.00403a8c();
    if ('\0' < extraout_DL) {
        fcn.00403a34();
    }
    return;
}


void fcn.00409a2c(void)
{
    char cVar1;
    int32_t in_EAX;
    undefined4 uVar2;
    
    if (*(char *)(in_EAX + 0x14) != '\0') {
        fcn.00402e88();
        cVar1 = fcn.0040392c();
        if (cVar1 != '\0') {
            uVar2 = fcn.00402ec8();
            *(undefined4 *)(in_EAX + 0xc) = uVar2;
        }
    }
    return;
}


void __fastcall fcn.00409a54(undefined4 param_1, undefined4 param_2)
{
    int32_t in_EAX;
    
    *(undefined4 *)(in_EAX + 0x10) = param_2;
    return;
}


undefined4 fcn.00402f9c(void)
{
    undefined4 uVar1;
    int32_t iVar2;
    
    iVar2 = fcn.00406588();
    uVar1 = *(undefined4 *)(iVar2 + 4);
    iVar2 = fcn.00406588();
    *(undefined4 *)(iVar2 + 4) = 0;
    return uVar1;
}


void fcn.00409ae4(void)
{
    int32_t iVar1;
    int32_t iVar2;
    int32_t iStack16;
    undefined uStack12;
    
    iVar2 = 0;
    iVar1 = fcn.00402f9c();
    while ((iVar2 < 7 && (iVar1 != *(int32_t *)(iVar2 * 8 + 0x4128cc)))) {
        iVar2 = iVar2 + 1;
    }
    if (iVar2 < 7) {
        iVar2 = fcn.00409824();
    } else {
        uStack12 = 0;
        iStack16 = iVar1;
        iVar2 = fcn.0040991c(0, (int32_t)&iStack16);
    }
    *(int32_t *)(iVar2 + 0x18) = iVar1;
    return;
}


// WARNING: [r2ghidra] Var arg_10h is stack pointer based, which is not supported for decompilation.

void __cdecl fcn.00409860(int32_t arg_8h, int32_t arg_ch)
{
    char in_DL;
    int32_t **in_FS_OFFSET;
    int32_t *arg_8h_00;
    int32_t *piStack48;
    undefined4 uStack44;
    undefined *puStack40;
    int32_t var_4h;
    
    var_4h = 0;
    if (in_DL != '\0') {
        puStack40 = (undefined *)0x409874;
        fcn.004039e4();
    }
    uStack44 = 0x4098ba;
    piStack48 = *in_FS_OFFSET;
    *in_FS_OFFSET = (int32_t *)&piStack48;
    arg_8h_00 = &var_4h;
    puStack40 = &stack0xfffffffc;
    fcn.004082d4((int32_t)arg_8h_00);
    fcn.00404c98((int32_t)arg_8h_00);
    *in_FS_OFFSET = arg_8h_00;
    uStack44 = 0x4098c1;
    piStack48 = (int32_t *)0x4098b9;
    fcn.00404c88();
    return;
}


// WARNING: [r2ghidra] Var arg_2000h is stack pointer based, which is not supported for decompilation.

void fcn.00409bb4(void)
{
    int32_t in_EAX;
    int32_t *in_FS_OFFSET;
    int32_t arg_8h;
    int32_t *arg_ch;
    int32_t iStack60;
    undefined4 uStack56;
    undefined *puStack52;
    int32_t var_20h;
    int32_t var_1ch;
    int32_t var_18h;
    int32_t var_14h;
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    
    puStack52 = &stack0xfffffffc;
    var_20h = 0;
    uStack56 = 0x409c50;
    iStack60 = *in_FS_OFFSET;
    *in_FS_OFFSET = (int32_t)&iStack60;
    if (in_EAX == 0) {
        fcn.004063e4();
    } else {
        puStack52 = &stack0xfffffffc;
        fcn.00404cec();
    }
    var_1ch = 0;
    arg_ch = &var_1ch;
    arg_8h = 2;
    fcn.004063e4();
    fcn.00409860(arg_8h, (int32_t)arg_ch);
    *in_FS_OFFSET = arg_8h;
    iStack60 = 0x409c57;
    fcn.00404c88();
    fcn.00404c88();
    return;
}


// WARNING (jumptable): Stack frame is not setup normally: Input value of stackpointer is not used
// WARNING: Stack frame is not setup normally: Input value of stackpointer is not used

void __fastcall fcn.00409c60(undefined4 *param_1, undefined4 param_2)
{
    undefined4 uVar1;
    int32_t iVar2;
    int32_t in_EAX;
    undefined4 uVar3;
    code *pcVar4;
    undefined4 unaff_EBX;
    undefined4 *unaff_EBP;
    undefined4 unaff_ESI;
    undefined4 unaff_EDI;
    
    *param_1 = param_2;
    uVar1 = *unaff_EBP;
    if (in_EAX == 0) {
        param_1[-1] = 0x403f96;
        in_EAX = fcn.004046b8();
    }
    uVar3 = *param_1;
    *param_1 = param_1 + 1;
    param_1[-1] = uVar1;
    param_1[-2] = unaff_EDI;
    param_1[-3] = unaff_ESI;
    param_1[-4] = unaff_EBX;
    param_1[-5] = in_EAX;
    param_1[-6] = uVar3;
    param_1[-7] = param_1 + -6;
    param_1[-8] = 7;
    param_1[-9] = 1;
    param_1[-10] = 0xeedfade;
    param_1[-0xb] = uVar3;
    iVar2 = *(int32_t *)0x41301c;
    if (*(int32_t *)0x41301c != 0) {
        param_1[-0xc] = *param_1;
        param_1[-0xd] = param_1[-1];
        param_1[-0xe] = param_1[-2];
        param_1[-0xf] = param_1[-3];
        param_1[-0x10] = param_1[-4];
        param_1[-0x11] = param_1[-5];
        param_1[-0x12] = param_1[-6];
        param_1[-0x13] = 7;
        param_1[-0x14] = param_1[-6];
        param_1[-0x15] = param_1 + -6;
        param_1[-0x16] = iVar2;
        param_1[-0x17] = 0x403fd4;
        iVar2 = fcn.00402efc();
        pcVar4 = (code *)param_1[-0x16];
        if (iVar2 != 0) {
            iVar2 = *(int32_t *)(iVar2 + 0xc);
        }
        param_1[-0x15] = iVar2;
        param_1[-0x16] = 1;
        param_1[-0x17] = 0xeedfade;
        param_1[-0x18] = 0x403feb;
        (*pcVar4)();
    }
    // WARNING: Could not recover jumptable at 0x00403fee. Too many branches
    // WARNING: Treating indirect jump as call
    (**(code **)0x413014)();
    return;
}


undefined4 fcn.00409ca4(void)
{
    int32_t iVar1;
    int32_t *in_EAX;
    unkbyte3 Var3;
    int32_t iVar2;
    
    iVar1 = *in_EAX;
    Var3 = (unkbyte3)((uint32_t)iVar1 >> 8);
    if (iVar1 < -0x3fffff6d) {
        iVar2 = iVar1;
        if (iVar1 == -0x3fffff6e) {
code_r0x00409d08:
            return CONCAT31((unkint3)((uint32_t)iVar2 >> 8), 6);
        }
        if (iVar1 < -0x3fffff71) {
            if (iVar1 == -0x3fffff72) {
                return CONCAT31(Var3, 7);
            }
            if (iVar1 == -0x3ffffffb) {
                return 0xb;
            }
            if (iVar1 == -0x3fffff74) {
                return 4;
            }
            iVar2 = iVar1 + 0x3fffff73;
            if (iVar2 == 0) goto code_r0x00409d11;
        } else {
            iVar2 = iVar1 + 0x3fffff6f;
            if (iVar1 + 0x3fffff71U < 2) goto code_r0x00409d08;
            if (iVar2 == 0) {
                return 8;
            }
        }
    } else {
        if (iVar1 < -0x3fffff69) {
            if (iVar1 == -0x3fffff6a) {
                return CONCAT31(Var3, 0xc);
            }
            iVar2 = iVar1 + 0x3fffff6d;
            if (iVar2 == 0) {
code_r0x00409d11:
                return CONCAT31((unkint3)((uint32_t)iVar2 >> 8), 9);
            }
            if (iVar1 == -0x3fffff6c) {
                return 3;
            }
            iVar2 = iVar1 + 0x3fffff6b;
            if (iVar2 == 0) {
                return 5;
            }
        } else {
            if (iVar1 == -0x3fffff03) {
                return 0xe;
            }
            iVar2 = iVar1 + 0x3ffffec6;
            if (iVar2 == 0) {
                return 0xd;
            }
        }
    }
    return CONCAT31((unkint3)((uint32_t)iVar2 >> 8), 0x16);
}


void __fastcall fcn.00404e50(int32_t param_1, int16_t *param_2)
{
    int16_t iVar1;
    undefined4 uVar2;
    undefined4 *in_EAX;
    int16_t *piVar3;
    
    piVar3 = param_2;
    do {
        if (param_1 == 0) break;
        param_1 = param_1 + -1;
        iVar1 = *piVar3;
        piVar3 = piVar3 + 1;
    } while (iVar1 != 0);
    uVar2 = fcn.004054b4();
    if (param_2 != (int16_t *)0x0) {
        fcn.00402fbc();
    }
    fcn.004046c4();
    *in_EAX = uVar2;
    return;
}


void __fastcall fcn.00408028(undefined4 param_1, int32_t param_2)
{
    fcn.00407f4c();
    fcn.0040525c(param_2);
    return;
}


// WARNING: [r2ghidra] Failed to match type PMEMORY_BASIC_INFORMATION * for variable lpBuffer to Decompiler type:
// Unknown type identifier PMEMORY_BASIC_INFORMATION
// WARNING: [r2ghidra] Failed to match type LPWSTR for variable lpFilename to Decompiler type: Unknown type identifier
// LPWSTR
// WARNING: [r2ghidra] Failed to match type HMODULE for variable hModule to Decompiler type: Unknown type identifier
// HMODULE
// WARNING: [r2ghidra] Var arg_2000h is stack pointer based, which is not supported for decompilation.

void __cdecl fcn.00409d3c(int32_t arg_8h)
{
    int32_t iVar1;
    int32_t *in_FS_OFFSET;
    int32_t iVar2;
    int32_t *piVar3;
    int32_t iStack652;
    undefined4 uStack648;
    undefined *puStack644;
    int32_t var_274h;
    int32_t var_270h;
    int32_t var_26ch;
    int32_t var_268h;
    int32_t var_264h;
    int32_t var_260h;
    int32_t var_25ch;
    int32_t var_258h;
    int32_t var_254h;
    int32_t var_250h;
    int32_t var_24ch;
    int32_t var_248h;
    int32_t var_244h;
    int32_t var_240h;
    int32_t var_23ch;
    int32_t var_238h;
    int32_t var_234h;
    int32_t var_230h;
    undefined4 lpFilename;
    undefined4 lpBuffer;
    undefined4 hModule;
    uint32_t var_10h;
    int32_t var_4h;
    
    puStack644 = &stack0xfffffffc;
    var_274h = 0;
    uStack648 = 0x409ef7;
    iStack652 = *in_FS_OFFSET;
    *in_FS_OFFSET = (int32_t)&iStack652;
    iVar2 = *(int32_t *)(arg_8h + -4);
    if (*(int32_t *)(iVar2 + 0x14) == 0) {
        puStack644 = &stack0xfffffffc;
        fcn.004063e4();
    } else {
        fcn.004063e4();
    }
    sub.kernel32.dll_VirtualQuery_1(*(undefined4 *)(iVar2 + 0xc), &lpBuffer, 0x1c);
    if (var_10h == 0x1000) {
        iVar1 = sub.kernel32.dll_GetModuleFileNameW_1(hModule, &lpFilename, 0x105);
        if (iVar1 != 0) {
            var_24ch = *(int32_t *)(iVar2 + 0xc);
            fcn.00404e50();
            fcn.00408028();
            piVar3 = &var_24ch;
            iVar2 = 3;
            fcn.004063e4();
            fcn.00409860(iVar2, (int32_t)piVar3);
            goto code_r0x00409ec6;
        }
    }
    var_270h = *(int32_t *)(iVar2 + 0xc);
    piVar3 = &var_270h;
    iVar2 = 2;
    fcn.004063e4();
    fcn.00409860(iVar2, (int32_t)piVar3);
code_r0x00409ec6:
    *in_FS_OFFSET = iVar2;
    fcn.00404c88(0x409efe);
    fcn.00404c90();
    fcn.00404c88();
    return;
}


// WARNING: [r2ghidra] Failed to match type PMEMORY_BASIC_INFORMATION for variable lpBuffer to Decompiler type: Unknown
// type identifier PMEMORY_BASIC_INFORMATION
// WARNING: [r2ghidra] Failed to match type LPWSTR for variable lpFilename to Decompiler type: Unknown type identifier
// LPWSTR
// WARNING: [r2ghidra] Failed to match type HMODULE for variable hModule to Decompiler type: Unknown type identifier
// HMODULE

void fcn.004096ac(void)
{
    undefined4 uVar1;
    undefined4 uVar2;
    undefined4 *in_FS_OFFSET;
    undefined4 uVar3;
    undefined4 uStack2208;
    undefined4 uStack2204;
    undefined *puStack2200;
    int32_t var_888h;
    int32_t var_88h;
    int32_t var_8h;
    int32_t var_4h;
    
    puStack2200 = &stack0xfffffffc;
    uStack2204 = 0x4097d1;
    uStack2208 = *in_FS_OFFSET;
    *in_FS_OFFSET = &uStack2208;
    uVar1 = fcn.004094c0(0x400);
    if (**(char **)0x412c30 == '\0') {
        uVar1 = fcn.00405b90(*(undefined4 *)(*(int32_t *)0x412b4c + 4), &var_88h, 0x40);
        sub.user32.dll_LoadStringW_1(uVar1);
        uVar3 = 0;
        sub.user32.dll_MessageBoxW(0, &var_888h, &var_88h, 0x2010);
    } else {
        fcn.0040317c();
        fcn.00402f6c();
        uVar3 = 1;
        uVar2 = sub.kernel32.dll_WideCharToMultiByte_1(1, 0, &var_888h, uVar1, 0, 0, 0, 0);
        fcn.00405ad8(uVar2);
        sub.kernel32.dll_WideCharToMultiByte_1(1, 0, &var_888h, uVar1, 0, uVar2, 0, 0);
        uVar1 = sub.kernel32.dll_GetStdHandle_1(0xfffffff4, 0, uVar2, &var_8h, 0);
        sub.kernel32.dll_WriteFile_1(uVar1);
        uVar1 = sub.kernel32.dll_GetStdHandle_1(0xfffffff4, 0x4097ec, 2, &var_8h, 0);
        sub.kernel32.dll_WriteFile_1(uVar1);
    }
    *in_FS_OFFSET = uVar3;
    fcn.00405ae4(0x4097d8);
    return;
}


undefined4 fcn.00402ea8(void)
{
    int32_t *piVar1;
    
    piVar1 = (int32_t *)fcn.00406588();
    if (*piVar1 != 0) {
        piVar1 = (int32_t *)fcn.00406588();
        return *(undefined4 *)(*piVar1 + 4);
    }
    return 0;
}


void fcn.00409ffc(void)
{
    fcn.004096ac();
    fcn.004046ac();
    return;
}


void fcn.00406698(void)
{
    sub.kernel32.dll_InterlockedCompareExchange();
    return;
}


int32_t fcn.0040a168(void)
{
    int32_t iVar1;
    int32_t *in_EAX;
    int32_t iVar2;
    
    do {
        iVar1 = *in_EAX;
        if (iVar1 == 0) {
            return 0;
        }
        iVar2 = fcn.00406698();
    } while (iVar1 != iVar2);
    return iVar1;
}


void __fastcall fcn.0040a148(undefined4 param_1, int32_t *param_2)
{
    int32_t *in_EAX;
    int32_t iVar1;
    
    do {
        *param_2 = *in_EAX;
        iVar1 = fcn.00406698();
    } while (iVar1 != *param_2);
    return;
}


void fcn.0040a2c4(void)
{
    int32_t *piVar1;
    int32_t *in_EAX;
    
    if (in_EAX != (int32_t *)0x0) {
        do {
            piVar1 = (int32_t *)*in_EAX;
            if (in_EAX[1] != 0) {
                sub.kernel32.dll_CloseHandle_1(in_EAX[1]);
            }
            fcn.00402e20();
            in_EAX = piVar1;
        } while (piVar1 != (int32_t *)0x0);
    }
    return;
}


void __fastcall fcn.0040a2f4(undefined4 param_1, int32_t param_2)
{
    int32_t iVar1;
    
    if (-1 < param_2) {
        param_2 = param_2 + 1;
        do {
            do {
                iVar1 = sub.kernel32.dll_InterlockedCompareExchange();
            } while (iVar1 != 0);
            sub.kernel32.dll_CloseHandle_1();
            param_2 = param_2 + -1;
        } while (param_2 != 0);
    }
    return;
}


undefined4 fcn.0040a3c8(void)
{
    uint16_t *in_EAX;
    
    if ((((0xd7ff < *in_EAX) && (*in_EAX < 0xdc00)) && (0xdbff < in_EAX[1])) && (in_EAX[1] < 0xe000)) {
        return 4;
    }
    return 2;
}


// WARNING: Variable defined which should be unmapped: var_1h
// WARNING: Could not reconcile some variable overlaps

void __cdecl fcn.0040a494(int32_t arg_8h)
{
    uint8_t uVar1;
    uint8_t *puVar2;
    char cVar3;
    int32_t iVar4;
    int32_t var_1h;
    
    sub.kernel32.dll_GetCPInfo(0, arg_8h + -0x14);
    iVar4 = 0;
    while ((iVar4 < 0xc && ((*(uint8_t *)(arg_8h + -0xe + iVar4) | *(uint8_t *)(arg_8h + -0xd + iVar4)) != 0))) {
        var_1h._0_1_ = *(uint8_t *)(arg_8h + -0xe + iVar4);
        uVar1 = *(uint8_t *)(arg_8h + -0xd + iVar4);
        if ((uint8_t)var_1h <= uVar1) {
            cVar3 = (uVar1 - (uint8_t)var_1h) + '\x01';
            do {
                puVar2 = (uint8_t *)(((int32_t)(uint32_t)(uint8_t)var_1h >> 3) + 0x4127ec);
                *puVar2 = *puVar2 | '\x01' << ((uint8_t)var_1h & 7);
                var_1h._0_1_ = (uint8_t)var_1h + 1;
                cVar3 = cVar3 + -1;
            } while (cVar3 != '\0');
        }
        iVar4 = iVar4 + 2;
    }
    return;
}


void fcn.0040a4f0(void)
{
    uint32_t uVar1;
    int32_t iVar2;
    undefined4 *puVar3;
    undefined4 *puVar4;
    
    *(uint32_t *)0x415c30 = 0x409;
    *(uint32_t *)0x415c34 = 9;
    *(uint32_t *)0x415c38 = 1;
    uVar1 = sub.kernel32.dll_GetThreadLocale_1();
    if (uVar1 != 0) {
        *(uint32_t *)0x415c30 = uVar1;
    }
    if ((uint16_t)uVar1 != 0) {
        *(uint32_t *)0x415c34 = (uint32_t)((uint16_t)uVar1 & 0x3ff);
        *(uint32_t *)0x415c38 = (uVar1 & 0xffff) >> 10;
    }
    iVar2 = 8;
    puVar3 = (undefined4 *)0x40a588;
    puVar4 = (undefined4 *)0x4127ec;
    while (iVar2 != 0) {
        iVar2 = iVar2 + -1;
        *puVar4 = *puVar3;
        puVar3 = puVar3 + 1;
        puVar4 = puVar4 + 1;
    }
    if ((*(int32_t *)0x4127dc < 5) || (*(int32_t *)0x4127d8 != 2)) {
        iVar2 = sub.user32.dll_GetSystemMetrics(0x4a);
        *(bool *)0x415c3d = iVar2 != 0;
    } else {
        *(bool *)0x415c3d = true;
    }
    *(undefined *)0x415c3c = 1;
    fcn.0040a494((int32_t)&stack0xfffffffc);
    return;
}


// WARNING: [r2ghidra] Failed to match type LCID for variable var_4h to Decompiler type: Unknown type identifier LCID

void fcn.00408f68(void)
{
    int32_t iVar1;
    int32_t *in_FS_OFFSET;
    int32_t iVar2;
    int32_t arg_8h;
    undefined4 uStack48;
    undefined *puStack44;
    int32_t var_18h;
    int32_t var_14h;
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_8h;
    undefined4 var_4h;
    
    puStack44 = &stack0xfffffffc;
    var_ch = 0;
    var_10h = 0;
    var_14h = 0;
    var_18h = 0;
    uStack48 = 0x40907b;
    arg_8h = *in_FS_OFFSET;
    *in_FS_OFFSET = (int32_t)&stack0xffffffcc;
    sub.kernel32.dll_GetThreadLocale_1();
    iVar1 = 1;
    do {
        iVar2 = 0xb;
        fcn.00408f2c((int32_t)&var_ch, 0xb, (int32_t)&stack0xfffffffc);
        fcn.00404c98(iVar2);
        fcn.00408f2c((int32_t)&var_10h, 0xb, (int32_t)&stack0xfffffffc);
        fcn.00404c98(arg_8h);
        iVar1 = iVar1 + 1;
    } while (iVar1 != 0xd);
    iVar1 = 1;
    do {
        iVar2 = 6;
        fcn.00408f2c((int32_t)&var_14h, 6, (int32_t)&stack0xfffffffc);
        fcn.00404c98(iVar2);
        fcn.00408f2c((int32_t)&var_18h, 6, (int32_t)&stack0xfffffffc);
        fcn.00404c98(arg_8h);
        iVar1 = iVar1 + 1;
    } while (iVar1 != 8);
    *in_FS_OFFSET = arg_8h;
    fcn.00404c90(0x409082);
    return;
}


// WARNING: [r2ghidra] Failed to match type LPWSTR for variable lpLCData to Decompiler type: Unknown type identifier
// LPWSTR

void fcn.00409140(void)
{
    int32_t iVar1;
    undefined4 uVar2;
    undefined4 *puVar3;
    int32_t iVar4;
    undefined4 *in_FS_OFFSET;
    undefined4 in_stack_ffffffc4;
    int32_t *arg_8h;
    undefined4 uStack24;
    undefined4 uStack20;
    undefined *puStack16;
    int32_t var_4h;
    
    puStack16 = &stack0xfffffffc;
    var_4h = 0;
    uStack20 = 0x4091d7;
    uStack24 = *in_FS_OFFSET;
    *in_FS_OFFSET = &uStack24;
    arg_8h = &var_4h;
    sub.kernel32.dll_GetThreadLocale_1();
    fcn.00408eb4((int32_t)arg_8h);
    iVar1 = fcn.00407f10();
    if (iVar1 - 3U < 3) {
        uVar2 = sub.kernel32.dll_GetThreadLocale_1(iVar1, 4);
        sub.kernel32.dll_EnumCalendarInfoW(0x40908c, uVar2);
        iVar4 = 7;
        puVar3 = (undefined4 *)0x415c5c;
        do {
            *puVar3 = 0xffffffff;
            puVar3 = puVar3 + 1;
            iVar4 = iVar4 + -1;
        } while (iVar4 != 0);
        uVar2 = sub.kernel32.dll_GetThreadLocale_1(iVar1, 3);
        in_stack_ffffffc4 = 0x4090c8;
        sub.kernel32.dll_EnumCalendarInfoW(0x4090c8, uVar2);
    }
    *in_FS_OFFSET = in_stack_ffffffc4;
    fcn.00404c88(0x4091de);
    return;
}


// WARNING: [r2ghidra] Failed to match type LPWSTR for variable lpLCData to Decompiler type: Unknown type identifier
// LPWSTR

undefined8 __fastcall fcn.00408f00(uint32_t param_1)
{
    uint32_t in_EAX;
    int32_t iVar1;
    
    iVar1 = sub.kernel32.dll_GetLocaleInfoW_1();
    if (0 < iVar1) {
        param_1 = in_EAX & 0xffff;
    }
    return CONCAT44(in_EAX, param_1);
}


// WARNING: [r2ghidra] Failed to match type LPWSTR for variable lpLCData to Decompiler type: Unknown type identifier
// LPWSTR

void fcn.004091f4(void)
{
    int16_t iVar1;
    bool bVar2;
    int32_t in_EAX;
    int32_t iVar3;
    uint32_t uVar4;
    int32_t iVar5;
    int32_t **in_FS_OFFSET;
    int32_t *piVar6;
    undefined4 uStack48;
    undefined *puStack44;
    int32_t var_18h;
    int32_t var_14h;
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    
    var_ch = 0;
    var_14h = 0;
    var_18h = 0;
    puStack44 = (undefined *)0x40920f;
    fcn.00404c80();
    uStack48 = 0x409427;
    piVar6 = *in_FS_OFFSET;
    *in_FS_OFFSET = (int32_t *)&stack0xffffffcc;
    iVar5 = 1;
    puStack44 = &stack0xfffffffc;
    fcn.00404c98((int32_t)piVar6);
    piVar6 = &var_ch;
    sub.kernel32.dll_GetThreadLocale_1();
    fcn.00408eb4((int32_t)piVar6);
    iVar3 = fcn.00407f10();
    if (iVar3 - 3U < 3) {
        while( true ) {
            fcn.00404830();
            iVar3 = fcn.00404ef4();
            if (iVar3 < iVar5) break;
            iVar3 = in_EAX;
            if ((in_EAX != 0) && (*(int16_t *)(in_EAX + -10) != 2)) {
                iVar3 = fcn.00404820();
            }
            if ((*(uint16_t *)(iVar3 + -2 + iVar5 * 2) < 0xd800) || (0xdfff < *(uint16_t *)(iVar3 + -2 + iVar5 * 2))) {
                iVar3 = fcn.00408164();
                if (iVar3 == 0) {
                    fcn.00404f98();
                    iVar5 = iVar5 + 1;
                } else {
                    iVar3 = fcn.00408164();
                    if (iVar3 == 0) {
                        fcn.00404f98();
                        iVar5 = iVar5 + 3;
                    } else {
                        iVar3 = fcn.00408164();
                        if (iVar3 == 0) {
                            fcn.00404f98();
                            iVar5 = iVar5 + 1;
                        } else {
                            iVar1 = *(int16_t *)(in_EAX + -2 + iVar5 * 2);
                            if ((iVar1 == 0x59) || (iVar1 == 0x79)) {
                                fcn.00404f98();
                            } else {
                                fcn.00404e04();
                                fcn.00404f98();
                            }
                        }
                    }
                }
                iVar5 = iVar5 + 1;
            } else {
                uVar4 = fcn.0040a3f8();
                iVar3 = (int32_t)uVar4 >> 1;
                if (iVar3 < 0) {
                    iVar3 = iVar3 + (uint32_t)((uVar4 & 1) != 0);
                }
                piVar6 = &var_14h;
                fcn.0040525c((int32_t)piVar6);
                fcn.00404f98();
                iVar5 = iVar5 + iVar3;
            }
        }
    } else {
        if ((*(int32_t *)0x415c34 == 4) || (*(int32_t *)0x415c34 - 0x11U < 2)) {
            bVar2 = true;
        } else {
            bVar2 = false;
        }
        if (bVar2) {
            while( true ) {
                fcn.00404830();
                iVar3 = fcn.00404ef4();
                if (iVar3 < iVar5) break;
                iVar1 = *(int16_t *)(in_EAX + -2 + iVar5 * 2);
                if ((iVar1 != 0x47) && (iVar1 != 0x67)) {
                    fcn.00404e04();
                    fcn.00404f98();
                }
                iVar5 = iVar5 + 1;
            }
        } else {
            fcn.00404c98((int32_t)piVar6);
        }
    }
    *in_FS_OFFSET = piVar6;
    uStack48 = 0x40942e;
    fcn.00404c90();
    fcn.00404c88();
    return;
}


int32_t fcn.00405918(void)
{
    int32_t iVar1;
    
    iVar1 = fcn.00405910();
    return iVar1 + -1;
}


uint32_t fcn.0040aa7c(void)
{
    undefined4 *puVar1;
    uint8_t *in_EAX;
    uint32_t uVar2;
    uint32_t uVar3;
    int32_t iVar4;
    uint8_t uVar5;
    undefined *puStack592;
    uint32_t uStack588;
    undefined4 uStack584;
    undefined4 uStack580;
    undefined4 uStack572;
    undefined *puStack568;
    uint32_t uStack564;
    undefined4 uStack560;
    undefined4 uStack556;
    undefined4 uStack548;
    undefined4 uStack544;
    undefined4 uStack540;
    
    uVar2 = 0;
    while( true ) {
        uVar3 = uVar2 << 5 | uVar2 >> 0x1b;
        uVar5 = *in_EAX;
        if ((uVar5 & 0x80) != 0) {
            uStack540 = 0x40a9fb;
            uStack572 = fcn.00404914();
            uStack540 = 0;
            uStack544 = 0;
            uStack556 = 0;
            puVar1 = &uStack560;
            uStack560 = 0xfde9;
            uStack564 = 0x40aa0f;
            uStack548 = uStack572;
            uVar2 = sub.kernel32.dll_MultiByteToWideChar_1();
            if (0x104 < uVar2) {
                uStack564 = 0x40aa22;
                puVar1 = (undefined4 *)fcn.00402e04();
            }
            uStack580 = 0;
            uStack584 = 0xfde9;
            uStack588 = 0x40aa38;
            puStack568 = (undefined *)puVar1;
            uStack564 = uVar2;
            sub.kernel32.dll_MultiByteToWideChar_1();
            puStack592 = (undefined *)puVar1;
            uStack588 = uVar2;
            sub.user32.dll_CharUpperBuffW();
            uVar3 = 0;
            if (-1 < (int32_t)(uVar2 - 1)) {
                iVar4 = 0;
                do {
                    uVar3 = (uVar3 << 5 | uVar3 >> 0x1b) ^ (uint32_t)*(uint16_t *)((int32_t)puVar1 + iVar4 * 2);
                    iVar4 = iVar4 + 1;
                    uVar2 = uVar2 - 1;
                } while (uVar2 != 0);
            }
            if ((undefined **)puVar1 != &puStack592) {
                fcn.00402e20();
            }
            return uVar3;
        }
        if (uVar5 == 0) break;
        if (('@' < (char)uVar5) && ((char)uVar5 < '[')) {
            uVar5 = uVar5 | 0x20;
        }
        uVar2 = uVar2 << 5 & 0xffffff00 | (uint32_t)(uint8_t)((uint8_t)uVar3 ^ uVar5);
        in_EAX = in_EAX + 1;
    }
    return uVar3;
}


void fcn.004058d4(void)
{
    fcn.00405658();
    fcn.00402e20();
    return;
}


void fcn.0040ad38(void)
{
    *(undefined4 *)0x415c88 = 0;
    fcn.00403894();
    *(undefined4 *)0x415c80 = 0;
    fcn.00403894();
    *(undefined4 *)0x415c90 = 0;
    fcn.00403894();
    *(undefined4 *)0x415c94 = 0;
    fcn.00403894();
    *(undefined4 *)0x415c8c = 0;
    fcn.00403894();
    *(undefined4 *)0x415c84 = 0;
    fcn.00403894();
    return;
}


void fcn.00406134(void)
{
    int32_t **ppiVar1;
    int32_t *in_EAX;
    int32_t **ppiVar2;
    
    if ((*(int32_t ***)0x412030 == (int32_t **)0x0) || ((*(int32_t ***)0x412030)[1] != in_EAX)) {
        ppiVar2 = *(int32_t ***)0x412030;
        if (*(int32_t ***)0x412030 != (int32_t **)0x0) {
            do {
                ppiVar1 = (int32_t **)*ppiVar2;
                if ((ppiVar1 != (int32_t **)0x0) && (ppiVar1[1] == in_EAX)) {
                    *ppiVar2 = *ppiVar1;
                    fcn.00402e20();
                    return;
                }
                ppiVar2 = (int32_t **)*ppiVar2;
            } while (ppiVar2 != (int32_t **)0x0);
        }
    } else {
        *(int32_t ***)0x412030 = (int32_t **)**(int32_t ***)0x412030;
        fcn.00402e20();
    }
    return;
}


void fcn.0040ad08(void)
{
    undefined4 *puVar1;
    
    puVar1 = (undefined4 *)**(undefined4 **)0x412c4c;
    while (puVar1 != (undefined4 *)0x0) {
        if (puVar1[5] != 0) {
            fcn.004058d4();
            puVar1[5] = 0;
        }
        puVar1 = (undefined4 *)*puVar1;
    }
    return;
}


void fcn.0040abd4(void)
{
    while (*(undefined4 **)0x4129d8 != (undefined4 *)0x0) {
        *(undefined4 **)0x4129d8 = (undefined4 *)**(undefined4 **)0x4129d8;
        fcn.00402e20();
    }
    return;
}


void fcn.0040a320(void)
{
    sub.kernel32.dll_InterlockedExchange(0x415da4, 0);
    fcn.0040a2c4();
    sub.kernel32.dll_InterlockedExchange(0x415da8, 0);
    fcn.0040a2c4();
    fcn.0040a2f4();
    return;
}


void fcn.0040a09c(void)
{
    char cVar1;
    int32_t iVar2;
    undefined4 uVar3;
    
    if (*(int32_t **)0x415c9c != (int32_t *)0x0) {
        *(undefined *)(*(int32_t **)0x415c9c + 6) = 1;
        (**(code **)(**(int32_t **)0x415c9c + -8))();
        *(int32_t **)0x415c9c = (int32_t *)0x0;
    }
    if (*(int32_t *)0x415ca0 != 0) {
        *(undefined *)(*(int32_t *)0x415ca0 + 0x18) = 1;
        fcn.00403894();
        *(int32_t *)0x415ca0 = 0;
    }
    **(undefined4 **)0x412b24 = 0;
    **(undefined4 **)0x412b80 = 0;
    **(undefined4 **)0x412b44 = 0;
    **(undefined4 **)0x412b74 = 0;
    **(undefined4 **)0x412b84 = 0;
    **(undefined4 **)0x412c00 = 0;
    iVar2 = fcn.00402e88();
    if (iVar2 != 0) {
        fcn.00402e88();
        cVar1 = fcn.0040392c();
        if (cVar1 == '\0') {
            uVar3 = fcn.00402ea8();
            fcn.00402e88(uVar3);
            fcn.00409ffc();
        }
    }
    return;
}


int32_t fcn.0040b58c(void)
{
    int32_t iVar1;
    int32_t in_EAX;
    int32_t iVar2;
    int32_t iVar3;
    int32_t iVar4;
    
    iVar2 = in_EAX;
    if (in_EAX != 0) {
        iVar2 = *(int32_t *)(in_EAX + -4);
    }
    iVar3 = fcn.0040b4b4();
    iVar1 = 0;
    iVar3 = iVar3 + 1;
    while (iVar3 <= iVar2) {
        if (*(int16_t *)(in_EAX + -2 + iVar3 * 2) == 0x2e) {
            iVar1 = iVar3;
            iVar3 = iVar3 + 1;
        } else {
            iVar4 = fcn.0040b32c();
            iVar3 = iVar3 + iVar4;
        }
    }
    return iVar1;
}


undefined4 fcn.0040b32c(void)
{
    return 1;
}


uint64_t __fastcall fcn.0040b3cc(undefined4 param_1, char param_2)
{
    char cVar1;
    int32_t in_EAX;
    int32_t iVar2;
    int32_t iVar3;
    int32_t iVar4;
    int32_t iVar5;
    
    iVar2 = in_EAX;
    if (in_EAX != 0) {
        iVar2 = *(int32_t *)(in_EAX + -4);
    }
    if (((iVar2 < 2) || (cVar1 = fcn.0040b334(), cVar1 == '\0')) || (cVar1 = fcn.0040b334(), cVar1 == '\0')) {
        if ((iVar2 < 1) || (cVar1 = fcn.0040b334(), cVar1 == '\0')) {
            if (0 < iVar2) {
                iVar5 = fcn.0040b32c();
                iVar4 = iVar5 + 1;
                if ((iVar4 <= iVar2) && (*(int16_t *)(in_EAX + -2 + iVar4 * 2) == 0x3a)) {
                    if ((param_2 != '\0') && ((iVar4 < iVar2 && (cVar1 = fcn.0040b334(), cVar1 != '\0')))) {
                        iVar4 = iVar5 + 2;
                    }
                    goto code_r0x0040b4ac;
                }
            }
            iVar4 = 0;
        } else {
            if (param_2 == '\0') {
                iVar4 = 0;
            } else {
                iVar4 = 1;
            }
        }
    } else {
        iVar4 = 3;
        iVar5 = 0;
        if (2 < iVar2) {
            do {
                cVar1 = fcn.0040b334();
                if (cVar1 == '\0') {
                    iVar3 = fcn.0040b32c();
                    iVar4 = iVar4 + iVar3;
                } else {
                    iVar5 = iVar5 + 1;
                    if (1 < iVar5) break;
                    do {
                        iVar4 = iVar4 + 1;
                        if (iVar2 < iVar4) break;
                        cVar1 = fcn.0040b334();
                    } while (cVar1 != '\0');
                }
            } while (iVar4 <= iVar2);
        }
        iVar4 = iVar4 + -1;
    }
code_r0x0040b4ac:
    return (uint64_t)CONCAT14(param_2, iVar4);
}


void __fastcall fcn.0040b62c(undefined4 param_1, int32_t param_2)
{
    char cVar1;
    int32_t in_EAX;
    int32_t iVar2;
    int32_t iVar3;
    int32_t unaff_EBP;
    
    iVar2 = fcn.0040b3cc();
    iVar3 = in_EAX;
    if (in_EAX != 0) {
        iVar3 = *(int32_t *)(in_EAX + -4);
    }
    while (iVar2 < iVar3) {
        fcn.0040b620();
        cVar1 = fcn.0040b334();
        if (cVar1 == '\0') break;
        iVar3 = iVar3 + -1;
    }
    if (in_EAX != 0) {
        in_EAX = *(int32_t *)(in_EAX + -4);
    }
    if (in_EAX == iVar3) {
        fcn.00404c98(unaff_EBP);
    } else {
        fcn.0040525c(param_2);
    }
    return;
}


void fcn.0040b698(void)
{
    undefined4 uVar1;
    undefined4 *in_FS_OFFSET;
    undefined4 uStack24;
    undefined4 uStack20;
    undefined *puStack16;
    int32_t var_4h;
    
    puStack16 = &stack0xfffffffc;
    var_4h = 0;
    uStack20 = 0x40b6de;
    uStack24 = *in_FS_OFFSET;
    *in_FS_OFFSET = &uStack24;
    fcn.0040b62c();
    uVar1 = fcn.00404d24();
    sub.kernel32.dll_GetFileAttributesW();
    *in_FS_OFFSET = uVar1;
    uStack20 = 0x40b6e5;
    uStack24 = 0x40b6dd;
    fcn.00404c88();
    return;
}


undefined8 __fastcall fcn.0040bb10(undefined4 param_1, int32_t param_2)
{
    int32_t iVar1;
    int32_t *in_EAX;
    int32_t iVar2;
    uint32_t unaff_EBX;
    
    iVar1 = *in_EAX;
    iVar2 = iVar1;
    if (iVar1 != 0) {
        iVar2 = *(int32_t *)(iVar1 + -4);
    }
    fcn.00404f00();
    return CONCAT44(iVar1, unaff_EBX & 0xffffff00 | (uint32_t)(param_2 < iVar2));
}


void __fastcall fcn.0040b770(int32_t *param_1, int32_t param_2)
{
    uint16_t uVar1;
    uint8_t uVar2;
    uint16_t *in_EAX;
    uint32_t var_4h;
    
    *param_1 = 0;
    uVar2 = 0;
    while ((uVar1 = *in_EAX, uVar1 != 0 && ((bool)(0x20 < uVar1 | uVar2)))) {
        if (uVar1 == 0x22) {
            uVar2 = uVar2 ^ 1;
        } else {
            if (param_2 != 0) {
                *(uint16_t *)(param_2 + *param_1 * 2) = uVar1;
            }
            *param_1 = *param_1 + 1;
        }
        in_EAX = in_EAX + 1;
    }
    return;
}


int32_t fcn.004054ac(void)
{
    int32_t *piVar1;
    int32_t iVar2;
    int32_t *in_EAX;
    int32_t iVar3;
    
    iVar3 = *in_EAX;
    if (iVar3 != 0) {
        if (*(int16_t *)(iVar3 + -10) != 2) {
            fcn.00404818();
            iVar3 = *in_EAX;
        }
        if (*(int32_t *)(iVar3 + -8) != 1) {
            iVar2 = fcn.004054b4();
            iVar3 = *in_EAX;
            *in_EAX = iVar2;
            fcn.00402fbc();
            if (0 < *(int32_t *)(iVar3 + -8)) {
                LOCK();
                piVar1 = (int32_t *)(iVar3 + -8);
                *piVar1 = *piVar1 + -1;
                if (*piVar1 == 0) {
                    fcn.00402e20();
                }
            }
            iVar3 = *in_EAX;
        }
    }
    return iVar3;
}


void __fastcall fcn.0040b710(undefined4 param_1, int32_t *param_2)
{
    char cVar1;
    undefined4 uVar2;
    int32_t iVar3;
    int32_t iVar4;
    
    fcn.00404f00(param_1);
    while( true ) {
        iVar3 = *param_2;
        if (iVar3 != 0) {
            iVar3 = *(int32_t *)(iVar3 + -4);
        }
        uVar2 = fcn.00404d24(iVar3);
        iVar3 = fcn.00404d24(uVar2);
        iVar4 = sub.kernel32.dll_GetEnvironmentVariableW();
        if (iVar4 == 0) break;
        cVar1 = fcn.0040bb10();
        if (cVar1 != '\0') {
            return;
        }
    }
    fcn.00404c98(iVar3);
    return;
}


undefined4 fcn.0040b6ec(void)
{
    uint32_t uVar1;
    
    uVar1 = fcn.0040b698();
    if ((uVar1 != 0xffffffff) && ((uVar1 & 0x10) != 0)) {
        return 1;
    }
    return 0;
}


// WARNING: [r2ghidra] Failed to match type LPWSTR for variable lpBuffer to Decompiler type: Unknown type identifier
// LPWSTR

void fcn.0040b9a4(void)
{
    undefined auStack524 [520];
    
    sub.kernel32.dll_GetWindowsDirectoryW(auStack524, 0x104);
    fcn.00408218();
    return;
}


// WARNING: [r2ghidra] Var arg_2000h is stack pointer based, which is not supported for decompilation.

void fcn.0040b524(void)
{
    int32_t iVar1;
    int32_t iVar2;
    undefined auStack4108 [4092];
    int32_t iStack16;
    
    iVar1 = 2;
    do {
        iStack16 = iVar1;
        iVar1 = iStack16 + -1;
    } while (iStack16 + -1 != 0);
    iVar1 = fcn.00404d24(0x1000, auStack4108, &iStack16);
    iVar2 = sub.kernel32.dll_GetFullPathNameW();
    if ((iVar2 < 1) || (0xfff < iVar2)) {
        fcn.00404c98(iVar1);
    } else {
        fcn.00404dd4();
    }
    return;
}


void fcn.00409818(void)
{
    fcn.00403f88();
    return;
}


// WARNING: [r2ghidra] Failed to match type LPCWSTR for variable lpValueName to Decompiler type: Unknown type identifier
// LPCWSTR

void __cdecl fcn.0040bb34(uint32_t arg_8h, uint32_t arg_ch)
{
    int32_t in_EAX;
    int32_t iVar1;
    int32_t iVar2;
    uint32_t uVar3;
    int32_t *in_FS_OFFSET;
    int32_t arg_8h_00;
    uint32_t *puVar4;
    undefined4 uVar5;
    undefined4 uStack44;
    undefined *puStack40;
    uint32_t var_14h;
    uint32_t var_10h;
    int32_t var_ch;
    undefined4 lpValueName;
    int32_t var_4h;
    
    puStack40 = &stack0xfffffffc;
    uStack44 = 0x40bc6c;
    *in_FS_OFFSET = (int32_t)&stack0xffffffd0;
    while( true ) {
        var_14h = 0;
        uVar5 = 0;
        puVar4 = &var_10h;
        arg_8h_00 = in_EAX;
        iVar1 = sub.advapi32.dll_RegQueryValueExW_1();
        if ((iVar1 != 0) || ((var_10h != arg_ch && (var_10h != arg_8h)))) goto code_r0x0040bc56;
        if (var_14h == 0) break;
        if (0x6fffffff < var_14h) {
            fcn.00409818();
        }
        fcn.00404dd4();
        fcn.004054ac(&var_14h);
        iVar1 = in_EAX;
        iVar2 = sub.advapi32.dll_RegQueryValueExW_1();
        if (iVar2 != 0xea) {
            if ((iVar2 == 0) && ((var_10h == arg_ch || (var_10h == arg_8h)))) {
                uVar3 = var_14h >> 1;
                while ((uVar3 != 0 && (*(int16_t *)(uVar3 * 2 + -2) == 0))) {
                    uVar3 = uVar3 - 1;
                }
                if ((var_10h == 7) && (uVar3 != 0)) {
                    uVar3 = uVar3 + 1;
                }
                fcn.00404f00();
                if ((var_10h == 7) && (uVar3 != 0)) {
                    iVar2 = fcn.004054ac();
                    *(undefined2 *)(iVar2 + -2 + uVar3 * 2) = 0;
                }
                fcn.00404c98(iVar1);
            }
code_r0x0040bc56:
            *in_FS_OFFSET = arg_8h_00;
            fcn.00404c88(0x40bc73, puVar4, uVar5);
            return;
        }
    }
    fcn.00404c98(arg_8h_00);
    goto code_r0x0040bc56;
}


// WARNING: [r2ghidra] Failed to match type PHKEY for variable phkResult to Decompiler type: Unknown type identifier
// PHKEY
// WARNING: [r2ghidra] Failed to match type DWORD for variable ulOptions to Decompiler type: Unknown type identifier
// DWORD

void __cdecl fcn.0040bc8c(undefined4 phkResult, int32_t arg_ch, undefined4 ulOptions)
{
    sub.advapi32.dll_RegOpenKeyExW_1();
    return;
}


// WARNING: [r2ghidra] Failed to match type LPCWSTR for variable lpValueName to Decompiler type: Unknown type identifier
// LPCWSTR

void fcn.0040bc80(void)
{
    fcn.0040bb34(2, 1);
    return;
}


// WARNING: [r2ghidra] Var arg_10h is stack pointer based, which is not supported for decompilation.

void __fastcall fcn.00403864(undefined4 param_1, char param_2)
{
    char extraout_DL;
    undefined4 *in_FS_OFFSET;
    undefined4 unaff_retaddr;
    
    if (param_2 != '\0') {
        fcn.004039e4();
        param_2 = extraout_DL;
    }
    if (param_2 != '\0') {
        fcn.00403a3c();
        *in_FS_OFFSET = unaff_retaddr;
    }
    return;
}


void fcn.0040c6b0(void)
{
    uint32_t uVar1;
    uint32_t *puVar2;
    int32_t iVar3;
    uint32_t uVar4;
    
    uVar4 = 0;
    puVar2 = (uint32_t *)0x417d9c;
    do {
        iVar3 = 8;
        uVar1 = uVar4;
        do {
            if ((uVar1 & 1) == 0) {
                uVar1 = uVar1 >> 1;
            } else {
                uVar1 = uVar1 >> 1 ^ 0xedb88320;
            }
            iVar3 = iVar3 + -1;
        } while (iVar3 != 0);
        *puVar2 = uVar1;
        uVar4 = uVar4 + 1;
        puVar2 = puVar2 + 1;
    } while (uVar4 != 0x100);
    return;
}


uint32_t __fastcall fcn.0040b2d4(undefined4 param_1, uint32_t param_2)
{
    uint32_t uVar1;
    uint32_t uVar2;
    uint32_t *in_EAX;
    
    uVar1 = *in_EAX;
    *in_EAX = *in_EAX + param_2;
    uVar2 = in_EAX[1];
    in_EAX[1] = uVar2 + CARRY4(uVar1, param_2);
    return (uint32_t)in_EAX & 0xffffff00 | (uint32_t)!CARRY4(uVar2, (uint32_t)CARRY4(uVar1, param_2));
}


undefined4 __fastcall fcn.0040b2b4(undefined4 param_1, uint32_t *param_2)
{
    uint32_t uVar1;
    uint32_t *in_EAX;
    bool bVar2;
    
    uVar1 = in_EAX[1];
    bVar2 = param_2[1] <= uVar1;
    if (bVar2 && uVar1 != param_2[1]) {
        return 1;
    }
    if (bVar2) {
        uVar1 = *in_EAX;
        if (*param_2 <= uVar1 && uVar1 != *param_2) {
            return 1;
        }
        if (*param_2 <= uVar1) {
            return 0;
        }
    }
    return 0xffffffff;
}


void __fastcall fcn.0040ca08(int32_t param_1)
{
    int32_t in_EAX;
    int32_t iVar1;
    uint32_t uVar2;
    
    if (*(uint32_t *)(in_EAX + 0xc) < 5) {
        fcn.00409824();
        fcn.00403f88();
    }
    fcn.0040c1f8();
    *(int32_t *)(in_EAX + 0xc) = *(int32_t *)(in_EAX + 0xc) + -4;
    uVar2 = *(uint32_t *)(in_EAX + 0xc);
    if (0x1000 < uVar2) {
        uVar2 = 0x1000;
    }
    fcn.0040c1f8();
    *(int32_t *)(in_EAX + 0xc) = *(int32_t *)(in_EAX + 0xc) - uVar2;
    *(undefined4 *)(in_EAX + 0x14) = 0;
    *(uint32_t *)(in_EAX + 0x18) = uVar2;
    iVar1 = fcn.0040c738();
    if (iVar1 != param_1) {
        fcn.00409824();
        fcn.00403f88();
    }
    return;
}


undefined8 __fastcall fcn.0040cad8(uint32_t param_1)
{
    int32_t in_EAX;
    uint32_t uVar1;
    int32_t iStack20;
    
    iStack20 = 0;
    if (0 < (int32_t)param_1) {
        do {
            if (*(int32_t *)(in_EAX + 0x18) == 0) {
                if (*(int32_t *)(in_EAX + 0xc) == 0) break;
                fcn.0040ca08();
            }
            uVar1 = param_1;
            if (*(uint32_t *)(in_EAX + 0x18) <= param_1 && param_1 != *(uint32_t *)(in_EAX + 0x18)) {
                uVar1 = *(uint32_t *)(in_EAX + 0x18);
            }
            fcn.00402fbc();
            *(int32_t *)(in_EAX + 0x14) = *(int32_t *)(in_EAX + 0x14) + uVar1;
            *(int32_t *)(in_EAX + 0x18) = *(int32_t *)(in_EAX + 0x18) - uVar1;
            param_1 = param_1 - uVar1;
            iStack20 = iStack20 + uVar1;
        } while (0 < (int32_t)param_1);
    }
    return CONCAT44(iStack20, iStack20);
}


void fcn.0040ccdc(void)
{
    undefined auStack12 [4];
    undefined uStack8;
    
    uStack8 = 0x11;
    fcn.00409860(0, (int32_t)auStack12);
    fcn.00403f88();
    return;
}


void __fastcall fcn.0040cdf0(int32_t *param_1, int32_t *param_2)
{
    int32_t in_EAX;
    int32_t iVar1;
    
    *param_2 = in_EAX + 0x6c;
    *param_1 = 0;
    if (*(char *)(in_EAX + 0x10) == '\0') {
        iVar1 = (**(code **)(in_EAX + 8))();
        *param_1 = iVar1;
        if (*param_1 == 0) {
            *(undefined *)(in_EAX + 0x10) = 1;
        }
    }
    return;
}


void fcn.0040cdcc(void)
{
    int32_t in_EAX;
    
    *(undefined4 *)(in_EAX + 0x68) = 0;
    if (*(int32_t *)(in_EAX + 100) != 0) {
        sub.kernel32.dll_VirtualFree_1(*(int32_t *)(in_EAX + 100), 0, 0x8000);
        *(undefined4 *)(in_EAX + 100) = 0;
    }
    return;
}


void fcn.0040cc3c(void)
{
    undefined auStack12 [4];
    undefined uStack8;
    
    uStack8 = 0;
    fcn.00409860(0, (int32_t)auStack12);
    fcn.00403f88();
    return;
}


int32_t __cdecl fcn.0040d9d8(int32_t arg_8h, int32_t arg_ch, int32_t arg_10h)
{
    undefined4 *in_EAX;
    int32_t iVar1;
    int32_t in_EDX;
    int32_t var_4h;
    
    if (in_EDX == 0x50) {
        iVar1 = fcn.0040d2bc();
        if (iVar1 == 0) {
            *(int32_t *)arg_ch = ((0x300 << ((char)*in_EAX + (char)in_EAX[1] & 0x1fU)) + 0x736) * 2;
            *(undefined4 *)arg_8h = in_EAX[3];
        }
    } else {
        iVar1 = 1;
    }
    return iVar1;
}


void __fastcall fcn.0040da28(undefined4 param_1, undefined4 param_2)
{
    int32_t in_EAX;
    
    *(undefined4 *)(in_EAX + 0x10) = param_2;
    *(undefined4 *)(in_EAX + 0x1c) = param_1;
    *(undefined4 *)(in_EAX + 0x48) = 0xfffffffe;
    return;
}


void fcn.0040ce24(void)
{
    int32_t in_EAX;
    int32_t iVar1;
    int32_t iVar2;
    uint32_t uStack28;
    undefined auStack20 [4];
    undefined auStack16 [4];
    
    iVar1 = (**(code **)(in_EAX + 8))();
    if (iVar1 != 5) {
        fcn.0040cc3c();
    }
    fcn.00403250();
    iVar2 = 5;
    iVar1 = fcn.0040d9d8((int32_t)auStack16, (int32_t)auStack20, 5);
    if (iVar1 != 0) {
        fcn.0040cc3c();
    }
    if (0x4000000 < uStack28) {
        fcn.0040cc3c();
    }
    iVar2 = iVar2 + uStack28;
    if (iVar2 != *(int32_t *)(in_EAX + 0x68)) {
        fcn.0040cdcc();
        iVar1 = sub.kernel32.dll_VirtualAlloc_1(0, iVar2, 0x1000, 4);
        *(int32_t *)(in_EAX + 100) = iVar1;
        if (iVar1 == 0) {
            fcn.00409818();
        }
        *(int32_t *)(in_EAX + 0x68) = iVar2;
    }
    fcn.0040da28();
    *(undefined *)(in_EAX + 0x11) = 1;
    return;
}


// WARNING: Removing unreachable block (ram,0x0040d590)
// WARNING: Removing unreachable block (ram,0x0040d582)
// WARNING: Type propagation algorithm not settling
// WARNING: Could not reconcile some variable overlaps
// WARNING: [r2ghidra] Failed to match type signed int for variable var_34h to Decompiler type: Unknown type identifier
// signed
// WARNING: [r2ghidra] Failed to match type signed int for variable var_60h to Decompiler type: Unknown type identifier
// signed
// WARNING: [r2ghidra] Detected overlap for variable var_15h
// WARNING: [r2ghidra] Detected overlap for variable var_55h

uint32_t __cdecl fcn.0040d33c(int32_t arg_8h, uint32_t arg_ch)
{
    undefined uVar1;
    undefined4 uVar2;
    undefined4 uVar3;
    undefined4 uVar4;
    undefined4 uVar5;
    undefined4 uVar6;
    uint32_t uVar7;
    uint32_t uVar8;
    undefined4 *in_EAX;
    int32_t iVar9;
    int32_t iVar10;
    uint32_t uVar11;
    int32_t iVar12;
    int32_t iVar13;
    int32_t in_ECX;
    uint32_t uVar14;
    uint32_t uVar15;
    int32_t var_84h;
    int32_t var_80h;
    int32_t var_7ch;
    int32_t var_78h;
    int32_t var_74h;
    uint32_t var_70h;
    uint32_t var_6ch;
    int32_t var_68h;
    int32_t var_64h;
    undefined4 var_60h;
    uint32_t var_5ch;
    int32_t var_54h;
    int32_t var_50h;
    uint32_t var_4ch;
    int32_t var_48h;
    uint32_t var_44h;
    uint32_t var_40h;
    uint32_t var_3ch;
    int32_t var_38h;
    uint32_t var_34h;
    int32_t var_30h;
    int32_t var_2ch;
    int32_t var_28h;
    int32_t var_24h;
    int32_t var_20h;
    int32_t var_1ch;
    undefined var_15h;
    int32_t var_14h;
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    
    iVar10 = in_EAX[4];
    var_14h = 0;
    uVar2 = *in_EAX;
    uVar14 = in_EAX[0xd];
    iVar9 = in_EAX[0x11];
    var_28h = in_EAX[0xe];
    var_2ch = in_EAX[0xf];
    var_30h = in_EAX[0x10];
    var_34h = in_EAX[0x12];
    var_38h = in_EAX[0xb];
    var_3ch = in_EAX[0xc];
    var_40h = in_EAX[7];
    var_44h = in_EAX[3];
    uVar15 = in_EAX[10];
    uVar3 = in_EAX[8];
    uVar4 = in_EAX[9];
    uVar5 = in_EAX[5];
    uVar6 = in_EAX[6];
    *(undefined4 *)arg_8h = 0;
    if (var_34h == 0xffffffff) {
        var_70h = 0;
    } else {
        if (var_44h == 0) {
            var_40h = (uint32_t)&var_48h;
            var_44h = 1;
            var_48h._0_1_ = *(undefined *)(in_EAX + 0x13);
        }
        var_68h = in_ECX;
        if (var_34h != 0xfffffffe) {
code_r0x0040d523:
            while ((var_34h != 0 && ((uint32_t)var_14h < arg_ch))) {
                uVar11 = uVar15 - uVar14;
                if (var_44h <= uVar11) {
                    uVar11 = uVar11 + var_44h;
                }
                uVar1 = *(undefined *)(var_40h + uVar11);
                *(undefined *)(var_40h + uVar15) = uVar1;
                *(undefined *)var_68h = uVar1;
                var_14h = var_14h + 1;
                var_68h = var_68h + 1;
                uVar15 = uVar15 + 1;
                if (uVar15 == var_44h) {
                    uVar15 = 0;
                }
                var_34h = var_34h - 1;
            }
code_r0x0040d558:
            var_68h = in_ECX + var_14h;
joined_r0x0040d56a:
            uVar11 = uVar14;
            if (arg_ch <= (uint32_t)var_14h) {
code_r0x0040d948:
                in_EAX[8] = uVar3;
                in_EAX[9] = uVar4;
                in_EAX[10] = uVar15;
                in_EAX[0xb] = var_38h + var_14h;
                in_EAX[0xc] = var_3ch;
                in_EAX[0xd] = uVar11;
                in_EAX[0xe] = var_28h;
                in_EAX[0xf] = var_2ch;
                in_EAX[0x10] = var_30h;
                in_EAX[0x11] = iVar9;
                in_EAX[0x12] = var_34h;
                *(undefined *)(in_EAX + 0x13) = (undefined)var_48h;
                in_EAX[5] = uVar5;
                in_EAX[6] = uVar6;
                *(int32_t *)arg_8h = var_14h;
                return 0;
            }
            iVar10 = fcn.0040d094();
            if (iVar10 == 0) {
                if (iVar9 < 7) {
                    var_15h = fcn.0040d1a4();
                } else {
                    var_15h = fcn.0040d1d0();
                }
                *(undefined *)var_68h = var_15h;
                var_14h = var_14h + 1;
                var_68h = var_68h + 1;
                if (var_3ch < var_44h) {
                    var_3ch = var_3ch + 1;
                }
                *(undefined *)(var_40h + uVar15) = var_15h;
                uVar15 = uVar15 + 1;
                if (uVar15 == var_44h) {
                    uVar15 = 0;
                }
                if (iVar9 < 4) {
                    iVar9 = 0;
                } else {
                    if (iVar9 < 10) {
                        iVar9 = iVar9 + -3;
                    } else {
                        iVar9 = iVar9 + -6;
                    }
                }
                goto joined_r0x0040d56a;
            }
            iVar10 = fcn.0040d094();
            if (iVar10 == 1) {
                iVar10 = fcn.0040d094();
                uVar7 = var_2ch;
                if (iVar10 == 0) {
                    iVar10 = fcn.0040d094();
                    uVar8 = var_28h;
                    if (iVar10 == 0) goto code_r0x0040d6e5;
                } else {
                    iVar10 = fcn.0040d094();
                    uVar11 = var_28h;
                    uVar8 = uVar14;
                    if ((iVar10 != 0) && (iVar10 = fcn.0040d094(), uVar11 = var_2ch, uVar7 = var_28h, iVar10 != 0)) {
                        uVar11 = var_30h;
                        var_30h = var_2ch;
                    }
                }
                var_28h = uVar8;
                var_2ch = uVar7;
                var_34h = fcn.0040d244();
                uVar7 = var_2ch;
                uVar14 = var_28h;
                if (iVar9 < 7) {
                    iVar9 = 8;
                } else {
                    iVar9 = 0xb;
                }
            } else {
                if (iVar9 < 7) {
                    iVar9 = 7;
                } else {
                    iVar9 = 10;
                }
                var_34h = fcn.0040d244();
                uVar11 = fcn.0040d11c();
                if (3 < (int32_t)uVar11) {
                    iVar10 = (uVar11 & 1 | 2) << ((char)((int32_t)uVar11 >> 1) - 1U & 0x1f);
                    if ((int32_t)uVar11 < 0xe) {
                        iVar12 = fcn.0040d160();
                        uVar11 = iVar10 + iVar12;
                    } else {
                        iVar12 = fcn.0040d034();
                        iVar13 = fcn.0040d160();
                        uVar11 = iVar10 + iVar12 * 0x10 + iVar13;
                    }
                }
                uVar11 = uVar11 + 1;
                var_30h = var_2ch;
                uVar7 = var_28h;
                if (uVar11 == 0) {
                    var_34h = 0xffffffff;
                    var_2ch = var_28h;
                    var_28h = uVar14;
                    goto code_r0x0040d948;
                }
            }
            var_28h = uVar14;
            var_2ch = uVar7;
            var_34h = var_34h + 2;
            if (var_3ch < uVar11) {
                return 1;
            }
            if (var_34h < var_44h - var_3ch) {
                var_3ch = var_3ch + var_34h;
            } else {
                var_3ch = var_44h;
            }
            do {
                uVar14 = uVar15 - uVar11;
                if (var_44h <= uVar14) {
                    uVar14 = uVar14 + var_44h;
                }
                uVar1 = *(undefined *)(var_40h + uVar14);
                *(undefined *)(var_40h + uVar15) = uVar1;
                uVar15 = uVar15 + 1;
                if (uVar15 == var_44h) {
                    uVar15 = 0;
                }
                var_34h = var_34h - 1;
                *(undefined *)var_68h = uVar1;
                var_14h = var_14h + 1;
                var_68h = var_68h + 1;
                uVar14 = uVar11;
            } while ((var_34h != 0) && ((uint32_t)var_14h < arg_ch));
            goto joined_r0x0040d56a;
        }
        iVar9 = 0x300 << ((char)in_EAX[1] + (char)uVar2 & 0x1fU);
        var_50h = 0;
        var_68h = iVar10;
        if (iVar9 != -0x736) {
            do {
                *(undefined2 *)var_68h = 0x400;
                var_50h = var_50h + 1;
                var_68h = var_68h + 2;
            } while ((uint32_t)var_50h < iVar9 + 0x736U);
        }
        var_30h = 1;
        var_2ch = 1;
        var_28h = 1;
        uVar14 = 1;
        var_38h = 0;
        var_3ch = 0;
        iVar9 = 0;
        uVar15 = 0;
        *(undefined *)((var_40h - 1) + var_44h) = 0;
        fcn.0040cff4();
        if (var_70h == 0) {
            if (var_6ch == 0) {
                var_34h = 0;
                var_68h = in_ECX;
                goto code_r0x0040d523;
            }
            var_70h = 1;
        }
    }
    return var_70h;
code_r0x0040d6e5:
    if (var_3ch == 0) {
        return 1;
    }
    if (iVar9 < 7) {
        iVar9 = 9;
    } else {
        iVar9 = 0xb;
    }
    uVar11 = uVar15 - uVar14;
    if (var_44h <= uVar11) {
        uVar11 = uVar11 + var_44h;
    }
    uVar1 = *(undefined *)(var_40h + uVar11);
    *(undefined *)(var_40h + uVar15) = uVar1;
    uVar15 = uVar15 + 1;
    if (uVar15 == var_44h) {
        uVar15 = 0;
    }
    *(undefined *)var_68h = uVar1;
    var_14h = var_14h + 1;
    if (var_3ch < var_44h) {
        var_3ch = var_3ch + 1;
    }
    goto code_r0x0040d558;
}


void fcn.0040cd3c(void)
{
    int32_t **in_FS_OFFSET;
    int32_t *arg_8h;
    int32_t *piStack32;
    undefined4 uStack28;
    undefined *puStack24;
    int32_t var_4h;
    
    puStack24 = &stack0xfffffffc;
    var_4h = 0;
    uStack28 = 0x40cd85;
    piStack32 = *in_FS_OFFSET;
    *in_FS_OFFSET = (int32_t *)&piStack32;
    arg_8h = &var_4h;
    fcn.004082d4((int32_t)arg_8h);
    fcn.0040ccdc();
    *in_FS_OFFSET = arg_8h;
    uStack28 = 0x40cd8c;
    piStack32 = (int32_t *)0x40cd84;
    fcn.00404c88();
    return;
}


undefined8 __fastcall fcn.0040cfb4(int32_t param_1)
{
    uint8_t *puVar1;
    uint8_t **in_EAX;
    uint8_t *puVar2;
    uint32_t uVar3;
    
    puVar2 = *in_EAX;
    if (puVar2 == in_EAX[1]) {
        puVar2 = (uint8_t *)(**(code **)in_EAX[4])();
        in_EAX[5] = puVar2;
        in_EAX[1] = *in_EAX + param_1;
        if (param_1 == 0) {
            in_EAX[6] = (uint8_t *)0x1;
            uVar3 = CONCAT31((unkint3)((uint32_t)puVar2 >> 8), 0xff);
            goto code_r0x0040cfed;
        }
    }
    puVar1 = *in_EAX;
    *in_EAX = *in_EAX + 1;
    uVar3 = (uint32_t)puVar2 & 0xffffff00 | (uint32_t)*puVar1;
code_r0x0040cfed:
    return CONCAT44(param_1, uVar3);
}


undefined4 __fastcall fcn.0040d094(undefined4 param_1, int32_t param_2)
{
    uint8_t uVar1;
    uint16_t *in_EAX;
    uint32_t uVar2;
    
    uVar2 = (*(uint32_t *)(param_2 + 8) >> 0xb) * (uint32_t)*in_EAX;
    if (*(uint32_t *)(param_2 + 0xc) <= uVar2 && uVar2 - *(uint32_t *)(param_2 + 0xc) != 0) {
        *(uint32_t *)(param_2 + 8) = uVar2;
        *in_EAX = *in_EAX + (int16_t)((int32_t)(0x800 - (uint32_t)*in_EAX) >> 5);
        if (*(uint32_t *)(param_2 + 8) < 0x1000000) {
            uVar2 = fcn.0040cfb4();
            *(uint32_t *)(param_2 + 0xc) = uVar2 & 0xff | *(int32_t *)(param_2 + 0xc) << 8;
            *(int32_t *)(param_2 + 8) = *(int32_t *)(param_2 + 8) << 8;
        }
        return 0;
    }
    *(int32_t *)(param_2 + 8) = *(int32_t *)(param_2 + 8) - uVar2;
    *(int32_t *)(param_2 + 0xc) = *(int32_t *)(param_2 + 0xc) - uVar2;
    *in_EAX = *in_EAX - (int16_t)((int32_t)(uint32_t)*in_EAX >> 5);
    if (*(uint32_t *)(param_2 + 8) < 0x1000000) {
        uVar1 = fcn.0040cfb4();
        *(uint32_t *)(param_2 + 0xc) = (uint32_t)uVar1 | *(int32_t *)(param_2 + 0xc) << 8;
        *(int32_t *)(param_2 + 8) = *(int32_t *)(param_2 + 8) << 8;
    }
    return 1;
}


undefined8 __fastcall fcn.0040d11c(undefined4 param_1, int32_t param_2)
{
    int32_t iVar1;
    int32_t iVar2;
    int32_t iVar3;
    
    iVar2 = 1;
    iVar3 = param_2;
    if (param_2 != 0) {
        do {
            iVar1 = fcn.0040d094();
            iVar3 = iVar3 + -1;
            iVar2 = iVar1 + iVar2 * 2;
        } while (iVar3 != 0);
    }
    return CONCAT44(param_2, iVar2 - (1 << ((uint8_t)param_2 & 0x1f)));
}


void fcn.0040cff4(void)
{
    uint8_t uVar1;
    undefined4 *in_EAX;
    int32_t iVar2;
    
    in_EAX[1] = 0;
    *in_EAX = 0;
    in_EAX[6] = 0;
    in_EAX[3] = 0;
    in_EAX[2] = 0xffffffff;
    iVar2 = 0;
    do {
        uVar1 = fcn.0040cfb4();
        iVar2 = iVar2 + 1;
        in_EAX[3] = (uint32_t)uVar1 | in_EAX[3] << 8;
    } while (iVar2 < 5);
    return;
}


// WARNING: Could not reconcile some variable overlaps

undefined8 __fastcall fcn.0040d1d0(uint32_t param_1)
{
    uint32_t uVar1;
    uint32_t uVar2;
    uint32_t uVar3;
    uint32_t uStack20;
    
    uVar2 = 1;
    uStack20 = param_1;
    do {
        uVar3 = uStack20 & 0xff;
        uStack20 = uStack20 & 0xffffff00 | (uint32_t)(uint8_t)((char)uStack20 << 1);
        uVar1 = fcn.0040d094();
        uVar2 = uVar2 * 2 | uVar1;
        if (uVar1 != (int32_t)uVar3 >> 7) goto joined_r0x0040d217;
    } while ((int32_t)uVar2 < 0x100);
code_r0x0040d23b:
    return CONCAT44(uStack20, uVar2);
joined_r0x0040d217:
    while ((int32_t)uVar2 < 0x100) {
        uVar1 = fcn.0040d094();
        uVar2 = uVar1 | uVar2 * 2;
    }
    goto code_r0x0040d23b;
}


uint32_t fcn.0040d1a4(void)
{
    uint32_t uVar1;
    uint32_t uVar2;
    
    uVar2 = 1;
    do {
        uVar1 = fcn.0040d094();
        uVar2 = uVar1 | uVar2 * 2;
    } while ((int32_t)uVar2 < 0x100);
    return uVar2;
}


int32_t fcn.0040d244(void)
{
    int32_t iVar1;
    
    iVar1 = fcn.0040d094();
    if (iVar1 == 0) {
        iVar1 = fcn.0040d11c();
    } else {
        iVar1 = fcn.0040d094();
        if (iVar1 == 0) {
            iVar1 = fcn.0040d11c();
            iVar1 = iVar1 + 8;
        } else {
            iVar1 = fcn.0040d11c();
            iVar1 = iVar1 + 0x10;
        }
    }
    return iVar1;
}


undefined8 __fastcall fcn.0040d160(undefined4 param_1, int32_t param_2)
{
    int32_t iVar1;
    int32_t iVar2;
    uint32_t uVar3;
    
    uVar3 = 0;
    iVar2 = 0;
    if (0 < param_2) {
        do {
            iVar1 = fcn.0040d094();
            uVar3 = uVar3 | iVar1 << ((uint8_t)iVar2 & 0x1f);
            iVar2 = iVar2 + 1;
        } while (iVar2 < param_2);
    }
    return CONCAT44(param_1, uVar3);
}


undefined8 __fastcall fcn.0040d034(undefined4 param_1, int32_t param_2)
{
    uint8_t uVar1;
    int32_t in_EAX;
    uint32_t uVar2;
    uint32_t uVar3;
    uint32_t uVar4;
    
    uVar3 = 0;
    uVar2 = *(uint32_t *)(in_EAX + 8);
    uVar4 = *(uint32_t *)(in_EAX + 0xc);
    if (param_2 != 0) {
        do {
            uVar2 = uVar2 >> 1;
            uVar3 = uVar3 * 2;
            if (uVar2 <= uVar4) {
                uVar4 = uVar4 - uVar2;
                uVar3 = uVar3 | 1;
            }
            if (uVar2 < 0x1000000) {
                uVar2 = uVar2 << 8;
                uVar1 = fcn.0040cfb4();
                uVar4 = (uint32_t)uVar1 | uVar4 << 8;
            }
            param_2 = param_2 + -1;
        } while (param_2 != 0);
    }
    *(uint32_t *)(in_EAX + 8) = uVar2;
    *(uint32_t *)(in_EAX + 0xc) = uVar4;
    return CONCAT44(in_EAX, uVar3);
}


undefined4 __fastcall fcn.0040d2bc(int32_t param_1, uint8_t *param_2)
{
    uint32_t *in_EAX;
    uint8_t uVar1;
    int32_t iVar2;
    int32_t iVar3;
    
    if (param_1 < 5) {
        return 1;
    }
    uVar1 = *param_2;
    if (uVar1 < 0xe1) {
        in_EAX[2] = 0;
        while (0x2c < uVar1) {
            in_EAX[2] = in_EAX[2] + 1;
            uVar1 = uVar1 - 0x2d;
        }
        in_EAX[1] = 0;
        while (8 < uVar1) {
            in_EAX[1] = in_EAX[1] + 1;
            uVar1 = uVar1 - 9;
        }
        *in_EAX = (uint32_t)uVar1;
        param_2 = param_2 + 1;
        in_EAX[3] = 0;
        iVar2 = 0;
        do {
            uVar1 = *param_2;
            iVar3 = iVar2 + 1;
            param_2 = param_2 + 1;
            in_EAX[3] = in_EAX[3] + ((uint32_t)uVar1 << ((uint8_t)(iVar2 << 3) & 0x1f));
            iVar2 = iVar3;
        } while (iVar3 < 4);
        if (in_EAX[3] == 0) {
            in_EAX[3] = 1;
        }
        return 0;
    }
    return 1;
}


void fcn.0040df78(void)
{
    fcn.00409824();
    fcn.00403f88();
    return;
}


void fcn.0040df5c(void)
{
    char cVar1;
    int32_t unaff_ESI;
    
    cVar1 = -0x23;
    do {
        fcn.00404c98(unaff_ESI);
        cVar1 = cVar1 + -1;
    } while (cVar1 != '\0');
    return;
}


bool __fastcall fcn.0040e134(undefined4 param_1, undefined *param_2)
{
    char in_AL;
    int32_t iVar1;
    bool bVar2;
    
    *param_2 = 0;
    if (in_AL == '\0') {
        return true;
    }
    if (*(char *)0x418524 == '\0') {
        sub.kernel32.dll_SetLastError(1);
        bVar2 = false;
    } else {
        iVar1 = (**(code **)0x41851c)(param_2 + 4);
        bVar2 = iVar1 != 0;
        if (bVar2) {
            *param_2 = 1;
        }
    }
    return bVar2;
}


void fcn.0040e170(void)
{
    char *in_EAX;
    
    if (*in_EAX != '\0') {
        (**(code **)0x418520)(*(undefined4 *)(in_EAX + 4));
    }
    return;
}


uint32_t fcn.0040b700(void)
{
    int32_t iVar1;
    
    iVar1 = fcn.0040b698();
    return iVar1 + 1U & 0xffffff00 | (uint32_t)(iVar1 + 1U != 0);
}


// WARNING: Could not reconcile some variable overlaps
// WARNING: [r2ghidra] Failed to match type signed int for variable var_8h to Decompiler type: Unknown type identifier
// signed
// WARNING: [r2ghidra] Failed to match type signed int for variable var_ch to Decompiler type: Unknown type identifier
// signed
// WARNING: [r2ghidra] Detected overlap for variable var_ch

void __fastcall fcn.0040532c(int32_t param_1, int32_t *param_2)
{
    int32_t in_EAX;
    int32_t iVar1;
    int32_t iVar2;
    undefined4 *in_FS_OFFSET;
    undefined4 uStack44;
    undefined4 uStack40;
    undefined *puStack36;
    uint32_t var_dh;
    int32_t var_8h;
    uint32_t var_4h;
    
    puStack36 = (undefined *)0x405345;
    fcn.00404c80();
    uStack40 = 0x40544a;
    uStack44 = *in_FS_OFFSET;
    *in_FS_OFFSET = &uStack44;
    iVar1 = in_EAX;
    puStack36 = &stack0xfffffffc;
    if ((in_EAX != 0) && (puStack36 = &stack0xfffffffc, *(int16_t *)(in_EAX + -10) != 2)) {
        puStack36 = &stack0xfffffffc;
        iVar1 = fcn.00404820();
    }
    if (iVar1 != 0) {
        iVar1 = *(int32_t *)(iVar1 + -4);
    }
    if (0 < iVar1) {
        iVar2 = *param_2;
        if ((iVar2 != 0) && (*(int16_t *)(iVar2 + -10) != 2)) {
            iVar2 = fcn.00404820();
        }
        if (iVar2 != 0) {
            iVar2 = *(int32_t *)(iVar2 + -4);
        }
        if (param_1 < 1) {
            var_8h = 0;
        } else {
            var_8h = param_1 + -1;
            if (iVar2 < param_1 + -1) {
                var_8h = iVar2;
            }
        }
        var_dh._0_1_ = *param_2 == in_EAX;
        unique0x00000400 = iVar1 + iVar2;
        if ((int32_t)unique0x00000400 < 0) {
            fcn.0040380c();
        }
        fcn.00404f00();
        if (var_8h < iVar2) {
            fcn.00402fbc();
        }
        if ((char)var_dh == '\0') {
            fcn.00402fbc();
        } else {
            fcn.00402fbc();
        }
    }
    *in_FS_OFFSET = uStack44;
    puStack36 = (undefined *)0x405451;
    uStack40 = 0x405449;
    fcn.00404c88();
    return;
}


undefined4 fcn.004030e4(void)
{
    uint32_t in_EAX;
    
    *(uint32_t *)0x412008 = *(int32_t *)0x412008 * 0x8088405 + 1;
    return (int32_t)((uint64_t)in_EAX * (uint64_t)*(uint32_t *)0x412008 >> 0x20);
}


// WARNING: [r2ghidra] Failed to match type signed int for variable var_8h to Decompiler type: Unknown type identifier
// signed
// WARNING: [r2ghidra] Failed to match type signed int for variable var_ch to Decompiler type: Unknown type identifier
// signed
// WARNING: [r2ghidra] Detected overlap for variable var_ch

void fcn.0040e298(void)
{
    int32_t iVar1;
    int32_t *in_FS_OFFSET;
    int32_t arg_8h;
    undefined4 uStack28;
    undefined *puStack24;
    int32_t var_4h;
    
    puStack24 = &stack0xfffffffc;
    var_4h = 0;
    uStack28 = 0x40e300;
    arg_8h = *in_FS_OFFSET;
    *in_FS_OFFSET = (int32_t)&stack0xffffffe0;
    fcn.00404c98(arg_8h);
    iVar1 = 5;
    do {
        fcn.00404e04();
        fcn.0040532c();
        iVar1 = iVar1 + -1;
    } while (iVar1 != 0);
    *in_FS_OFFSET = arg_8h;
    puStack24 = (undefined *)0x40e307;
    uStack28 = 0x40e2ff;
    fcn.00404c88();
    return;
}


// WARNING: Variable defined which should be unmapped: var_1h
// WARNING: Could not reconcile some variable overlaps
// WARNING: [r2ghidra] Failed to match type DWORD for variable var_10h to Decompiler type: Unknown type identifier DWORD

undefined4 fcn.0040e1f8(void)
{
    char cVar1;
    undefined4 uVar2;
    undefined4 *in_FS_OFFSET;
    undefined4 uStack40;
    undefined4 uStack36;
    undefined *puStack32;
    undefined4 var_10h;
    int32_t var_ch;
    int32_t var_1h;
    
    puStack32 = (undefined *)0x40e20e;
    cVar1 = fcn.0040e134();
    if (cVar1 == '\0') {
        return 0;
    }
    uStack36 = 0x40e24e;
    uStack40 = *in_FS_OFFSET;
    *in_FS_OFFSET = &uStack40;
    puStack32 = (undefined *)((int32_t)&var_1h + 1);
    var_1h._0_1_ = fcn.0040b700();
    var_10h = sub.kernel32.dll_GetLastError();
    *in_FS_OFFSET = uStack40;
    puStack32 = (undefined *)0x40e255;
    uStack36 = 0x40e24d;
    uVar2 = fcn.0040e170();
    return uVar2;
}


undefined loc.0040e25e(void)
{
    int32_t unaff_EBP;
    int32_t var_1h;
    
    return *(undefined *)(unaff_EBP + -1);
}


// WARNING: [r2ghidra] Failed to match type LPWSTR for variable lpBuffer to Decompiler type: Unknown type identifier
// LPWSTR
// WARNING: [r2ghidra] Var arg_2000h is stack pointer based, which is not supported for decompilation.

void fcn.0040b9fc(void)
{
    char cVar1;
    int32_t *in_EAX;
    int32_t *in_FS_OFFSET;
    int32_t arg_8h;
    undefined4 uStack24;
    undefined *puStack20;
    int32_t var_8h;
    int32_t var_4h;
    
    puStack20 = &stack0xfffffffc;
    var_8h = 0;
    uStack24 = 0x40bab3;
    arg_8h = *in_FS_OFFSET;
    *in_FS_OFFSET = (int32_t)&stack0xffffffe4;
    fcn.0040b710();
    if (*in_EAX != 0) {
        cVar1 = fcn.0040b6ec();
        if (cVar1 != '\0') goto code_r0x0040ba79;
    }
    fcn.0040b710();
    if (*in_EAX != 0) {
        cVar1 = fcn.0040b6ec();
        if (cVar1 != '\0') goto code_r0x0040ba79;
    }
    if (**(int32_t **)0x412c80 == 2) {
        fcn.0040b710();
        if (*in_EAX != 0) {
            cVar1 = fcn.0040b6ec();
            if (cVar1 != '\0') goto code_r0x0040ba79;
        }
    }
    fcn.0040b9a4();
code_r0x0040ba79:
    fcn.0040b524();
    fcn.0040b2e0();
    fcn.00404c98(arg_8h);
    *in_FS_OFFSET = arg_8h;
    puStack20 = (undefined *)0x40baba;
    uStack24 = 0x40bab2;
    fcn.00404c90();
    return;
}


// WARNING: [r2ghidra] Removing arg arg_4h because it doesn't fit into ProtoModel
// WARNING: [r2ghidra] Failed to match type DWORD for variable var_10h to Decompiler type: Unknown type identifier DWORD

void __cdecl fcn.0040e310(int32_t arg_8h)
{
    char cVar1;
    int32_t iVar2;
    undefined4 in_EDX;
    int32_t iVar3;
    int32_t *in_FS_OFFSET;
    int32_t extraout_var;
    int32_t arg_8h_00;
    undefined4 uStack52;
    undefined *puStack48;
    int32_t var_1ch;
    int32_t var_18h;
    int32_t var_14h;
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    
    var_1ch = 0;
    puStack48 = (undefined *)0x40e334;
    fcn.00404c80();
    uStack52 = 0x40e407;
    *in_FS_OFFSET = (int32_t)&stack0xffffffc8;
    puStack48 = &stack0xfffffffc;
    fcn.0040b2e0();
    fcn.00404cec();
    iVar2 = fcn.004030e4();
    iVar3 = iVar2;
    do {
        iVar3 = iVar3 + 1;
        if (0x1ffffff < iVar3) {
            iVar3 = 0;
        }
        if (iVar2 == iVar3) {
            fcn.0040b62c();
            fcn.0040df38();
            fcn.00409824();
            fcn.00403f88();
        }
        fcn.0040e298(0x40e424, in_EDX);
        fcn.0040513c();
        arg_8h_00 = extraout_var;
        cVar1 = fcn.0040e1f8();
    } while (cVar1 != '\0');
    fcn.00404c98(arg_8h_00);
    *in_FS_OFFSET = arg_8h_00;
    fcn.00404c90(0x40e40e);
    fcn.00404c90();
    return;
}


void __cdecl fcn.00407ee8(int32_t arg_8h)
{
    fcn.00407e1c();
    fcn.00404dc4();
    return;
}


// WARNING: [r2ghidra] Failed to match type BOOL for variable var_4h to Decompiler type: Unknown type identifier BOOL
// WARNING: [r2ghidra] Failed to match type DWORD for variable var_10h to Decompiler type: Unknown type identifier DWORD

undefined4 fcn.0040e180(void)
{
    char cVar1;
    undefined4 uVar2;
    undefined4 *in_FS_OFFSET;
    undefined4 uStack40;
    undefined4 uStack36;
    undefined *puStack32;
    undefined4 var_10h;
    int32_t var_ch;
    undefined4 var_4h;
    
    puStack32 = (undefined *)0x40e196;
    cVar1 = fcn.0040e134();
    if (cVar1 == '\0') {
        return 0;
    }
    uStack36 = 0x40e1dd;
    uStack40 = *in_FS_OFFSET;
    *in_FS_OFFSET = &uStack40;
    puStack32 = &stack0xfffffffc;
    uVar2 = fcn.00404d24();
    sub.kernel32.dll_DeleteFileW();
    var_10h = sub.kernel32.dll_GetLastError();
    *in_FS_OFFSET = uVar2;
    uStack36 = 0x40e1e4;
    uStack40 = 0x40e1dc;
    uVar2 = fcn.0040e170();
    return uVar2;
}


undefined4 loc.0040e1ed(void)
{
    int32_t unaff_EBP;
    int32_t var_4h;
    
    return *(undefined4 *)(unaff_EBP + -4);
}


// WARNING: Removing unreachable block (ram,0x00407cc0)

uint32_t __fastcall fcn.00407bdc(undefined4 param_1, int32_t param_2)
{
    int32_t iVar1;
    uint32_t in_EAX;
    uint32_t uVar2;
    int32_t iVar3;
    uint32_t uVar4;
    uint32_t uVar5;
    bool bVar6;
    
    if (in_EAX == 0) {
        if (param_2 != 0) {
            in_EAX = -*(int32_t *)(param_2 + -4);
        }
        return in_EAX;
    }
    if (param_2 == 0) {
        return *(uint32_t *)(in_EAX - 4);
    }
    if (*(int16_t *)(in_EAX - 10) != 2) {
        fcn.00404e6c();
        in_EAX = 0;
    }
    if (*(int16_t *)(param_2 + -10) != 2) {
        fcn.00404e6c();
        param_2 = 0;
    }
    uVar2 = *(uint32_t *)(param_2 + -4);
    uVar5 = *(uint32_t *)(in_EAX - 4) - uVar2;
    iVar3 = (-(uint32_t)(*(uint32_t *)(in_EAX - 4) < uVar2) & uVar5) + uVar2;
    iVar1 = in_EAX + iVar3 * 2;
    param_2 = param_2 + iVar3 * 2;
    iVar3 = -iVar3;
    if (iVar3 != 0) {
        do {
            uVar2 = *(uint32_t *)(iVar1 + iVar3 * 2);
            uVar4 = *(uint32_t *)(param_2 + iVar3 * 2);
            if (uVar2 != uVar4) {
                if ((int16_t)uVar2 != (int16_t)uVar4) {
                    uVar2 = uVar2 & 0xffff;
                    uVar4 = uVar4 & 0xffff;
                    if ((0x60 < uVar2) && (uVar2 < 0x7b)) {
                        uVar2 = uVar2 - 0x20;
                    }
                    if ((0x60 < uVar4) && (uVar4 < 0x7b)) {
                        uVar4 = uVar4 - 0x20;
                    }
                    if (uVar2 - uVar4 != 0) {
                        return uVar2 - uVar4;
                    }
                    uVar2 = *(uint32_t *)(iVar1 + iVar3 * 2) & 0xffff0000;
                    uVar4 = *(uint32_t *)(param_2 + iVar3 * 2) & 0xffff0000;
                    if (uVar2 == uVar4) goto code_r0x00407cb0;
                }
                uVar2 = uVar2 >> 0x10;
                uVar4 = uVar4 >> 0x10;
                if ((0x60 < uVar2) && (uVar2 < 0x7b)) {
                    uVar2 = uVar2 - 0x20;
                }
                if ((0x60 < uVar4) && (uVar4 < 0x7b)) {
                    uVar4 = uVar4 - 0x20;
                }
                if (uVar2 - uVar4 != 0) {
                    return uVar2 - uVar4;
                }
            }
code_r0x00407cb0:
            bVar6 = SCARRY4(iVar3, 2);
            iVar3 = iVar3 + 2;
        } while (bVar6 != iVar3 < 0);
    }
    return uVar5;
}


// WARNING: [r2ghidra] Failed to match type HKEY for variable hKey to Decompiler type: Unknown type identifier HKEY
// WARNING: [r2ghidra] Failed to match type PHKEY for variable phkResult to Decompiler type: Unknown type identifier
// PHKEY
// WARNING: [r2ghidra] Failed to match type DWORD for variable ulOptions to Decompiler type: Unknown type identifier
// DWORD

void fcn.0040bcb4(void)
{
    int32_t iVar1;
    code *pcVar2;
    undefined4 *in_FS_OFFSET;
    undefined4 in_stack_ffffffc0;
    int32_t arg_ch;
    undefined4 uStack36;
    undefined4 uStack32;
    undefined *puStack28;
    int32_t var_10h;
    uint32_t var_ch;
    undefined4 hKey;
    int32_t var_4h;
    
    puStack28 = &stack0xfffffffc;
    var_10h = 0;
    uStack32 = 0x40bdae;
    uStack36 = *in_FS_OFFSET;
    *in_FS_OFFSET = &uStack36;
    arg_ch = 0x40bdf0;
    iVar1 = sub.kernel32.dll_GetModuleHandleW_2(0x40bdf0, 0x40bdbc);
    pcVar2 = (code *)fcn.00406728(iVar1, arg_ch);
    if (pcVar2 == (code *)0x0) {
        if (**(int32_t **)0x412c80 == 2) {
            in_stack_ffffffc0 = 0x40bd16;
            iVar1 = fcn.0040bc8c(&hKey, 1, 0);
            if (iVar1 == 0) {
                fcn.0040bc80();
                sub.advapi32.dll_RegCloseKey_1();
                in_stack_ffffffc0 = hKey;
            }
        } else {
            in_stack_ffffffc0 = 0x40bd4e;
            iVar1 = fcn.0040bc8c(&hKey, 1, 0);
            if (iVar1 == 0) {
                fcn.0040bc80();
                sub.advapi32.dll_RegCloseKey_1();
                in_stack_ffffffc0 = hKey;
            }
        }
        fcn.00405058();
        fcn.004032ec();
    } else {
        (*pcVar2)();
    }
    *in_FS_OFFSET = in_stack_ffffffc0;
    fcn.00404c88(0x40bdb5);
    fcn.00404c88();
    return;
}


// WARNING: [r2ghidra] Failed to match type LPWSTR for variable lpLCData to Decompiler type: Unknown type identifier
// LPWSTR

undefined4 fcn.0040e658(void)
{
    undefined2 in_AX;
    int32_t iVar1;
    undefined4 lpLCData;
    
    iVar1 = sub.kernel32.dll_GetLocaleInfoW_1(in_AX, 0x20001004, &lpLCData, 2);
    if (iVar1 < 1) {
        lpLCData = 0xffffffff;
    }
    return lpLCData;
}


void fcn.0040b89c(void)
{
    int16_t *piVar1;
    undefined4 *in_FS_OFFSET;
    undefined4 uStack28;
    undefined4 uStack24;
    undefined *puStack20;
    int32_t var_4h;
    
    puStack20 = &stack0xfffffffc;
    var_4h = 0;
    uStack24 = 0x40b8ed;
    uStack28 = *in_FS_OFFSET;
    *in_FS_OFFSET = &uStack28;
    sub.kernel32.dll_GetCommandLineW_1();
    piVar1 = (int16_t *)fcn.0040b7bc();
    while (*piVar1 != 0) {
        piVar1 = (int16_t *)fcn.0040b7bc();
    }
    *in_FS_OFFSET = uStack28;
    puStack20 = (undefined *)0x40b8f4;
    uStack24 = 0x40b8ec;
    fcn.00404c88();
    return;
}


void fcn.0040e788(void)
{
    int32_t arg_8h;
    int32_t *in_FS_OFFSET;
    undefined4 uVar1;
    int32_t *piVar2;
    int32_t iStack48;
    undefined4 uStack44;
    undefined *puStack40;
    int32_t var_18h;
    int32_t var_14h;
    int32_t var_10h;
    int32_t var_ch;
    int32_t var_8h;
    int32_t var_4h;
    
    puStack40 = &stack0xfffffffc;
    var_4h = 0;
    var_18h = 0;
    uStack44 = 0x40e82f;
    iStack48 = *in_FS_OFFSET;
    *in_FS_OFFSET = (int32_t)&iStack48;
    arg_8h = sub.kernel32.dll_GetLastError();
    piVar2 = &var_4h;
    uVar1 = 0;
    fcn.00407ee8(arg_8h);
    fcn.0040bf84(arg_8h, uVar1, piVar2);
    fcn.0040df08(arg_8h);
    fcn.00409824();
    fcn.00403f88();
    *in_FS_OFFSET = arg_8h;
    fcn.00404c90(0x40e836);
    fcn.00404c88();
    return;
}


void fcn.0040eb3c(void)
{
    int32_t iVar1;
    undefined *apuStack32 [7];
    
    while( true ) {
        iVar1 = sub.user32.dll_PeekMessageW(apuStack32, 0, 0, 0, 1);
        if (iVar1 == 0) break;
        sub.user32.dll_TranslateMessage(apuStack32);
        apuStack32[0] = (undefined *)apuStack32;
        sub.user32.dll_DispatchMessageW();
    }
    return;
}


void fcn.0040ed50(void)
{
    undefined4 *in_EAX;
    
    LOCK();
    *in_EAX = *in_EAX;
    return;
}


